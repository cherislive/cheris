{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/README.md","path":"README.md","modified":1,"renderable":0},{"_id":"themes/cheris/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"themes/cheris/source/images/avatar.png","path":"images/avatar.png","modified":1,"renderable":1},{"_id":"themes/cheris/source/images/article.jpg","path":"images/article.jpg","modified":1,"renderable":1},{"_id":"themes/cheris/source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/cheris/source/images/icon-bubble.svg","path":"images/icon-bubble.svg","modified":1,"renderable":1},{"_id":"themes/cheris/source/images/icon-categories.svg","path":"images/icon-categories.svg","modified":1,"renderable":1},{"_id":"themes/cheris/source/images/icon-tags.svg","path":"images/icon-tags.svg","modified":1,"renderable":1},{"_id":"themes/cheris/source/images/icon-heart.svg","path":"images/icon-heart.svg","modified":1,"renderable":1},{"_id":"themes/cheris/source/images/logo.png","path":"images/logo.png","modified":1,"renderable":1},{"_id":"themes/cheris/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/cheris/source/css/style-2.styl","path":"css/style-2.styl","modified":1,"renderable":1},{"_id":"source/projrct/treenode/index.html","path":"projrct/treenode/index.html","modified":1,"renderable":0},{"_id":"source/projrct/treenode/treenode.js","path":"projrct/treenode/treenode.js","modified":1,"renderable":0},{"_id":"source/projrct/vueDemo/index.html","path":"projrct/vueDemo/index.html","modified":1,"renderable":0},{"_id":"source/projrct/vue-mint-slider/index.html","path":"projrct/vue-mint-slider/index.html","modified":1,"renderable":0},{"_id":"source/projrct/treenode/jquery-1.8.2.min.js","path":"projrct/treenode/jquery-1.8.2.min.js","modified":1,"renderable":0},{"_id":"source/projrct/vue-mint-slider/dist/example.css","path":"projrct/vue-mint-slider/dist/example.css","modified":1,"renderable":0},{"_id":"source/projrct/vue-mint-slider/dist/vue-mint-slider.css","path":"projrct/vue-mint-slider/dist/vue-mint-slider.css","modified":1,"renderable":0},{"_id":"source/projrct/vue-mint-slider/dist/vue-mint-slider.js","path":"projrct/vue-mint-slider/dist/vue-mint-slider.js","modified":1,"renderable":0},{"_id":"source/projrct/vue-mint-slider/dist/example.js","path":"projrct/vue-mint-slider/dist/example.js","modified":1,"renderable":0},{"_id":"source/projrct/vueDemo/static/img/navigation.0afa5d7.png","path":"projrct/vueDemo/static/img/navigation.0afa5d7.png","modified":1,"renderable":0},{"_id":"source/projrct/vueDemo/static/imgs/favicon.ico","path":"projrct/vueDemo/static/imgs/favicon.ico","modified":1,"renderable":0},{"_id":"source/projrct/vueDemo/static/js/1.a83c244ed527bcbc3f30.js","path":"projrct/vueDemo/static/js/1.a83c244ed527bcbc3f30.js","modified":1,"renderable":0},{"_id":"source/projrct/vueDemo/static/js/2.3b889690f69ca6094463.js","path":"projrct/vueDemo/static/js/2.3b889690f69ca6094463.js","modified":1,"renderable":0},{"_id":"source/projrct/vueDemo/static/js/2.3b889690f69ca6094463.js.map","path":"projrct/vueDemo/static/js/2.3b889690f69ca6094463.js.map","modified":1,"renderable":0},{"_id":"source/projrct/vueDemo/static/js/3.c1e4e5029bce3ab36dda.js","path":"projrct/vueDemo/static/js/3.c1e4e5029bce3ab36dda.js","modified":1,"renderable":0},{"_id":"source/projrct/vueDemo/static/js/4.ac13e65c03e0caab6fe7.js","path":"projrct/vueDemo/static/js/4.ac13e65c03e0caab6fe7.js","modified":1,"renderable":0},{"_id":"source/projrct/vueDemo/static/js/5.f536e045fdcc9e776ea0.js","path":"projrct/vueDemo/static/js/5.f536e045fdcc9e776ea0.js","modified":1,"renderable":0},{"_id":"source/projrct/vueDemo/static/js/5.f536e045fdcc9e776ea0.js.map","path":"projrct/vueDemo/static/js/5.f536e045fdcc9e776ea0.js.map","modified":1,"renderable":0},{"_id":"source/projrct/vueDemo/static/js/6.1a1d4802111ebde934a2.js","path":"projrct/vueDemo/static/js/6.1a1d4802111ebde934a2.js","modified":1,"renderable":0},{"_id":"source/projrct/vueDemo/static/js/7.4e3fd715ae38ca7fb00d.js","path":"projrct/vueDemo/static/js/7.4e3fd715ae38ca7fb00d.js","modified":1,"renderable":0},{"_id":"source/projrct/vueDemo/static/js/8.a05ecc3dbd0b6018af6a.js","path":"projrct/vueDemo/static/js/8.a05ecc3dbd0b6018af6a.js","modified":1,"renderable":0},{"_id":"source/projrct/vueDemo/static/js/8.a05ecc3dbd0b6018af6a.js.map","path":"projrct/vueDemo/static/js/8.a05ecc3dbd0b6018af6a.js.map","modified":1,"renderable":0},{"_id":"source/projrct/vueDemo/static/js/app.1e8bb0bb8f65fb2456fc.js","path":"projrct/vueDemo/static/js/app.1e8bb0bb8f65fb2456fc.js","modified":1,"renderable":0},{"_id":"source/projrct/vueDemo/static/js/manifest.9a4ba876ebd7ec0919aa.js","path":"projrct/vueDemo/static/js/manifest.9a4ba876ebd7ec0919aa.js","modified":1,"renderable":0},{"_id":"source/projrct/vueDemo/static/js/manifest.9a4ba876ebd7ec0919aa.js.map","path":"projrct/vueDemo/static/js/manifest.9a4ba876ebd7ec0919aa.js.map","modified":1,"renderable":0},{"_id":"source/projrct/vueDemo/static/img/avatar.ee535e2.jpg","path":"projrct/vueDemo/static/img/avatar.ee535e2.jpg","modified":1,"renderable":0},{"_id":"source/projrct/vueDemo/static/img/content.3e7def2.png","path":"projrct/vueDemo/static/img/content.3e7def2.png","modified":1,"renderable":0},{"_id":"source/projrct/vueDemo/static/js/0.14058a7af21aea574185.js","path":"projrct/vueDemo/static/js/0.14058a7af21aea574185.js","modified":1,"renderable":0},{"_id":"source/projrct/vueDemo/static/js/4.ac13e65c03e0caab6fe7.js.map","path":"projrct/vueDemo/static/js/4.ac13e65c03e0caab6fe7.js.map","modified":1,"renderable":0},{"_id":"source/projrct/vueDemo/static/js/3.c1e4e5029bce3ab36dda.js.map","path":"projrct/vueDemo/static/js/3.c1e4e5029bce3ab36dda.js.map","modified":1,"renderable":0},{"_id":"source/projrct/vueDemo/static/js/7.4e3fd715ae38ca7fb00d.js.map","path":"projrct/vueDemo/static/js/7.4e3fd715ae38ca7fb00d.js.map","modified":1,"renderable":0},{"_id":"source/projrct/vueDemo/static/js/6.1a1d4802111ebde934a2.js.map","path":"projrct/vueDemo/static/js/6.1a1d4802111ebde934a2.js.map","modified":1,"renderable":0},{"_id":"source/projrct/vueDemo/static/js/app.1e8bb0bb8f65fb2456fc.js.map","path":"projrct/vueDemo/static/js/app.1e8bb0bb8f65fb2456fc.js.map","modified":1,"renderable":0},{"_id":"source/projrct/vueDemo/static/js/1.a83c244ed527bcbc3f30.js.map","path":"projrct/vueDemo/static/js/1.a83c244ed527bcbc3f30.js.map","modified":1,"renderable":0},{"_id":"source/projrct/vueDemo/static/js/vendor.8e160083522a0e84bca1.js","path":"projrct/vueDemo/static/js/vendor.8e160083522a0e84bca1.js","modified":1,"renderable":0},{"_id":"source/projrct/vueDemo/static/css/app.ec9b5b49b14eabc7d5c64c1e7c677d92.css","path":"projrct/vueDemo/static/css/app.ec9b5b49b14eabc7d5c64c1e7c677d92.css","modified":1,"renderable":0},{"_id":"source/projrct/vueDemo/static/js/0.14058a7af21aea574185.js.map","path":"projrct/vueDemo/static/js/0.14058a7af21aea574185.js.map","modified":1,"renderable":0},{"_id":"source/projrct/vueDemo/static/css/app.ec9b5b49b14eabc7d5c64c1e7c677d92.css.map","path":"projrct/vueDemo/static/css/app.ec9b5b49b14eabc7d5c64c1e7c677d92.css.map","modified":1,"renderable":0},{"_id":"source/projrct/vueDemo/static/js/vendor.8e160083522a0e84bca1.js.map","path":"projrct/vueDemo/static/js/vendor.8e160083522a0e84bca1.js.map","modified":1,"renderable":0}],"Cache":[{"_id":"themes/cheris/.gitignore","hash":"803c06a7086b5817c03d2e8672da27bc56ba2bce","modified":1553139723316},{"_id":"source/README.md","hash":"e484ff478892e06c010f884335bb68800274d113","modified":1553139723281},{"_id":"themes/cheris/_config.yml","hash":"78cce496d30ef128c71ad70fa9c3ce0ab7af8781","modified":1553139723316},{"_id":"themes/cheris/languages/zh-CN.yml","hash":"cbb421e575c3a50138bd3b26834b547d50627369","modified":1553139723317},{"_id":"themes/cheris/languages/default.yml","hash":"4571e0216ed876cd8240ccbb92c9302688f82f5b","modified":1553139723316},{"_id":"themes/cheris/layout/archive.ejs","hash":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1553139723319},{"_id":"themes/cheris/layout/category.ejs","hash":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1553139723319},{"_id":"themes/cheris/layout/index.ejs","hash":"daebbdce27bc42410a118a5d050ee62e6229989e","modified":1553139723319},{"_id":"themes/cheris/layout/layout.ejs","hash":"bb9586d19ad1a54e723ec9e38ca3f5aeea8c6373","modified":1553139723320},{"_id":"themes/cheris/layout/page.ejs","hash":"70cbc9854655773cc6ba84eecaaf330fed430465","modified":1553139723320},{"_id":"themes/cheris/layout/post.ejs","hash":"70cbc9854655773cc6ba84eecaaf330fed430465","modified":1553139723320},{"_id":"themes/cheris/layout/tag.ejs","hash":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1553139723320},{"_id":"themes/cheris/source/favicon.ico","hash":"17cec2383d6442ab02f456dde75a598240dce259","modified":1553139723324},{"_id":"source/_posts/H5项目常见问题及注意事项.md","hash":"0329b6237dfb732cfc7a085e509d3460988eb5ab","modified":1553139723282},{"_id":"source/_posts/30分钟git命令入门到放弃.md","hash":"0fa00fc6de49a94f22e1dc03ac6d477d21f1457b","modified":1553139723282},{"_id":"source/_posts/HTTP服务器之 - http-server (nodeJs).md","hash":"efc588d0d81021e626c70645064ab914349e297c","modified":1553139723283},{"_id":"source/_posts/Git常用命令.md","hash":"b3c792d4a210fb0826020ed7faed17b469e00cf9","modified":1553139723282},{"_id":"source/_posts/Hexo 多设备管理.md","hash":"81dc992d3ede1123314935f121fbd6fe0e14cda4","modified":1553139723283},{"_id":"source/_posts/JavaScript-ES7-中使用-async-await-解决回调函数嵌套问题.md","hash":"6f6fd5feabf71e3dbf0de42570ad7c5ece172eb1","modified":1553139723283},{"_id":"source/_posts/Sublime Text 3建议配置.md","hash":"252e41ffaa78f7ba8606529347fad945e81e9cd2","modified":1553139723283},{"_id":"source/_posts/发布自己模块到NPM.md","hash":"fe92b3cda2c711f88d34ce265e8036a73900b970","modified":1553139723284},{"_id":"source/_posts/响应式图片.md","hash":"edbcb1f81a1e6245b052fd5882f762d0b27a8405","modified":1553139723284},{"_id":"source/_posts/如何使用Gulp构建项目.md","hash":"f9260a63232b9616d7bbbaa319c40aa1bcd6e658","modified":1553139723284},{"_id":"source/_posts/抛弃jquery，你仍然可以.md","hash":"84440763aba1ea715cec5b05f9bbf82895ac1163","modified":1553139723284},{"_id":"source/_posts/搭建一个Hexo博客.md","hash":"5bcda21e677eaf663dba740be0efd08cf8184cd3","modified":1553139723284},{"_id":"source/about/index.md","hash":"ee0de109970a109f081f613cd6d1a49d0b20db6a","modified":1553139723285},{"_id":"source/_posts/第五届iWeb峰会议程概述.md","hash":"5a7e474447d94651272960dcdf2584cc2c9735f9","modified":1553139723285},{"_id":"source/projrct/.DS_Store","hash":"3a23da5cc00d5efcaff3955ff6c72bbc3bee7d30","modified":1553156403525},{"_id":"source/_posts/前端开发面试题.md","hash":"f886770fc3407aab8fbf0d3a5652c8be12f6b841","modified":1553139723284},{"_id":"themes/cheris/layout/_partial/archive.ejs","hash":"126459fada101d7e7ff87864fb9c1013fc83534f","modified":1553139723317},{"_id":"themes/cheris/layout/_partial/article.ejs","hash":"4d5bfc39aee870813b99b972432c2b704798a484","modified":1553139723317},{"_id":"themes/cheris/layout/_partial/article_default.ejs","hash":"217bfa60b3fc2cdb74aab95d85a78c8a139ae9b6","modified":1553139723317},{"_id":"themes/cheris/layout/_partial/article_index.ejs","hash":"271385ad10d7d69bc8d0b06f0841e30f83224fb4","modified":1553139723317},{"_id":"themes/cheris/layout/_partial/footer.ejs","hash":"e2fae900604d3c44cd23e2d2fc9d593e312ba368","modified":1553139723317},{"_id":"themes/cheris/layout/_partial/googleanalytics.ejs","hash":"1ca2043a53997a4d22b99d7f78b4cc0a73518562","modified":1553139723318},{"_id":"themes/cheris/layout/_partial/head.ejs","hash":"b555339cf4c905d54143f1da020e22bb1edbf3d7","modified":1553139723318},{"_id":"themes/cheris/layout/_partial/comment.ejs","hash":"18e0f0eaeda5cae163789e65b57eb36ea81d672c","modified":1553139723317},{"_id":"themes/cheris/layout/_partial/header.ejs","hash":"8feeac50d2ca752141a52f4d50990c8ddff24f77","modified":1553139723318},{"_id":"themes/cheris/layout/_partial/pagination.ejs","hash":"10a164fd96344c9879a42bf5ca0a44ac0b57c85c","modified":1553139723318},{"_id":"themes/cheris/source/images/avatar.png","hash":"2ca9ecd71c5eace855736bc60890028e994ce74d","modified":1553139723325},{"_id":"themes/cheris/source/images/article.jpg","hash":"b1731429972273ad832fbc1337702de851f82181","modified":1553139723325},{"_id":"themes/cheris/source/images/avatar.jpg","hash":"77c5b57042d1f3af059a0ef589657dba3419dc26","modified":1553139723325},{"_id":"themes/cheris/source/images/icon-bubble.svg","hash":"705b667e317db9b6b572f6f4153d81991a3a69a7","modified":1553139723325},{"_id":"themes/cheris/source/images/icon-categories.svg","hash":"1740f4817c0126e259c12ddf38378026ab0bac29","modified":1553139723325},{"_id":"themes/cheris/source/images/icon-tags.svg","hash":"5f7af686d28f0d1015ae6f16559f9b9658f17dd1","modified":1553139723326},{"_id":"themes/cheris/source/images/icon-heart.svg","hash":"ec483e96c88eea013fd8ac71a34a875107397f43","modified":1553139723326},{"_id":"themes/cheris/source/images/logo.png","hash":"dc53e45da84c0c8e3642e3e6d3d3b1bebbc31766","modified":1553139723326},{"_id":"themes/cheris/source/css/style.styl","hash":"869334beeee1ae5d122b87376bff1516c038f56f","modified":1553139723324},{"_id":"themes/cheris/source/css/style-2.styl","hash":"e85367592c7ee8fd9d784665091fd558c1d32150","modified":1553139723324},{"_id":"source/projrct/treenode/index.html","hash":"f36db463f5c96cadd753f7dc1b93efefe0ec991e","modified":1553139723285},{"_id":"source/projrct/treenode/treenode.js","hash":"1802f8c9fad4bffff09cdf458c0b0e0edc5b51a6","modified":1553139723286},{"_id":"source/projrct/vue-mint-slider/.DS_Store","hash":"289ed7be148d454240e3f36d11d5c515b6f0b081","modified":1553156440051},{"_id":"source/projrct/vueDemo/index.html","hash":"a05aef534c31d292a57987527bb9505ffaeef16d","modified":1553139723286},{"_id":"source/projrct/vue-mint-slider/index.html","hash":"6637150951f8e1f95c526b29b317b0aacbae6e21","modified":1553158333896},{"_id":"source/projrct/treenode/jquery-1.8.2.min.js","hash":"d09d3a99ed25d0f1fbe6856de9e14ffd33557256","modified":1553139723286},{"_id":"themes/cheris/layout/_partial/post/category.ejs","hash":"7df31e3d4ab40ea81f94ffa11f1b4f2a9ebc839d","modified":1553139723318},{"_id":"themes/cheris/layout/_partial/post/gallery.ejs","hash":"de577a884255f35fc14eecf3ff9a14a7d9c786be","modified":1553139723318},{"_id":"themes/cheris/layout/_partial/post/title.ejs","hash":"30bc79a4769933df1c1b770f5f3a2fde4e7f1ffa","modified":1553139723318},{"_id":"themes/cheris/layout/_partial/post/tag.ejs","hash":"0a426f56b90927397036c937bc5491b704e5e12a","modified":1553139723318},{"_id":"themes/cheris/source/css/_base/layout.css","hash":"63ced4a6a819ec70e6e86f5c188704ecceedfef8","modified":1553139723321},{"_id":"themes/cheris/source/css/_base/normalize.css","hash":"e58275a588bb631a37a2988145eea231ed23176b","modified":1553139723321},{"_id":"themes/cheris/source/css/_base/style.css","hash":"a8f4ea6d41dac6a079aed33aad316424575d4674","modified":1553139723321},{"_id":"themes/cheris/source/css/_base/responsive.css","hash":"cf8e14de3ceb1214af47c80b1f5abfd1532e1073","modified":1553139723321},{"_id":"themes/cheris/source/css/_base/syntax.css","hash":"da87e8df35f5ce77cc0fd9ba89f95e8c533b3542","modified":1553139723322},{"_id":"themes/cheris/source/css/_base/syntax.styl","hash":"36900cf4b58d2b01a512a875941ae73c8556d273","modified":1553139723322},{"_id":"themes/cheris/source/css/_base/utils.css","hash":"c4e3f6c77980755302e15066b7bd988c31f61e65","modified":1553139723322},{"_id":"themes/cheris/source/css/_cheris/base.css","hash":"f9ed0a2a9cba283c6aa02fed29b765d0148803ea","modified":1553139723322},{"_id":"themes/cheris/source/css/_cheris/highlight.css","hash":"64f739e5b2c47c7ceb4a4d6b4edf8bdef58b85ed","modified":1553139723322},{"_id":"themes/cheris/source/css/_cheris/style.css","hash":"9752dd40f77c7c08c4a399abdb2bc748237d66b3","modified":1553139723322},{"_id":"themes/cheris/source/css/_partial/archive.css","hash":"73609280dbec6c0f8adbcfffd4fd94b5a6dd351e","modified":1553139723323},{"_id":"themes/cheris/source/css/_partial/article.css","hash":"c5b397d7ee68cb4f3e9287d4023dea0f6e35a661","modified":1553139723323},{"_id":"themes/cheris/source/css/_cheris/style_tmp.css","hash":"16a6e57e9af7d6a48ce38ccbf004db64250eab84","modified":1553139723323},{"_id":"themes/cheris/source/css/_partial/footer.css","hash":"36c1fe0af13d550d41cbb7f754cc4989b917ce18","modified":1553139723323},{"_id":"themes/cheris/source/css/_partial/media.css","hash":"386e605ffe9327dfe70230ff13af450ca7a9208f","modified":1553139723323},{"_id":"themes/cheris/source/css/_partial/pagination.css","hash":"6152eb2c019b497a86cc47946d449d9330a7d255","modified":1553139723324},{"_id":"themes/cheris/source/css/_partial/header.css","hash":"69828b0c639b4d1a3d631f135a925585b51c61dd","modified":1553139723323},{"_id":"themes/cheris/source/css/_partial/icon.css","hash":"5d8f9ef7ff45ceb179537ecb8ebef7103d72558a","modified":1553139723323},{"_id":"source/projrct/vue-mint-slider/dist/example.css","hash":"e85c0d2d38ddcfdda21656bc6c60a0190cf947fc","modified":1553158242766},{"_id":"source/projrct/vue-mint-slider/dist/vue-mint-slider.css","hash":"7ed2fd0f8339d42fe8648e2e8288495d6451b672","modified":1553158276444},{"_id":"source/projrct/vue-mint-slider/dist/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1553158298110},{"_id":"source/projrct/vue-mint-slider/dist/vue-mint-slider.js","hash":"deb300d3d612dd160739b673df9bc308bd857c22","modified":1553158276444},{"_id":"source/projrct/vue-mint-slider/dist/example.js","hash":"0f4f643507fa181fa9e5139e3086ce66c21fd062","modified":1553158242766},{"_id":"source/projrct/vueDemo/static/img/navigation.0afa5d7.png","hash":"ad36305d65087a93e48533e1f3021fec70a4ad54","modified":1553139723294},{"_id":"source/projrct/vueDemo/static/imgs/favicon.ico","hash":"ff96a43c07f49cf007e21e2c00820f5f0f9cb6d7","modified":1553139723294},{"_id":"source/projrct/vueDemo/static/js/1.a83c244ed527bcbc3f30.js","hash":"f4fb5c8705f38f2278fadd66312cddbce5c557cb","modified":1553139723298},{"_id":"source/projrct/vueDemo/static/js/2.3b889690f69ca6094463.js","hash":"b464d9d27758bd202b32d2c8b06af0f476815d32","modified":1553139723300},{"_id":"source/projrct/vueDemo/static/js/2.3b889690f69ca6094463.js.map","hash":"81e4ad1843ca5a8950515921cce6503d71e7707d","modified":1553139723300},{"_id":"source/projrct/vueDemo/static/js/3.c1e4e5029bce3ab36dda.js","hash":"0d41f4db1086a51f940ff254aa99a6fda11d2e9a","modified":1553139723300},{"_id":"source/projrct/vueDemo/static/js/4.ac13e65c03e0caab6fe7.js","hash":"3ce7db62e63248e0087e7a9d8d7a2b41a7c6a85f","modified":1553139723301},{"_id":"source/projrct/vueDemo/static/js/5.f536e045fdcc9e776ea0.js","hash":"1159884174d0e237b6840c1607c0b01d713cc2ad","modified":1553139723302},{"_id":"source/projrct/vueDemo/static/js/5.f536e045fdcc9e776ea0.js.map","hash":"88240b0722a3b0c8524373a27f4604cda2bfd09b","modified":1553139723302},{"_id":"source/projrct/vueDemo/static/js/6.1a1d4802111ebde934a2.js","hash":"88bbf46fc1edc7e203ef1564987959b24ee9f94e","modified":1553139723303},{"_id":"source/projrct/vueDemo/static/js/7.4e3fd715ae38ca7fb00d.js","hash":"6521fb03870ac04e13e8483585525639ac43add6","modified":1553139723304},{"_id":"source/projrct/vueDemo/static/js/8.a05ecc3dbd0b6018af6a.js","hash":"2fb89dfc6ce876ed58e0bd8b62a1474b4194d3c3","modified":1553139723304},{"_id":"source/projrct/vueDemo/static/js/8.a05ecc3dbd0b6018af6a.js.map","hash":"08b652121986e422b10ea56f2d8d72a964740de3","modified":1553139723305},{"_id":"source/projrct/vueDemo/static/js/app.1e8bb0bb8f65fb2456fc.js","hash":"55016060f978d6290e88e11ebd9ceb40d0b788c4","modified":1553139723305},{"_id":"source/projrct/vueDemo/static/js/manifest.9a4ba876ebd7ec0919aa.js","hash":"2d52a78f33b1e33cfc25f5ec603c40bcecc12b2b","modified":1553139723305},{"_id":"source/projrct/vueDemo/static/js/manifest.9a4ba876ebd7ec0919aa.js.map","hash":"9dc43006c2047b87fee30ef0fb520f2e145f30db","modified":1553139723306},{"_id":"source/projrct/vueDemo/static/img/avatar.ee535e2.jpg","hash":"9bbd8b8c8068240196860c1953e5d5d00b562f98","modified":1553139723293},{"_id":"source/projrct/vueDemo/static/img/content.3e7def2.png","hash":"cbe113ce6d36b89f8b68257115420b16a4bced86","modified":1553139723293},{"_id":"source/projrct/vueDemo/static/js/0.14058a7af21aea574185.js","hash":"c819b65f6cf9c78954424fb624baa27fa5e242cf","modified":1553139723295},{"_id":"source/projrct/vueDemo/static/js/4.ac13e65c03e0caab6fe7.js.map","hash":"906499019c044d86646c78018f64f2326ce29781","modified":1553139723302},{"_id":"source/projrct/vueDemo/static/js/3.c1e4e5029bce3ab36dda.js.map","hash":"dc39459997484bd7e0be7b24f95eedf5d9f7ff4a","modified":1553139723301},{"_id":"source/projrct/vueDemo/static/js/7.4e3fd715ae38ca7fb00d.js.map","hash":"092720e028a9a3f24f238885b0f6fc23c773ccc7","modified":1553139723304},{"_id":"source/projrct/vueDemo/static/js/6.1a1d4802111ebde934a2.js.map","hash":"5196a7118651162dcdb0cab4b00a04639d857ff5","modified":1553139723303},{"_id":"source/projrct/vueDemo/static/js/app.1e8bb0bb8f65fb2456fc.js.map","hash":"ed84ff40d7d60d35e639fd08c3620d0d17e2e3ad","modified":1553139723305},{"_id":"source/projrct/vueDemo/static/js/1.a83c244ed527bcbc3f30.js.map","hash":"7c2afb325fd7c6c2090128f7daac350eb2316ef0","modified":1553139723299},{"_id":"source/projrct/vueDemo/static/js/vendor.8e160083522a0e84bca1.js","hash":"8f5f853f9fd7d56c2ae3a8538ab74e76db0da4ad","modified":1553139723307},{"_id":"source/projrct/vueDemo/static/css/app.ec9b5b49b14eabc7d5c64c1e7c677d92.css","hash":"dcdee4f5bb3d938913b0b24420d9bd5bea8ab9d4","modified":1553139723288},{"_id":"source/projrct/vueDemo/static/js/0.14058a7af21aea574185.js.map","hash":"cfad5fbebabb7d3e789ac758b6b3ba6d7cc2b8e7","modified":1553139723297},{"_id":"source/projrct/vueDemo/static/css/app.ec9b5b49b14eabc7d5c64c1e7c677d92.css.map","hash":"7f4e5304779dd679e5480d2b23716dd9653bb423","modified":1553139723291},{"_id":"source/projrct/vueDemo/static/js/vendor.8e160083522a0e84bca1.js.map","hash":"b26a98940efcaaffeba3ed6c18d94138cef874fd","modified":1553139723315},{"_id":"public/feed.xml","hash":"9512a35c7195289c0af1917b537999c5a8ea8177","modified":1553160311596},{"_id":"public/about/index.html","hash":"0fefb455e34c200fc62bca39dd086a3338bf69d1","modified":1553160311748},{"_id":"public/2017/08/10/H5项目常见问题及注意事项/index.html","hash":"6acc5fef85b4581b0c18ec22388c191504a60e43","modified":1553160311748},{"_id":"public/2017/08/10/发布自己模块到NPM/index.html","hash":"3f64c65f21383710f4aeb4a9fff332f866a50f9c","modified":1553160311748},{"_id":"public/2017/04/07/JavaScript-ES7-中使用-async-await-解决回调函数嵌套问题/index.html","hash":"c761916bf6864bfade52e003634b9d1b971029a0","modified":1553160311748},{"_id":"public/2017/03/28/响应式图片/index.html","hash":"db3b7dd1a8632ebc740ed4fa2e642428f762b822","modified":1553160311749},{"_id":"public/2016/08/04/HTTP服务器之 - http-server (nodeJs)/index.html","hash":"10259cb1ab8bf7aec00517b2ef79d6d56e757dce","modified":1553160311749},{"_id":"public/2016/08/04/Sublime Text 3建议配置/index.html","hash":"ee0a4cdb87f0a9e7b2e1b40d96b51fe5f033e867","modified":1553160311749},{"_id":"public/2016/07/14/如何使用Gulp构建项目/index.html","hash":"0bdc0d069f56f86e3040624341246c34d093ac49","modified":1553160311749},{"_id":"public/2016/07/13/Hexo 多设备管理/index.html","hash":"3f62aa8dff4813c3a28847d0c4201ecd7ad09fca","modified":1553160311749},{"_id":"public/categories/nodeJs/index.html","hash":"d6bbdcf3043b1e6da62bdea9750cd433d8889406","modified":1553160311749},{"_id":"public/categories/前端/index.html","hash":"8a5af65b7f4c7dfe6ba3b841ba022955bad0a49b","modified":1553160311749},{"_id":"public/categories/编辑器/index.html","hash":"b4f3d2987f9299a0b520d8ee802a186d4005c2c5","modified":1553160311749},{"_id":"public/tags/HTTP服务器/index.html","hash":"839152c8b0298197dce81775d01665c41b5d03cf","modified":1553160311749},{"_id":"public/tags/Git/index.html","hash":"c05718ec8731dae4c054b3eacc9aef9177b39754","modified":1553160311749},{"_id":"public/tags/Hexo/index.html","hash":"5b3519b12965452c81cd90a9e830cf8bdf39f0cf","modified":1553160311749},{"_id":"public/tags/Sublime/index.html","hash":"cf1664f2b0f9bc5c4a276d8ee7cfc25268c53486","modified":1553160311749},{"_id":"public/tags/Gulp/index.html","hash":"010b45ed0634dd30ab1bf0a7e786def02777a5fd","modified":1553160311749},{"_id":"public/tags/JavaScript/index.html","hash":"312bf960450e3e98901b992ab82c12412392511f","modified":1553160311750},{"_id":"public/tags/面试/index.html","hash":"e118e45e46e12019032fd42ce05a9d1698f39adb","modified":1553160311750},{"_id":"public/archives/index.html","hash":"bcab8846a0b9fd0bfb82527fbb14397968d51a05","modified":1553160311750},{"_id":"public/archives/2016/index.html","hash":"aab4f577b0ad965faf17a805fac6aa0e537cfa60","modified":1553160311750},{"_id":"public/archives/2016/07/index.html","hash":"d3d9e33d40241337b5fe451edbc3a5b6bf9a573d","modified":1553160311750},{"_id":"public/archives/2016/08/index.html","hash":"c04827c37c81f527fe746278aeeb843965477512","modified":1553160311750},{"_id":"public/archives/2016/10/index.html","hash":"031c8a0a8aa61e9b2d0a16b70442038e30be6b9f","modified":1553160311750},{"_id":"public/archives/2017/index.html","hash":"99be606597d4c01fb459b5d1414322f76b8b4835","modified":1553160311750},{"_id":"public/archives/2017/03/index.html","hash":"5079f479fe63d0d447a402c38903fa8e3b25c725","modified":1553160311750},{"_id":"public/archives/2017/04/index.html","hash":"521f245501b1a69c28c369ada90bf3d49f087f55","modified":1553160311750},{"_id":"public/archives/2017/08/index.html","hash":"ab190ad0e18871578d55ef9ee33e68527958a32c","modified":1553160311750},{"_id":"public/index.html","hash":"e56e294b906cc21fdc634db626814f092d2c7240","modified":1553160311750},{"_id":"public/page/2/index.html","hash":"2cf3fff70c2bf3b6067d81f4574138c83805b7f5","modified":1553160311750},{"_id":"public/2016/10/20/抛弃jquery，你仍然可以/index.html","hash":"928f3d4ff4584f8ff51a93ea820e640c88d02ed3","modified":1553160311750},{"_id":"public/2016/08/30/前端开发面试题/index.html","hash":"a1c50540c43202807f3b24655107a686cf2cfa71","modified":1553160311750},{"_id":"public/2016/08/28/第五届iWeb峰会议程概述/index.html","hash":"c47b3116e5b11126b7b658d0f83c41fa36361f08","modified":1553160311750},{"_id":"public/2016/07/14/Git常用命令/index.html","hash":"002a6d31c8153cf123cdd0bfaf2246e73cc1667c","modified":1553160311750},{"_id":"public/2016/07/13/搭建一个Hexo博客/index.html","hash":"fadc1cd82b373ac1254ba7add95a6e463a48cf3e","modified":1553160311750},{"_id":"public/2016/07/11/30分钟git命令入门到放弃/index.html","hash":"da9d594b0e38e0e0e76edac3de71b31ebfbe99d8","modified":1553160311750},{"_id":"public/README.md","hash":"e484ff478892e06c010f884335bb68800274d113","modified":1553160311757},{"_id":"public/favicon.ico","hash":"17cec2383d6442ab02f456dde75a598240dce259","modified":1553160311757},{"_id":"public/images/avatar.png","hash":"2ca9ecd71c5eace855736bc60890028e994ce74d","modified":1553160311757},{"_id":"public/images/avatar.jpg","hash":"77c5b57042d1f3af059a0ef589657dba3419dc26","modified":1553160311757},{"_id":"public/images/article.jpg","hash":"b1731429972273ad832fbc1337702de851f82181","modified":1553160311757},{"_id":"public/images/icon-bubble.svg","hash":"705b667e317db9b6b572f6f4153d81991a3a69a7","modified":1553160311757},{"_id":"public/images/icon-categories.svg","hash":"1740f4817c0126e259c12ddf38378026ab0bac29","modified":1553160311757},{"_id":"public/images/icon-tags.svg","hash":"5f7af686d28f0d1015ae6f16559f9b9658f17dd1","modified":1553160311757},{"_id":"public/images/icon-heart.svg","hash":"ec483e96c88eea013fd8ac71a34a875107397f43","modified":1553160311758},{"_id":"public/images/logo.png","hash":"dc53e45da84c0c8e3642e3e6d3d3b1bebbc31766","modified":1553160311758},{"_id":"public/projrct/treenode/index.html","hash":"f36db463f5c96cadd753f7dc1b93efefe0ec991e","modified":1553160311758},{"_id":"public/projrct/treenode/treenode.js","hash":"1802f8c9fad4bffff09cdf458c0b0e0edc5b51a6","modified":1553160311758},{"_id":"public/projrct/vueDemo/index.html","hash":"a05aef534c31d292a57987527bb9505ffaeef16d","modified":1553160311758},{"_id":"public/projrct/vue-mint-slider/index.html","hash":"6637150951f8e1f95c526b29b317b0aacbae6e21","modified":1553160311758},{"_id":"public/projrct/vue-mint-slider/dist/example.css","hash":"e85c0d2d38ddcfdda21656bc6c60a0190cf947fc","modified":1553160311758},{"_id":"public/projrct/vue-mint-slider/dist/vue-mint-slider.css","hash":"7ed2fd0f8339d42fe8648e2e8288495d6451b672","modified":1553160311758},{"_id":"public/projrct/vue-mint-slider/dist/vue-mint-slider.js","hash":"deb300d3d612dd160739b673df9bc308bd857c22","modified":1553160311758},{"_id":"public/projrct/vueDemo/static/imgs/favicon.ico","hash":"ff96a43c07f49cf007e21e2c00820f5f0f9cb6d7","modified":1553160311758},{"_id":"public/projrct/vueDemo/static/img/navigation.0afa5d7.png","hash":"ad36305d65087a93e48533e1f3021fec70a4ad54","modified":1553160311758},{"_id":"public/projrct/vueDemo/static/js/2.3b889690f69ca6094463.js","hash":"b464d9d27758bd202b32d2c8b06af0f476815d32","modified":1553160311758},{"_id":"public/projrct/vueDemo/static/js/1.a83c244ed527bcbc3f30.js","hash":"f4fb5c8705f38f2278fadd66312cddbce5c557cb","modified":1553160311758},{"_id":"public/projrct/vueDemo/static/js/3.c1e4e5029bce3ab36dda.js","hash":"0d41f4db1086a51f940ff254aa99a6fda11d2e9a","modified":1553160311758},{"_id":"public/projrct/vueDemo/static/js/2.3b889690f69ca6094463.js.map","hash":"81e4ad1843ca5a8950515921cce6503d71e7707d","modified":1553160311758},{"_id":"public/projrct/vueDemo/static/js/4.ac13e65c03e0caab6fe7.js","hash":"3ce7db62e63248e0087e7a9d8d7a2b41a7c6a85f","modified":1553160311758},{"_id":"public/projrct/vueDemo/static/js/5.f536e045fdcc9e776ea0.js","hash":"1159884174d0e237b6840c1607c0b01d713cc2ad","modified":1553160311758},{"_id":"public/projrct/vueDemo/static/js/5.f536e045fdcc9e776ea0.js.map","hash":"88240b0722a3b0c8524373a27f4604cda2bfd09b","modified":1553160311759},{"_id":"public/projrct/vueDemo/static/js/6.1a1d4802111ebde934a2.js","hash":"88bbf46fc1edc7e203ef1564987959b24ee9f94e","modified":1553160311759},{"_id":"public/projrct/vueDemo/static/js/8.a05ecc3dbd0b6018af6a.js","hash":"2fb89dfc6ce876ed58e0bd8b62a1474b4194d3c3","modified":1553160311759},{"_id":"public/projrct/vueDemo/static/js/7.4e3fd715ae38ca7fb00d.js","hash":"6521fb03870ac04e13e8483585525639ac43add6","modified":1553160311759},{"_id":"public/projrct/vueDemo/static/js/8.a05ecc3dbd0b6018af6a.js.map","hash":"08b652121986e422b10ea56f2d8d72a964740de3","modified":1553160311759},{"_id":"public/projrct/vueDemo/static/js/manifest.9a4ba876ebd7ec0919aa.js","hash":"2d52a78f33b1e33cfc25f5ec603c40bcecc12b2b","modified":1553160311759},{"_id":"public/projrct/vueDemo/static/js/app.1e8bb0bb8f65fb2456fc.js","hash":"55016060f978d6290e88e11ebd9ceb40d0b788c4","modified":1553160311759},{"_id":"public/projrct/vueDemo/static/js/manifest.9a4ba876ebd7ec0919aa.js.map","hash":"9dc43006c2047b87fee30ef0fb520f2e145f30db","modified":1553160311759},{"_id":"public/projrct/vueDemo/static/js/4.ac13e65c03e0caab6fe7.js.map","hash":"906499019c044d86646c78018f64f2326ce29781","modified":1553160311759},{"_id":"public/projrct/vueDemo/static/js/7.4e3fd715ae38ca7fb00d.js.map","hash":"092720e028a9a3f24f238885b0f6fc23c773ccc7","modified":1553160311759},{"_id":"public/projrct/vueDemo/static/js/6.1a1d4802111ebde934a2.js.map","hash":"5196a7118651162dcdb0cab4b00a04639d857ff5","modified":1553160311759},{"_id":"public/projrct/treenode/jquery-1.8.2.min.js","hash":"d09d3a99ed25d0f1fbe6856de9e14ffd33557256","modified":1553160311951},{"_id":"public/projrct/vue-mint-slider/dist/example.js","hash":"0f4f643507fa181fa9e5139e3086ce66c21fd062","modified":1553160311951},{"_id":"public/projrct/vueDemo/static/img/avatar.ee535e2.jpg","hash":"9bbd8b8c8068240196860c1953e5d5d00b562f98","modified":1553160311951},{"_id":"public/projrct/vueDemo/static/js/0.14058a7af21aea574185.js","hash":"c819b65f6cf9c78954424fb624baa27fa5e242cf","modified":1553160311951},{"_id":"public/projrct/vueDemo/static/img/content.3e7def2.png","hash":"cbe113ce6d36b89f8b68257115420b16a4bced86","modified":1553160311951},{"_id":"public/projrct/vueDemo/static/js/3.c1e4e5029bce3ab36dda.js.map","hash":"dc39459997484bd7e0be7b24f95eedf5d9f7ff4a","modified":1553160311952},{"_id":"public/projrct/vueDemo/static/js/app.1e8bb0bb8f65fb2456fc.js.map","hash":"ed84ff40d7d60d35e639fd08c3620d0d17e2e3ad","modified":1553160311952},{"_id":"public/css/style.css","hash":"07bead9d1457f967c875b3e9b8f423bbca6bb8f9","modified":1553160311956},{"_id":"public/css/style-2.css","hash":"fea4931e5182c66cbe1652aa59c0a44aa51abcc2","modified":1553160311956},{"_id":"public/projrct/vueDemo/static/js/vendor.8e160083522a0e84bca1.js","hash":"8f5f853f9fd7d56c2ae3a8538ab74e76db0da4ad","modified":1553160311956},{"_id":"public/projrct/vueDemo/static/js/1.a83c244ed527bcbc3f30.js.map","hash":"7c2afb325fd7c6c2090128f7daac350eb2316ef0","modified":1553160311961},{"_id":"public/projrct/vueDemo/static/css/app.ec9b5b49b14eabc7d5c64c1e7c677d92.css","hash":"dcdee4f5bb3d938913b0b24420d9bd5bea8ab9d4","modified":1553160311964},{"_id":"public/projrct/vueDemo/static/js/0.14058a7af21aea574185.js.map","hash":"cfad5fbebabb7d3e789ac758b6b3ba6d7cc2b8e7","modified":1553160311964},{"_id":"public/projrct/vueDemo/static/css/app.ec9b5b49b14eabc7d5c64c1e7c677d92.css.map","hash":"7f4e5304779dd679e5480d2b23716dd9653bb423","modified":1553160311974},{"_id":"public/projrct/vueDemo/static/js/vendor.8e160083522a0e84bca1.js.map","hash":"b26a98940efcaaffeba3ed6c18d94138cef874fd","modified":1553160311982}],"Category":[{"name":"nodeJs","_id":"cjtifjpst0004lohi5chd10lk"},{"name":"前端","_id":"cjtifjpt00009lohicsno5h9e"},{"name":"编辑器","_id":"cjtifjptb000klohid0geyguj"}],"Data":[],"Page":[{"title":"about","date":"2016-08-29T03:04:49.000Z","_content":"### 微博：(cherislive)[http://weibo.com/cherislive]\n### 微信：(cherislive)\n### 网站：(cheris.cn)[http://www.cheris.cn]\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2016-08-29 11:04:49\n---\n### 微博：(cherislive)[http://weibo.com/cherislive]\n### 微信：(cherislive)\n### 网站：(cheris.cn)[http://www.cheris.cn]\n","updated":"2019-03-21T03:42:03.285Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjtifjpso0001lohia1inltst","content":"<h3 id=\"微博：-cherislive-http-weibo-com-cherislive\"><a href=\"#微博：-cherislive-http-weibo-com-cherislive\" class=\"headerlink\" title=\"微博：(cherislive)[http://weibo.com/cherislive]\"></a>微博：(cherislive)[<a href=\"http://weibo.com/cherislive]\" target=\"_blank\" rel=\"noopener\">http://weibo.com/cherislive]</a></h3><h3 id=\"微信：-cherislive\"><a href=\"#微信：-cherislive\" class=\"headerlink\" title=\"微信：(cherislive)\"></a>微信：(cherislive)</h3><h3 id=\"网站：-cheris-cn-http-www-cheris-cn\"><a href=\"#网站：-cheris-cn-http-www-cheris-cn\" class=\"headerlink\" title=\"网站：(cheris.cn)[http://www.cheris.cn]\"></a>网站：(cheris.cn)[<a href=\"http://www.cheris.cn]\" target=\"_blank\" rel=\"noopener\">http://www.cheris.cn]</a></h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"微博：-cherislive-http-weibo-com-cherislive\"><a href=\"#微博：-cherislive-http-weibo-com-cherislive\" class=\"headerlink\" title=\"微博：(cherislive)[http://weibo.com/cherislive]\"></a>微博：(cherislive)[<a href=\"http://weibo.com/cherislive]\" target=\"_blank\" rel=\"noopener\">http://weibo.com/cherislive]</a></h3><h3 id=\"微信：-cherislive\"><a href=\"#微信：-cherislive\" class=\"headerlink\" title=\"微信：(cherislive)\"></a>微信：(cherislive)</h3><h3 id=\"网站：-cheris-cn-http-www-cheris-cn\"><a href=\"#网站：-cheris-cn-http-www-cheris-cn\" class=\"headerlink\" title=\"网站：(cheris.cn)[http://www.cheris.cn]\"></a>网站：(cheris.cn)[<a href=\"http://www.cheris.cn]\" target=\"_blank\" rel=\"noopener\">http://www.cheris.cn]</a></h3>"}],"Post":[{"title":"H5项目常见问题及注意事项","date":"2017-08-10T06:48:13.000Z","_content":"当我们谈论前端性能 我们在谈论什么？加载性能、渲染性能、用户交互相应速度、动画流畅、DOM操作无闪烁。。。\n\n<!--more-->\n\n#### Meta 基础知识：\n* viewport\n \n 1、JS动态判断\n```\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, minimal-ui\">\n```\n>  width：设置viewport宽度，为一个正整数，或字符串‘device-width’；\n>  height：设置viewport高度，一般不设置，自适应；\n>  initial-scale：默认缩放比例，为一个数字，可以带小数；\n>  minimum-scale：允许用户最小缩放比例，为一个数字，可以带小数；\n>  maximum-scale：允许用户最大缩放比例，为一个数字，可以带小数；\n>  user-scalable：是否允许手动缩放。\n\n\n2、JS动态计算\n```\nvar winWidth=  parseInt(window.screen.width);\nvar phoneScale = winWidth/640;\nvar ua = navigator.userAgent;\nif (/Android (\\d+\\.\\d+)/.test(ua)){\n  var version = parseFloat(RegExp.$1);\n  if(version>2.3){\n    document.write('<meta name=\"viewport\" content=\"width=640, minimum-scale = '+phoneScale+', maximum-scale = '+phoneScale+', target-densitydpi=device-dpi\">');\n  }else{\n    document.write('<meta name=\"viewport\" content=\"width=640, target-densitydpi=device-dpi\">');\n  }\n} else {\n  document.write('<meta name=\"viewport\" content=\"width=640, user-scalable=no, target-densitydpi=device-dpi\">');\n}\n```\n* 其他**meta**标签\n```\n<!-- 横竖屏设置 -->\n<meta name=\"screen-orientation\" content=\"portrait\"/>\n\n<!-- 可隐藏地址栏，仅针对IOS的Safari（注：IOS7.0版本以后，safari上已看不到效果），和minimal-ui效果类似 -->\n<meta name=\"apple-mobile-web-app-capable\" content=\"yes\">\n\n<!-- 仅针对IOS的Safari顶端状态条的样式（可选default/black/black-translucent ） -->\n<meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\">\n\n<!-- 格式检测 数字识别为电话号码/对邮箱地址的识别/跳转至地图 -->\n<meta name=\"format-detection\" content=\"telephone=no, email=no, adress=no\">\n\n<!-- UC强制全屏 -->\n<meta name=\"full-screen\" content=\"yes\">\n\n<!-- QQ强制全屏 -->\n<meta name=\"x5-fullscreen\" content=\"true\">\n```\n> 更多 [ < meta > 知识获取](https://segmentfault.com/a/1190000002407912)。\n\n### 微信单页面修改title\n*问题：当页面载入时，微信顶部 title 获取并显示，之后怎么用JS修改 title ，无效。*\n*这个是针对IOS出现的 hack ，Android是有效的。 貌似是IOS的webview没有监听titlechange事件。 目前的处理就是使用重新载入页面的形式来唤醒页面的title有关事件。*\n```\n// 解决iOS设备修改title不起作用的bug\nfunction set_title (title) {\n  document.title = title;\n  if (!ua.is_idevice) return;\n  // 随便访问iframe访问一个网页，title就可以刷新了\n  var $iframe = $(\"<iframe style='display:none;' src='/favicon.ico'></iframe>\");\n  $iframe.on('load',function() {\n    setTimeout(function() {\n      $iframe.off('load').remove();\n    }, 0);\n  }).appendTo($body);\n}\n```\n\n###  点击事件 **Click**\nclick事件，移动端click事件有300ms的延迟（有很多PC页面没有做移动端分辨率兼容==》需要放大缩小来浏览==》移动端常用的放大缩小方案：双击==》区分单双击==》设置300ms延迟）\n移动端解决方案：\n引入zepto,用tap事件代替click;\ntap不是原生事件，touchstart/touchmove/touchend\n基本条件：从触摸到离开时间间隔短，从起点到终点距离间隔小\n\n点击态：\n方案1：用  :active 伪类  缺点：滚动的时候也会触发样式\n方案2：\n\n```\n// 点击事件带点击态\n$el.on('tap',function(e){\n    var $target = $(e.target);\n    var timer=null;\n    $target.addClass('active');\n    timer = setTimeout(function(){\n        $target.removeClass('active');\n        clearTimeout(timer);\n    });\n});\n```\n\n### 滚动\n全局滚动：滚动节点在body 节点或者更顶层\n局部滚动:  滚动条在body 下的某一个dom 节点上\n\n| Col1      |     iOS |   Android |\n| :-------- | :------- | :------ |\n| 全局滚动 | 默认支持 | 定制版本较多，表现各异|\n| 局部滚动 | 默认没有滚动条，且滑动起来干涩 | - |  \n| 弹性滚动 | 支持 | 默认没有弹性滚动效果|\n| -webkit-overflow-scrolling | 支持 | 默认浏览器不支持 Android版chrome支持 |\n| 触发出界 | **全局滚动：**滚动到页面顶部（或底部）时继续向下（向上）滑动，就会出现;<br> **局部滚动：**滚动到页面顶部（或底部）时，手指离开停下，再继续向下（向上）滑动，就会出现 | - |\n* iOS局部滚动使用弹性滚动效果\n```\n// 建议：将属性挂在body上，可以避免很多奇怪的bug\nbody{--webkit-overflow-scrolling: touch;}\n\n/*局部dom节点*/\n.scroll-el{overflow:auto;}\n```\n* **流畅滚动的军规：**\n> body上加上 -webkit-overfllow-scrolling:touch\n> iOS 尽量使用局部滚动\n> iOS 引进ScrollFix 避免出界\n> Android下尽量使用全局滚动\n\n","source":"_posts/H5项目常见问题及注意事项.md","raw":"---\ntitle: H5项目常见问题及注意事项\ndate: 2017-08-10 14:48:13\ntags:\n---\n当我们谈论前端性能 我们在谈论什么？加载性能、渲染性能、用户交互相应速度、动画流畅、DOM操作无闪烁。。。\n\n<!--more-->\n\n#### Meta 基础知识：\n* viewport\n \n 1、JS动态判断\n```\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, minimal-ui\">\n```\n>  width：设置viewport宽度，为一个正整数，或字符串‘device-width’；\n>  height：设置viewport高度，一般不设置，自适应；\n>  initial-scale：默认缩放比例，为一个数字，可以带小数；\n>  minimum-scale：允许用户最小缩放比例，为一个数字，可以带小数；\n>  maximum-scale：允许用户最大缩放比例，为一个数字，可以带小数；\n>  user-scalable：是否允许手动缩放。\n\n\n2、JS动态计算\n```\nvar winWidth=  parseInt(window.screen.width);\nvar phoneScale = winWidth/640;\nvar ua = navigator.userAgent;\nif (/Android (\\d+\\.\\d+)/.test(ua)){\n  var version = parseFloat(RegExp.$1);\n  if(version>2.3){\n    document.write('<meta name=\"viewport\" content=\"width=640, minimum-scale = '+phoneScale+', maximum-scale = '+phoneScale+', target-densitydpi=device-dpi\">');\n  }else{\n    document.write('<meta name=\"viewport\" content=\"width=640, target-densitydpi=device-dpi\">');\n  }\n} else {\n  document.write('<meta name=\"viewport\" content=\"width=640, user-scalable=no, target-densitydpi=device-dpi\">');\n}\n```\n* 其他**meta**标签\n```\n<!-- 横竖屏设置 -->\n<meta name=\"screen-orientation\" content=\"portrait\"/>\n\n<!-- 可隐藏地址栏，仅针对IOS的Safari（注：IOS7.0版本以后，safari上已看不到效果），和minimal-ui效果类似 -->\n<meta name=\"apple-mobile-web-app-capable\" content=\"yes\">\n\n<!-- 仅针对IOS的Safari顶端状态条的样式（可选default/black/black-translucent ） -->\n<meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\">\n\n<!-- 格式检测 数字识别为电话号码/对邮箱地址的识别/跳转至地图 -->\n<meta name=\"format-detection\" content=\"telephone=no, email=no, adress=no\">\n\n<!-- UC强制全屏 -->\n<meta name=\"full-screen\" content=\"yes\">\n\n<!-- QQ强制全屏 -->\n<meta name=\"x5-fullscreen\" content=\"true\">\n```\n> 更多 [ < meta > 知识获取](https://segmentfault.com/a/1190000002407912)。\n\n### 微信单页面修改title\n*问题：当页面载入时，微信顶部 title 获取并显示，之后怎么用JS修改 title ，无效。*\n*这个是针对IOS出现的 hack ，Android是有效的。 貌似是IOS的webview没有监听titlechange事件。 目前的处理就是使用重新载入页面的形式来唤醒页面的title有关事件。*\n```\n// 解决iOS设备修改title不起作用的bug\nfunction set_title (title) {\n  document.title = title;\n  if (!ua.is_idevice) return;\n  // 随便访问iframe访问一个网页，title就可以刷新了\n  var $iframe = $(\"<iframe style='display:none;' src='/favicon.ico'></iframe>\");\n  $iframe.on('load',function() {\n    setTimeout(function() {\n      $iframe.off('load').remove();\n    }, 0);\n  }).appendTo($body);\n}\n```\n\n###  点击事件 **Click**\nclick事件，移动端click事件有300ms的延迟（有很多PC页面没有做移动端分辨率兼容==》需要放大缩小来浏览==》移动端常用的放大缩小方案：双击==》区分单双击==》设置300ms延迟）\n移动端解决方案：\n引入zepto,用tap事件代替click;\ntap不是原生事件，touchstart/touchmove/touchend\n基本条件：从触摸到离开时间间隔短，从起点到终点距离间隔小\n\n点击态：\n方案1：用  :active 伪类  缺点：滚动的时候也会触发样式\n方案2：\n\n```\n// 点击事件带点击态\n$el.on('tap',function(e){\n    var $target = $(e.target);\n    var timer=null;\n    $target.addClass('active');\n    timer = setTimeout(function(){\n        $target.removeClass('active');\n        clearTimeout(timer);\n    });\n});\n```\n\n### 滚动\n全局滚动：滚动节点在body 节点或者更顶层\n局部滚动:  滚动条在body 下的某一个dom 节点上\n\n| Col1      |     iOS |   Android |\n| :-------- | :------- | :------ |\n| 全局滚动 | 默认支持 | 定制版本较多，表现各异|\n| 局部滚动 | 默认没有滚动条，且滑动起来干涩 | - |  \n| 弹性滚动 | 支持 | 默认没有弹性滚动效果|\n| -webkit-overflow-scrolling | 支持 | 默认浏览器不支持 Android版chrome支持 |\n| 触发出界 | **全局滚动：**滚动到页面顶部（或底部）时继续向下（向上）滑动，就会出现;<br> **局部滚动：**滚动到页面顶部（或底部）时，手指离开停下，再继续向下（向上）滑动，就会出现 | - |\n* iOS局部滚动使用弹性滚动效果\n```\n// 建议：将属性挂在body上，可以避免很多奇怪的bug\nbody{--webkit-overflow-scrolling: touch;}\n\n/*局部dom节点*/\n.scroll-el{overflow:auto;}\n```\n* **流畅滚动的军规：**\n> body上加上 -webkit-overfllow-scrolling:touch\n> iOS 尽量使用局部滚动\n> iOS 引进ScrollFix 避免出界\n> Android下尽量使用全局滚动\n\n","slug":"H5项目常见问题及注意事项","published":1,"updated":"2019-03-21T03:42:03.282Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtifjpsj0000lohi4bxhzorz","content":"<p>当我们谈论前端性能 我们在谈论什么？加载性能、渲染性能、用户交互相应速度、动画流畅、DOM操作无闪烁。。。</p>\n<a id=\"more\"></a>\n<h4 id=\"Meta-基础知识：\"><a href=\"#Meta-基础知识：\" class=\"headerlink\" title=\"Meta 基础知识：\"></a>Meta 基础知识：</h4><ul>\n<li><p>viewport</p>\n<p>1、JS动态判断</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, minimal-ui&quot;&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p> width：设置viewport宽度，为一个正整数，或字符串‘device-width’；<br> height：设置viewport高度，一般不设置，自适应；<br> initial-scale：默认缩放比例，为一个数字，可以带小数；<br> minimum-scale：允许用户最小缩放比例，为一个数字，可以带小数；<br> maximum-scale：允许用户最大缩放比例，为一个数字，可以带小数；<br> user-scalable：是否允许手动缩放。</p>\n</blockquote>\n<p>2、JS动态计算<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var winWidth=  parseInt(window.screen.width);</span><br><span class=\"line\">var phoneScale = winWidth/640;</span><br><span class=\"line\">var ua = navigator.userAgent;</span><br><span class=\"line\">if (/Android (\\d+\\.\\d+)/.test(ua))&#123;</span><br><span class=\"line\">  var version = parseFloat(RegExp.$1);</span><br><span class=\"line\">  if(version&gt;2.3)&#123;</span><br><span class=\"line\">    document.write(&apos;&lt;meta name=&quot;viewport&quot; content=&quot;width=640, minimum-scale = &apos;+phoneScale+&apos;, maximum-scale = &apos;+phoneScale+&apos;, target-densitydpi=device-dpi&quot;&gt;&apos;);</span><br><span class=\"line\">  &#125;else&#123;</span><br><span class=\"line\">    document.write(&apos;&lt;meta name=&quot;viewport&quot; content=&quot;width=640, target-densitydpi=device-dpi&quot;&gt;&apos;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">  document.write(&apos;&lt;meta name=&quot;viewport&quot; content=&quot;width=640, user-scalable=no, target-densitydpi=device-dpi&quot;&gt;&apos;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>其他<strong>meta</strong>标签<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 横竖屏设置 --&gt;</span><br><span class=\"line\">&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 可隐藏地址栏，仅针对IOS的Safari（注：IOS7.0版本以后，safari上已看不到效果），和minimal-ui效果类似 --&gt;</span><br><span class=\"line\">&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 仅针对IOS的Safari顶端状态条的样式（可选default/black/black-translucent ） --&gt;</span><br><span class=\"line\">&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 格式检测 数字识别为电话号码/对邮箱地址的识别/跳转至地图 --&gt;</span><br><span class=\"line\">&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no, email=no, adress=no&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- UC强制全屏 --&gt;</span><br><span class=\"line\">&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- QQ强制全屏 --&gt;</span><br><span class=\"line\">&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>更多 <a href=\"https://segmentfault.com/a/1190000002407912\" target=\"_blank\" rel=\"noopener\"> &lt; meta &gt; 知识获取</a>。</p>\n</blockquote>\n<h3 id=\"微信单页面修改title\"><a href=\"#微信单页面修改title\" class=\"headerlink\" title=\"微信单页面修改title\"></a>微信单页面修改title</h3><p><em>问题：当页面载入时，微信顶部 title 获取并显示，之后怎么用JS修改 title ，无效。</em><br><em>这个是针对IOS出现的 hack ，Android是有效的。 貌似是IOS的webview没有监听titlechange事件。 目前的处理就是使用重新载入页面的形式来唤醒页面的title有关事件。</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 解决iOS设备修改title不起作用的bug</span><br><span class=\"line\">function set_title (title) &#123;</span><br><span class=\"line\">  document.title = title;</span><br><span class=\"line\">  if (!ua.is_idevice) return;</span><br><span class=\"line\">  // 随便访问iframe访问一个网页，title就可以刷新了</span><br><span class=\"line\">  var $iframe = $(&quot;&lt;iframe style=&apos;display:none;&apos; src=&apos;/favicon.ico&apos;&gt;&lt;/iframe&gt;&quot;);</span><br><span class=\"line\">  $iframe.on(&apos;load&apos;,function() &#123;</span><br><span class=\"line\">    setTimeout(function() &#123;</span><br><span class=\"line\">      $iframe.off(&apos;load&apos;).remove();</span><br><span class=\"line\">    &#125;, 0);</span><br><span class=\"line\">  &#125;).appendTo($body);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"点击事件-Click\"><a href=\"#点击事件-Click\" class=\"headerlink\" title=\"点击事件 Click\"></a>点击事件 <strong>Click</strong></h3><p>click事件，移动端click事件有300ms的延迟（有很多PC页面没有做移动端分辨率兼容==》需要放大缩小来浏览==》移动端常用的放大缩小方案：双击==》区分单双击==》设置300ms延迟）<br>移动端解决方案：<br>引入zepto,用tap事件代替click;<br>tap不是原生事件，touchstart/touchmove/touchend<br>基本条件：从触摸到离开时间间隔短，从起点到终点距离间隔小</p>\n<p>点击态：<br>方案1：用  :active 伪类  缺点：滚动的时候也会触发样式<br>方案2：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 点击事件带点击态</span><br><span class=\"line\">$el.on(&apos;tap&apos;,function(e)&#123;</span><br><span class=\"line\">    var $target = $(e.target);</span><br><span class=\"line\">    var timer=null;</span><br><span class=\"line\">    $target.addClass(&apos;active&apos;);</span><br><span class=\"line\">    timer = setTimeout(function()&#123;</span><br><span class=\"line\">        $target.removeClass(&apos;active&apos;);</span><br><span class=\"line\">        clearTimeout(timer);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"滚动\"><a href=\"#滚动\" class=\"headerlink\" title=\"滚动\"></a>滚动</h3><p>全局滚动：滚动节点在body 节点或者更顶层<br>局部滚动:  滚动条在body 下的某一个dom 节点上</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Col1</th>\n<th style=\"text-align:left\">iOS</th>\n<th style=\"text-align:left\">Android</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">全局滚动</td>\n<td style=\"text-align:left\">默认支持</td>\n<td style=\"text-align:left\">定制版本较多，表现各异</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">局部滚动</td>\n<td style=\"text-align:left\">默认没有滚动条，且滑动起来干涩</td>\n<td style=\"text-align:left\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">弹性滚动</td>\n<td style=\"text-align:left\">支持</td>\n<td style=\"text-align:left\">默认没有弹性滚动效果</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">-webkit-overflow-scrolling</td>\n<td style=\"text-align:left\">支持</td>\n<td style=\"text-align:left\">默认浏览器不支持 Android版chrome支持</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">触发出界</td>\n<td style=\"text-align:left\"><strong>全局滚动：</strong>滚动到页面顶部（或底部）时继续向下（向上）滑动，就会出现;<br> <strong>局部滚动：</strong>滚动到页面顶部（或底部）时，手指离开停下，再继续向下（向上）滑动，就会出现</td>\n<td style=\"text-align:left\">-</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p>iOS局部滚动使用弹性滚动效果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 建议：将属性挂在body上，可以避免很多奇怪的bug</span><br><span class=\"line\">body&#123;--webkit-overflow-scrolling: touch;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/*局部dom节点*/</span><br><span class=\"line\">.scroll-el&#123;overflow:auto;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>流畅滚动的军规：</strong></p>\n<blockquote>\n<p>body上加上 -webkit-overfllow-scrolling:touch<br>iOS 尽量使用局部滚动<br>iOS 引进ScrollFix 避免出界<br>Android下尽量使用全局滚动</p>\n</blockquote>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>当我们谈论前端性能 我们在谈论什么？加载性能、渲染性能、用户交互相应速度、动画流畅、DOM操作无闪烁。。。</p>","more":"<h4 id=\"Meta-基础知识：\"><a href=\"#Meta-基础知识：\" class=\"headerlink\" title=\"Meta 基础知识：\"></a>Meta 基础知识：</h4><ul>\n<li><p>viewport</p>\n<p>1、JS动态判断</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, minimal-ui&quot;&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p> width：设置viewport宽度，为一个正整数，或字符串‘device-width’；<br> height：设置viewport高度，一般不设置，自适应；<br> initial-scale：默认缩放比例，为一个数字，可以带小数；<br> minimum-scale：允许用户最小缩放比例，为一个数字，可以带小数；<br> maximum-scale：允许用户最大缩放比例，为一个数字，可以带小数；<br> user-scalable：是否允许手动缩放。</p>\n</blockquote>\n<p>2、JS动态计算<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var winWidth=  parseInt(window.screen.width);</span><br><span class=\"line\">var phoneScale = winWidth/640;</span><br><span class=\"line\">var ua = navigator.userAgent;</span><br><span class=\"line\">if (/Android (\\d+\\.\\d+)/.test(ua))&#123;</span><br><span class=\"line\">  var version = parseFloat(RegExp.$1);</span><br><span class=\"line\">  if(version&gt;2.3)&#123;</span><br><span class=\"line\">    document.write(&apos;&lt;meta name=&quot;viewport&quot; content=&quot;width=640, minimum-scale = &apos;+phoneScale+&apos;, maximum-scale = &apos;+phoneScale+&apos;, target-densitydpi=device-dpi&quot;&gt;&apos;);</span><br><span class=\"line\">  &#125;else&#123;</span><br><span class=\"line\">    document.write(&apos;&lt;meta name=&quot;viewport&quot; content=&quot;width=640, target-densitydpi=device-dpi&quot;&gt;&apos;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">  document.write(&apos;&lt;meta name=&quot;viewport&quot; content=&quot;width=640, user-scalable=no, target-densitydpi=device-dpi&quot;&gt;&apos;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>其他<strong>meta</strong>标签<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 横竖屏设置 --&gt;</span><br><span class=\"line\">&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 可隐藏地址栏，仅针对IOS的Safari（注：IOS7.0版本以后，safari上已看不到效果），和minimal-ui效果类似 --&gt;</span><br><span class=\"line\">&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 仅针对IOS的Safari顶端状态条的样式（可选default/black/black-translucent ） --&gt;</span><br><span class=\"line\">&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 格式检测 数字识别为电话号码/对邮箱地址的识别/跳转至地图 --&gt;</span><br><span class=\"line\">&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no, email=no, adress=no&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- UC强制全屏 --&gt;</span><br><span class=\"line\">&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- QQ强制全屏 --&gt;</span><br><span class=\"line\">&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>更多 <a href=\"https://segmentfault.com/a/1190000002407912\" target=\"_blank\" rel=\"noopener\"> &lt; meta &gt; 知识获取</a>。</p>\n</blockquote>\n<h3 id=\"微信单页面修改title\"><a href=\"#微信单页面修改title\" class=\"headerlink\" title=\"微信单页面修改title\"></a>微信单页面修改title</h3><p><em>问题：当页面载入时，微信顶部 title 获取并显示，之后怎么用JS修改 title ，无效。</em><br><em>这个是针对IOS出现的 hack ，Android是有效的。 貌似是IOS的webview没有监听titlechange事件。 目前的处理就是使用重新载入页面的形式来唤醒页面的title有关事件。</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 解决iOS设备修改title不起作用的bug</span><br><span class=\"line\">function set_title (title) &#123;</span><br><span class=\"line\">  document.title = title;</span><br><span class=\"line\">  if (!ua.is_idevice) return;</span><br><span class=\"line\">  // 随便访问iframe访问一个网页，title就可以刷新了</span><br><span class=\"line\">  var $iframe = $(&quot;&lt;iframe style=&apos;display:none;&apos; src=&apos;/favicon.ico&apos;&gt;&lt;/iframe&gt;&quot;);</span><br><span class=\"line\">  $iframe.on(&apos;load&apos;,function() &#123;</span><br><span class=\"line\">    setTimeout(function() &#123;</span><br><span class=\"line\">      $iframe.off(&apos;load&apos;).remove();</span><br><span class=\"line\">    &#125;, 0);</span><br><span class=\"line\">  &#125;).appendTo($body);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"点击事件-Click\"><a href=\"#点击事件-Click\" class=\"headerlink\" title=\"点击事件 Click\"></a>点击事件 <strong>Click</strong></h3><p>click事件，移动端click事件有300ms的延迟（有很多PC页面没有做移动端分辨率兼容==》需要放大缩小来浏览==》移动端常用的放大缩小方案：双击==》区分单双击==》设置300ms延迟）<br>移动端解决方案：<br>引入zepto,用tap事件代替click;<br>tap不是原生事件，touchstart/touchmove/touchend<br>基本条件：从触摸到离开时间间隔短，从起点到终点距离间隔小</p>\n<p>点击态：<br>方案1：用  :active 伪类  缺点：滚动的时候也会触发样式<br>方案2：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 点击事件带点击态</span><br><span class=\"line\">$el.on(&apos;tap&apos;,function(e)&#123;</span><br><span class=\"line\">    var $target = $(e.target);</span><br><span class=\"line\">    var timer=null;</span><br><span class=\"line\">    $target.addClass(&apos;active&apos;);</span><br><span class=\"line\">    timer = setTimeout(function()&#123;</span><br><span class=\"line\">        $target.removeClass(&apos;active&apos;);</span><br><span class=\"line\">        clearTimeout(timer);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"滚动\"><a href=\"#滚动\" class=\"headerlink\" title=\"滚动\"></a>滚动</h3><p>全局滚动：滚动节点在body 节点或者更顶层<br>局部滚动:  滚动条在body 下的某一个dom 节点上</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Col1</th>\n<th style=\"text-align:left\">iOS</th>\n<th style=\"text-align:left\">Android</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">全局滚动</td>\n<td style=\"text-align:left\">默认支持</td>\n<td style=\"text-align:left\">定制版本较多，表现各异</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">局部滚动</td>\n<td style=\"text-align:left\">默认没有滚动条，且滑动起来干涩</td>\n<td style=\"text-align:left\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">弹性滚动</td>\n<td style=\"text-align:left\">支持</td>\n<td style=\"text-align:left\">默认没有弹性滚动效果</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">-webkit-overflow-scrolling</td>\n<td style=\"text-align:left\">支持</td>\n<td style=\"text-align:left\">默认浏览器不支持 Android版chrome支持</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">触发出界</td>\n<td style=\"text-align:left\"><strong>全局滚动：</strong>滚动到页面顶部（或底部）时继续向下（向上）滑动，就会出现;<br> <strong>局部滚动：</strong>滚动到页面顶部（或底部）时，手指离开停下，再继续向下（向上）滑动，就会出现</td>\n<td style=\"text-align:left\">-</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p>iOS局部滚动使用弹性滚动效果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 建议：将属性挂在body上，可以避免很多奇怪的bug</span><br><span class=\"line\">body&#123;--webkit-overflow-scrolling: touch;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/*局部dom节点*/</span><br><span class=\"line\">.scroll-el&#123;overflow:auto;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>流畅滚动的军规：</strong></p>\n<blockquote>\n<p>body上加上 -webkit-overfllow-scrolling:touch<br>iOS 尽量使用局部滚动<br>iOS 引进ScrollFix 避免出界<br>Android下尽量使用全局滚动</p>\n</blockquote>\n</li>\n</ul>"},{"title":"HTTP服务器之 - http-server (nodeJs)","date":"2016-08-04T07:03:15.000Z","_content":"Sublime Text3 是一款非常优秀的跨平台编辑器，工欲善其事必先利其器，作为一名开发同学，这里简单记录下Sublime Text3的配置。\n<!--more-->\n## 安装命令：\n```\n$ npm install -g  http-server\n```\n\n## 运行命令：\n切换到项目目录下\n```\n$ http-server [path] [options]\n```\n\n## 使用于package.json\n```\n \"scripts\": {\n     \"start\": \"http-server -a 0.0.0.0 -p 8000\",\n }\n ```\n\n参数配置：\n-p 端口号 (默认 8080)\n\n-a IP 地址 (默认 0.0.0.0)\n\n-d 显示目录列表 (默认 'True')\n\n-i 显示 autoIndex (默认 'True')\n\n-e or --ext 如果没有提供默认的文件扩展名(默认 'html')\n\n-s or --silent 禁止日志信息输出\n\n--cors 启用 CORS via the Access-Control-Allow-Origin header\n\n-o 在开始服务后打开浏览器\n-c 为 cache-control max-age header 设置Cache time(秒) , e.g. -c10 for 10 seconds (defaults to '3600'). 禁用 caching, 则使用 -c-1.\n-U 或 --utc 使用UTC time 格式化log消息\n\n-P or --proxy Proxies all requests which can't be resolved locally to the given url. e.g.: -P http://someurl.com\n\n-S or --ssl 启用 https\n\n-C or --cert ssl cert 文件路径 (default: cert.pem)\n\n-K or --key Path to ssl key file (default: key.pem).\n\n-r or --robots Provide a /robots.txt (whose content defaults to 'User-agent: *\\nDisallow: /')\n\n-h or --help 打印以上列表并退出 \n\n","source":"_posts/HTTP服务器之 - http-server (nodeJs).md","raw":"---\ntitle: HTTP服务器之 - http-server (nodeJs)\ndate: 2016-08-04 15:03:15\ntags: HTTP服务器\ncategory: nodeJs\n---\nSublime Text3 是一款非常优秀的跨平台编辑器，工欲善其事必先利其器，作为一名开发同学，这里简单记录下Sublime Text3的配置。\n<!--more-->\n## 安装命令：\n```\n$ npm install -g  http-server\n```\n\n## 运行命令：\n切换到项目目录下\n```\n$ http-server [path] [options]\n```\n\n## 使用于package.json\n```\n \"scripts\": {\n     \"start\": \"http-server -a 0.0.0.0 -p 8000\",\n }\n ```\n\n参数配置：\n-p 端口号 (默认 8080)\n\n-a IP 地址 (默认 0.0.0.0)\n\n-d 显示目录列表 (默认 'True')\n\n-i 显示 autoIndex (默认 'True')\n\n-e or --ext 如果没有提供默认的文件扩展名(默认 'html')\n\n-s or --silent 禁止日志信息输出\n\n--cors 启用 CORS via the Access-Control-Allow-Origin header\n\n-o 在开始服务后打开浏览器\n-c 为 cache-control max-age header 设置Cache time(秒) , e.g. -c10 for 10 seconds (defaults to '3600'). 禁用 caching, 则使用 -c-1.\n-U 或 --utc 使用UTC time 格式化log消息\n\n-P or --proxy Proxies all requests which can't be resolved locally to the given url. e.g.: -P http://someurl.com\n\n-S or --ssl 启用 https\n\n-C or --cert ssl cert 文件路径 (default: cert.pem)\n\n-K or --key Path to ssl key file (default: key.pem).\n\n-r or --robots Provide a /robots.txt (whose content defaults to 'User-agent: *\\nDisallow: /')\n\n-h or --help 打印以上列表并退出 \n\n","slug":"HTTP服务器之 - http-server (nodeJs)","published":1,"updated":"2019-03-21T03:42:03.283Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtifjpsp0002lohik43ft61u","content":"<p>Sublime Text3 是一款非常优秀的跨平台编辑器，工欲善其事必先利其器，作为一名开发同学，这里简单记录下Sublime Text3的配置。<br><a id=\"more\"></a></p>\n<h2 id=\"安装命令：\"><a href=\"#安装命令：\" class=\"headerlink\" title=\"安装命令：\"></a>安装命令：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g  http-server</span><br></pre></td></tr></table></figure>\n<h2 id=\"运行命令：\"><a href=\"#运行命令：\" class=\"headerlink\" title=\"运行命令：\"></a>运行命令：</h2><p>切换到项目目录下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ http-server [path] [options]</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用于package-json\"><a href=\"#使用于package-json\" class=\"headerlink\" title=\"使用于package.json\"></a>使用于package.json</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;start&quot;: &quot;http-server -a 0.0.0.0 -p 8000&quot;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>参数配置：<br>-p 端口号 (默认 8080)</p>\n<p>-a IP 地址 (默认 0.0.0.0)</p>\n<p>-d 显示目录列表 (默认 ‘True’)</p>\n<p>-i 显示 autoIndex (默认 ‘True’)</p>\n<p>-e or –ext 如果没有提供默认的文件扩展名(默认 ‘html’)</p>\n<p>-s or –silent 禁止日志信息输出</p>\n<p>–cors 启用 CORS via the Access-Control-Allow-Origin header</p>\n<p>-o 在开始服务后打开浏览器<br>-c 为 cache-control max-age header 设置Cache time(秒) , e.g. -c10 for 10 seconds (defaults to ‘3600’). 禁用 caching, 则使用 -c-1.<br>-U 或 –utc 使用UTC time 格式化log消息</p>\n<p>-P or –proxy Proxies all requests which can’t be resolved locally to the given url. e.g.: -P <a href=\"http://someurl.com\" target=\"_blank\" rel=\"noopener\">http://someurl.com</a></p>\n<p>-S or –ssl 启用 https</p>\n<p>-C or –cert ssl cert 文件路径 (default: cert.pem)</p>\n<p>-K or –key Path to ssl key file (default: key.pem).</p>\n<p>-r or –robots Provide a /robots.txt (whose content defaults to ‘User-agent: *\\nDisallow: /‘)</p>\n<p>-h or –help 打印以上列表并退出 </p>\n","site":{"data":{}},"excerpt":"<p>Sublime Text3 是一款非常优秀的跨平台编辑器，工欲善其事必先利其器，作为一名开发同学，这里简单记录下Sublime Text3的配置。<br>","more":"</p>\n<h2 id=\"安装命令：\"><a href=\"#安装命令：\" class=\"headerlink\" title=\"安装命令：\"></a>安装命令：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g  http-server</span><br></pre></td></tr></table></figure>\n<h2 id=\"运行命令：\"><a href=\"#运行命令：\" class=\"headerlink\" title=\"运行命令：\"></a>运行命令：</h2><p>切换到项目目录下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ http-server [path] [options]</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用于package-json\"><a href=\"#使用于package-json\" class=\"headerlink\" title=\"使用于package.json\"></a>使用于package.json</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;start&quot;: &quot;http-server -a 0.0.0.0 -p 8000&quot;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>参数配置：<br>-p 端口号 (默认 8080)</p>\n<p>-a IP 地址 (默认 0.0.0.0)</p>\n<p>-d 显示目录列表 (默认 ‘True’)</p>\n<p>-i 显示 autoIndex (默认 ‘True’)</p>\n<p>-e or –ext 如果没有提供默认的文件扩展名(默认 ‘html’)</p>\n<p>-s or –silent 禁止日志信息输出</p>\n<p>–cors 启用 CORS via the Access-Control-Allow-Origin header</p>\n<p>-o 在开始服务后打开浏览器<br>-c 为 cache-control max-age header 设置Cache time(秒) , e.g. -c10 for 10 seconds (defaults to ‘3600’). 禁用 caching, 则使用 -c-1.<br>-U 或 –utc 使用UTC time 格式化log消息</p>\n<p>-P or –proxy Proxies all requests which can’t be resolved locally to the given url. e.g.: -P <a href=\"http://someurl.com\" target=\"_blank\" rel=\"noopener\">http://someurl.com</a></p>\n<p>-S or –ssl 启用 https</p>\n<p>-C or –cert ssl cert 文件路径 (default: cert.pem)</p>\n<p>-K or –key Path to ssl key file (default: key.pem).</p>\n<p>-r or –robots Provide a /robots.txt (whose content defaults to ‘User-agent: *\\nDisallow: /‘)</p>\n<p>-h or –help 打印以上列表并退出 </p>"},{"title":"Git 的安装和使用","date":"2016-07-14T02:46:06.000Z","_content":"Git 是一个很强大的分布式版本控制系统。它不但适用于管理大型开源软件的源代码，管理私人的文档和源代码也有很多优势。\n<!--more-->\n## 安装\n在windows下安装git比较常用的有以下几种方式：\n* [Git 官方版本的安装](http://git-scm.com/download/win)\n* [GitHub for Windows](https://desktop.github.com/)\n* [TortoiseGit  1.8.12.0-64](//assets-github.cheris.com.cn/file/git/TortoiseGit-1.8.12.0-64bit.msi)(点击直接下载)\n* [TortoiseGit-LanguagePack-zh_CN  1.8.12.0-64](//assets-github.cheris.com.cn/file/git/TortoiseGit-LanguagePack-1.8.12.0-64bit-zh_CN.msi)(点击直接下载)\n\n## 配置\n当安装完Git应该做的第一件事情就是设置用户名称和邮件地址。这样做很重要，因为每一个Git的提交都会使用这些信息，并且它会写入你的每一次提交中，不可更改：\n``` bash\n git config --global user.name \"username\"\n$ git config --global user.email \"username@example.com\"\n```\n对于user.email，因为在GitHub的commits信息上是可见的，所以如果你不想让人知道你的email，可以Keeping your email address private:\n1. 在GitHub右上方点击你的头像，选择”Settings”；\n2. 在右边的”Personal settings”侧边栏选择”Emails”；\n3. 选择”Keep my email address private”。\n\n这样，你就可以使用如下格式的email进行配置：\n``` bash\n$ git config --global user.email \"username@users.noreply.github.com\"\n```\n\n![git速查表](//assets-github.cheris.com.cn/images/github/20140730150425_610.jpg) \n![git常用命令](//assets-github.cheris.com.cn/images/github/git%E9%80%9F%E6%9F%A5%E8%A1%A8.png)\n## 创建\n复制一个已创建的仓库:\n``` bash\n$ git clone git@github.com:example/example.github.io.git\n```\n\n创建一个新的本地仓库:\n``` bash\n$ git init\n```\n\n## 本地修改\n显示工作路径下已修改的文件：\n``` bash\n$ git status\n```\n\n显示与上次提交版本文件的不同：\n``` bash\n$ git diff\n```\n\n把当前所有修改添加到下次提交中：\n``` bash\n$ git add\n```\n\n把对某个文件的修改添加到下次提交中：\n``` bash\n$ git add -p <file>\n```\n\n提交本地的所有修改：\n``` bash\n$ git commit -a\n```\n\n提交之前已标记的变化：\n``` bash\n$ git commit\n```\n\n附加消息提交：\n``` bash\n$ git commit -m 'message here'\n```\n\n提交，并将提交时间设置为之前的某个日期:\n``` bash\ngit commit --date=\"`date --date='n day ago'`\" -am \"Commit Message\"\n```\n\n修改上次提交\n请勿修改已发布的提交记录!\n``` bash\n$ git commit --amend\n```\n\n把当前分支中未提交的修改移动到其他分支\n``` bash\ngit stash\ngit checkout branch2\ngit stash pop\n```\n## 搜索\n从当前目录的所有文件中查找文本内容：\n``` bash\n$ git grep \"Hello\"\n```\n\n在某一版本中搜索文本：\n``` bash\n$ git grep \"Hello\" v2.5\n```\n\n## 提交历史\n从最新提交开始，显示所有的提交记录（显示hash， 作者信息，提交的标题和时间）：\n``` bash\n$ git log\n```\n\n显示所有提交（仅显示提交的hash和message）：\n``` bash\n$ git log --oneline\n```\n\n显示某个用户的所有提交：\n``` bash\n$ git log --author=\"username\"\n```\n\n显示某个文件的所有修改：\n``` bash\n$ git log -p <file>\n```\n\n谁，在什么时间，修改了文件的什么内容：\n``` bash\n$ git blame <file>\n```\n\n#分支与标签\n列出所有的分支：\n``` bash\n$ git branch\n```\n\n切换分支：\n``` bash\n$ git checkout <branch>\n```\n\n创建并切换到新分支:\n``` bash\n$ git checkout -b <branch>\n```\n\n基于当前分支创建新分支：\n``` bash\n$ git branch <new-branch>\n```\n\n基于远程分支创建新的可追溯的分支：\n``` bash\n$ git branch --track <new-branch> <remote-branch>\n```\n\n删除本地分支:\n``` bash\n$ git branch -d <branch>\n```\n\n给当前版本打标签：\n``` bash\n$ git tag <tag-name>\n```\n\n## 更新与发布\n列出当前配置的远程端：\n``` bash\n$ git remote -v\n```\n\n显示远程端的信息：\n``` bash\n$ git remote show <remote>\n```\n\n添加新的远程端：\n``` bash\n$ git remote add <remote> <url>\n```\n\n下载远程端版本，但不合并到HEAD中：\n``` bash\n$ git fetch <remote>\n```\n\n下载远程端版本，并自动与HEAD版本合并：\n``` bash\n$ git remote pull <remote> <url>\n```\n\n将远程端版本合并到本地版本中：\n``` bash\n$ git pull origin master\n```\n\n将本地版本发布到远程端：\n``` bash\n$ git push remote <remote> <branch>\n```\n\n删除远程端分支：\n``` bash\n$ git push <remote> :<branch> (since Git v1.5.0)\n或\ngit push <remote> --delete <branch> (since Git v1.7.0)\n```\n\n发布标签:\n``` bash\n$ git push --tags\n```\n\n## 合并与重置\n将分支合并到当前HEAD中：\n``` bash\n$ git merge <branch>\n```\n\n将当前HEAD版本重置到分支中:\n请勿重置已发布的提交!\n``` bash\n$ git rebase <branch>\n```\n\n退出重置:\n``` bash\n$ git rebase --abort\n```\n\n解决冲突后继续重置：\n``` bash\n$ git rebase --continue\n```\n\n使用配置好的merge tool 解决冲突：\n``` bash\n$ git mergetool\n```\n\n在编辑器中手动解决冲突后，标记文件为已解决冲突\n``` bash\n$ git add <resolved-file>\n$ git rm <resolved-file>\n```\n\n## 撤销\n放弃工作目录下的所有修改：\n``` bash\n$ git reset --hard HEAD\n```\n\n移除缓存区的所有文件（i.e. 撤销上次git add）:\n``` bash\n$ git reset HEAD\n```\n\n放弃某个文件的所有本地修改：\n``` bash\n$ git checkout HEAD <file>\n```\n\n重置一个提交（通过创建一个截然不同的新提交）\n``` bash\n$ git revert <commit>\n```\n\n将HEAD重置到指定的版本，并抛弃该版本之后的所有修改：\n``` bash\n$ git reset --hard <commit>\n```\n\n将HEAD重置到上一次提交的版本，并将之后的修改标记为未添加到缓存区的修改：\n``` bash\n$ git reset <commit>\n```\n\n将HEAD重置到上一次提交的版本，并保留未提交的本地修改：\n``` bash\n$ git reset --keep <commit>\n```\n","source":"_posts/Git常用命令.md","raw":"---\ntitle: Git 的安装和使用\ndate: 2016-07-14 10:46:06\ntags: Git\ncategory: 前端\n---\nGit 是一个很强大的分布式版本控制系统。它不但适用于管理大型开源软件的源代码，管理私人的文档和源代码也有很多优势。\n<!--more-->\n## 安装\n在windows下安装git比较常用的有以下几种方式：\n* [Git 官方版本的安装](http://git-scm.com/download/win)\n* [GitHub for Windows](https://desktop.github.com/)\n* [TortoiseGit  1.8.12.0-64](//assets-github.cheris.com.cn/file/git/TortoiseGit-1.8.12.0-64bit.msi)(点击直接下载)\n* [TortoiseGit-LanguagePack-zh_CN  1.8.12.0-64](//assets-github.cheris.com.cn/file/git/TortoiseGit-LanguagePack-1.8.12.0-64bit-zh_CN.msi)(点击直接下载)\n\n## 配置\n当安装完Git应该做的第一件事情就是设置用户名称和邮件地址。这样做很重要，因为每一个Git的提交都会使用这些信息，并且它会写入你的每一次提交中，不可更改：\n``` bash\n git config --global user.name \"username\"\n$ git config --global user.email \"username@example.com\"\n```\n对于user.email，因为在GitHub的commits信息上是可见的，所以如果你不想让人知道你的email，可以Keeping your email address private:\n1. 在GitHub右上方点击你的头像，选择”Settings”；\n2. 在右边的”Personal settings”侧边栏选择”Emails”；\n3. 选择”Keep my email address private”。\n\n这样，你就可以使用如下格式的email进行配置：\n``` bash\n$ git config --global user.email \"username@users.noreply.github.com\"\n```\n\n![git速查表](//assets-github.cheris.com.cn/images/github/20140730150425_610.jpg) \n![git常用命令](//assets-github.cheris.com.cn/images/github/git%E9%80%9F%E6%9F%A5%E8%A1%A8.png)\n## 创建\n复制一个已创建的仓库:\n``` bash\n$ git clone git@github.com:example/example.github.io.git\n```\n\n创建一个新的本地仓库:\n``` bash\n$ git init\n```\n\n## 本地修改\n显示工作路径下已修改的文件：\n``` bash\n$ git status\n```\n\n显示与上次提交版本文件的不同：\n``` bash\n$ git diff\n```\n\n把当前所有修改添加到下次提交中：\n``` bash\n$ git add\n```\n\n把对某个文件的修改添加到下次提交中：\n``` bash\n$ git add -p <file>\n```\n\n提交本地的所有修改：\n``` bash\n$ git commit -a\n```\n\n提交之前已标记的变化：\n``` bash\n$ git commit\n```\n\n附加消息提交：\n``` bash\n$ git commit -m 'message here'\n```\n\n提交，并将提交时间设置为之前的某个日期:\n``` bash\ngit commit --date=\"`date --date='n day ago'`\" -am \"Commit Message\"\n```\n\n修改上次提交\n请勿修改已发布的提交记录!\n``` bash\n$ git commit --amend\n```\n\n把当前分支中未提交的修改移动到其他分支\n``` bash\ngit stash\ngit checkout branch2\ngit stash pop\n```\n## 搜索\n从当前目录的所有文件中查找文本内容：\n``` bash\n$ git grep \"Hello\"\n```\n\n在某一版本中搜索文本：\n``` bash\n$ git grep \"Hello\" v2.5\n```\n\n## 提交历史\n从最新提交开始，显示所有的提交记录（显示hash， 作者信息，提交的标题和时间）：\n``` bash\n$ git log\n```\n\n显示所有提交（仅显示提交的hash和message）：\n``` bash\n$ git log --oneline\n```\n\n显示某个用户的所有提交：\n``` bash\n$ git log --author=\"username\"\n```\n\n显示某个文件的所有修改：\n``` bash\n$ git log -p <file>\n```\n\n谁，在什么时间，修改了文件的什么内容：\n``` bash\n$ git blame <file>\n```\n\n#分支与标签\n列出所有的分支：\n``` bash\n$ git branch\n```\n\n切换分支：\n``` bash\n$ git checkout <branch>\n```\n\n创建并切换到新分支:\n``` bash\n$ git checkout -b <branch>\n```\n\n基于当前分支创建新分支：\n``` bash\n$ git branch <new-branch>\n```\n\n基于远程分支创建新的可追溯的分支：\n``` bash\n$ git branch --track <new-branch> <remote-branch>\n```\n\n删除本地分支:\n``` bash\n$ git branch -d <branch>\n```\n\n给当前版本打标签：\n``` bash\n$ git tag <tag-name>\n```\n\n## 更新与发布\n列出当前配置的远程端：\n``` bash\n$ git remote -v\n```\n\n显示远程端的信息：\n``` bash\n$ git remote show <remote>\n```\n\n添加新的远程端：\n``` bash\n$ git remote add <remote> <url>\n```\n\n下载远程端版本，但不合并到HEAD中：\n``` bash\n$ git fetch <remote>\n```\n\n下载远程端版本，并自动与HEAD版本合并：\n``` bash\n$ git remote pull <remote> <url>\n```\n\n将远程端版本合并到本地版本中：\n``` bash\n$ git pull origin master\n```\n\n将本地版本发布到远程端：\n``` bash\n$ git push remote <remote> <branch>\n```\n\n删除远程端分支：\n``` bash\n$ git push <remote> :<branch> (since Git v1.5.0)\n或\ngit push <remote> --delete <branch> (since Git v1.7.0)\n```\n\n发布标签:\n``` bash\n$ git push --tags\n```\n\n## 合并与重置\n将分支合并到当前HEAD中：\n``` bash\n$ git merge <branch>\n```\n\n将当前HEAD版本重置到分支中:\n请勿重置已发布的提交!\n``` bash\n$ git rebase <branch>\n```\n\n退出重置:\n``` bash\n$ git rebase --abort\n```\n\n解决冲突后继续重置：\n``` bash\n$ git rebase --continue\n```\n\n使用配置好的merge tool 解决冲突：\n``` bash\n$ git mergetool\n```\n\n在编辑器中手动解决冲突后，标记文件为已解决冲突\n``` bash\n$ git add <resolved-file>\n$ git rm <resolved-file>\n```\n\n## 撤销\n放弃工作目录下的所有修改：\n``` bash\n$ git reset --hard HEAD\n```\n\n移除缓存区的所有文件（i.e. 撤销上次git add）:\n``` bash\n$ git reset HEAD\n```\n\n放弃某个文件的所有本地修改：\n``` bash\n$ git checkout HEAD <file>\n```\n\n重置一个提交（通过创建一个截然不同的新提交）\n``` bash\n$ git revert <commit>\n```\n\n将HEAD重置到指定的版本，并抛弃该版本之后的所有修改：\n``` bash\n$ git reset --hard <commit>\n```\n\n将HEAD重置到上一次提交的版本，并将之后的修改标记为未添加到缓存区的修改：\n``` bash\n$ git reset <commit>\n```\n\n将HEAD重置到上一次提交的版本，并保留未提交的本地修改：\n``` bash\n$ git reset --keep <commit>\n```\n","slug":"Git常用命令","published":1,"updated":"2019-03-21T03:42:03.282Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtifjpss0003lohid8idlid0","content":"<p>Git 是一个很强大的分布式版本控制系统。它不但适用于管理大型开源软件的源代码，管理私人的文档和源代码也有很多优势。<br><a id=\"more\"></a></p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>在windows下安装git比较常用的有以下几种方式：</p>\n<ul>\n<li><a href=\"http://git-scm.com/download/win\" target=\"_blank\" rel=\"noopener\">Git 官方版本的安装</a></li>\n<li><a href=\"https://desktop.github.com/\" target=\"_blank\" rel=\"noopener\">GitHub for Windows</a></li>\n<li><a href=\"//assets-github.cheris.com.cn/file/git/TortoiseGit-1.8.12.0-64bit.msi\">TortoiseGit  1.8.12.0-64</a>(点击直接下载)</li>\n<li><a href=\"//assets-github.cheris.com.cn/file/git/TortoiseGit-LanguagePack-1.8.12.0-64bit-zh_CN.msi\">TortoiseGit-LanguagePack-zh_CN  1.8.12.0-64</a>(点击直接下载)</li>\n</ul>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>当安装完Git应该做的第一件事情就是设置用户名称和邮件地址。这样做很重要，因为每一个Git的提交都会使用这些信息，并且它会写入你的每一次提交中，不可更改：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git config --global user.name <span class=\"string\">\"username\"</span></span><br><span class=\"line\">$ git config --global user.email <span class=\"string\">\"username@example.com\"</span></span><br></pre></td></tr></table></figure></p>\n<p>对于user.email，因为在GitHub的commits信息上是可见的，所以如果你不想让人知道你的email，可以Keeping your email address private:</p>\n<ol>\n<li>在GitHub右上方点击你的头像，选择”Settings”；</li>\n<li>在右边的”Personal settings”侧边栏选择”Emails”；</li>\n<li>选择”Keep my email address private”。</li>\n</ol>\n<p>这样，你就可以使用如下格式的email进行配置：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --global user.email <span class=\"string\">\"username@users.noreply.github.com\"</span></span><br></pre></td></tr></table></figure></p>\n<p><img src=\"//assets-github.cheris.com.cn/images/github/20140730150425_610.jpg\" alt=\"git速查表\"><br><img src=\"//assets-github.cheris.com.cn/images/github/git%E9%80%9F%E6%9F%A5%E8%A1%A8.png\" alt=\"git常用命令\"></p>\n<h2 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h2><p>复制一个已创建的仓库:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> git@github.com:example/example.github.io.git</span><br></pre></td></tr></table></figure></p>\n<p>创建一个新的本地仓库:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git init</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"本地修改\"><a href=\"#本地修改\" class=\"headerlink\" title=\"本地修改\"></a>本地修改</h2><p>显示工作路径下已修改的文件：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br></pre></td></tr></table></figure></p>\n<p>显示与上次提交版本文件的不同：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git diff</span><br></pre></td></tr></table></figure></p>\n<p>把当前所有修改添加到下次提交中：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add</span><br></pre></td></tr></table></figure></p>\n<p>把对某个文件的修改添加到下次提交中：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add -p &lt;file&gt;</span><br></pre></td></tr></table></figure></p>\n<p>提交本地的所有修改：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit -a</span><br></pre></td></tr></table></figure></p>\n<p>提交之前已标记的变化：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit</span><br></pre></td></tr></table></figure></p>\n<p>附加消息提交：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit -m <span class=\"string\">'message here'</span></span><br></pre></td></tr></table></figure></p>\n<p>提交，并将提交时间设置为之前的某个日期:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit --date=<span class=\"string\">\"`date --date='n day ago'`\"</span> -am <span class=\"string\">\"Commit Message\"</span></span><br></pre></td></tr></table></figure></p>\n<p>修改上次提交<br>请勿修改已发布的提交记录!<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit --amend</span><br></pre></td></tr></table></figure></p>\n<p>把当前分支中未提交的修改移动到其他分支<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git stash</span><br><span class=\"line\">git checkout branch2</span><br><span class=\"line\">git stash pop</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"搜索\"><a href=\"#搜索\" class=\"headerlink\" title=\"搜索\"></a>搜索</h2><p>从当前目录的所有文件中查找文本内容：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git grep <span class=\"string\">\"Hello\"</span></span><br></pre></td></tr></table></figure></p>\n<p>在某一版本中搜索文本：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git grep <span class=\"string\">\"Hello\"</span> v2.5</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"提交历史\"><a href=\"#提交历史\" class=\"headerlink\" title=\"提交历史\"></a>提交历史</h2><p>从最新提交开始，显示所有的提交记录（显示hash， 作者信息，提交的标题和时间）：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">log</span></span><br></pre></td></tr></table></figure></p>\n<p>显示所有提交（仅显示提交的hash和message）：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">log</span> --oneline</span><br></pre></td></tr></table></figure></p>\n<p>显示某个用户的所有提交：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">log</span> --author=<span class=\"string\">\"username\"</span></span><br></pre></td></tr></table></figure></p>\n<p>显示某个文件的所有修改：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">log</span> -p &lt;file&gt;</span><br></pre></td></tr></table></figure></p>\n<p>谁，在什么时间，修改了文件的什么内容：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git blame &lt;file&gt;</span><br></pre></td></tr></table></figure></p>\n<p>#分支与标签<br>列出所有的分支：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch</span><br></pre></td></tr></table></figure></p>\n<p>切换分支：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout &lt;branch&gt;</span><br></pre></td></tr></table></figure></p>\n<p>创建并切换到新分支:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout -b &lt;branch&gt;</span><br></pre></td></tr></table></figure></p>\n<p>基于当前分支创建新分支：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch &lt;new-branch&gt;</span><br></pre></td></tr></table></figure></p>\n<p>基于远程分支创建新的可追溯的分支：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch --track &lt;new-branch&gt; &lt;remote-branch&gt;</span><br></pre></td></tr></table></figure></p>\n<p>删除本地分支:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch -d &lt;branch&gt;</span><br></pre></td></tr></table></figure></p>\n<p>给当前版本打标签：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag &lt;tag-name&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"更新与发布\"><a href=\"#更新与发布\" class=\"headerlink\" title=\"更新与发布\"></a>更新与发布</h2><p>列出当前配置的远程端：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote -v</span><br></pre></td></tr></table></figure></p>\n<p>显示远程端的信息：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote show &lt;remote&gt;</span><br></pre></td></tr></table></figure></p>\n<p>添加新的远程端：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote add &lt;remote&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure></p>\n<p>下载远程端版本，但不合并到HEAD中：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git fetch &lt;remote&gt;</span><br></pre></td></tr></table></figure></p>\n<p>下载远程端版本，并自动与HEAD版本合并：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote pull &lt;remote&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure></p>\n<p>将远程端版本合并到本地版本中：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git pull origin master</span><br></pre></td></tr></table></figure></p>\n<p>将本地版本发布到远程端：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push remote &lt;remote&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure></p>\n<p>删除远程端分支：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push &lt;remote&gt; :&lt;branch&gt; (since Git v1.5.0)</span><br><span class=\"line\">或</span><br><span class=\"line\">git push &lt;remote&gt; --delete &lt;branch&gt; (since Git v1.7.0)</span><br></pre></td></tr></table></figure></p>\n<p>发布标签:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push --tags</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"合并与重置\"><a href=\"#合并与重置\" class=\"headerlink\" title=\"合并与重置\"></a>合并与重置</h2><p>将分支合并到当前HEAD中：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git merge &lt;branch&gt;</span><br></pre></td></tr></table></figure></p>\n<p>将当前HEAD版本重置到分支中:<br>请勿重置已发布的提交!<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git rebase &lt;branch&gt;</span><br></pre></td></tr></table></figure></p>\n<p>退出重置:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git rebase --abort</span><br></pre></td></tr></table></figure></p>\n<p>解决冲突后继续重置：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git rebase --<span class=\"built_in\">continue</span></span><br></pre></td></tr></table></figure></p>\n<p>使用配置好的merge tool 解决冲突：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git mergetool</span><br></pre></td></tr></table></figure></p>\n<p>在编辑器中手动解决冲突后，标记文件为已解决冲突<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add &lt;resolved-file&gt;</span><br><span class=\"line\">$ git rm &lt;resolved-file&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"撤销\"><a href=\"#撤销\" class=\"headerlink\" title=\"撤销\"></a>撤销</h2><p>放弃工作目录下的所有修改：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset --hard HEAD</span><br></pre></td></tr></table></figure></p>\n<p>移除缓存区的所有文件（i.e. 撤销上次git add）:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset HEAD</span><br></pre></td></tr></table></figure></p>\n<p>放弃某个文件的所有本地修改：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure></p>\n<p>重置一个提交（通过创建一个截然不同的新提交）<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git revert &lt;commit&gt;</span><br></pre></td></tr></table></figure></p>\n<p>将HEAD重置到指定的版本，并抛弃该版本之后的所有修改：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset --hard &lt;commit&gt;</span><br></pre></td></tr></table></figure></p>\n<p>将HEAD重置到上一次提交的版本，并将之后的修改标记为未添加到缓存区的修改：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset &lt;commit&gt;</span><br></pre></td></tr></table></figure></p>\n<p>将HEAD重置到上一次提交的版本，并保留未提交的本地修改：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset --keep &lt;commit&gt;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>Git 是一个很强大的分布式版本控制系统。它不但适用于管理大型开源软件的源代码，管理私人的文档和源代码也有很多优势。<br>","more":"</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>在windows下安装git比较常用的有以下几种方式：</p>\n<ul>\n<li><a href=\"http://git-scm.com/download/win\" target=\"_blank\" rel=\"noopener\">Git 官方版本的安装</a></li>\n<li><a href=\"https://desktop.github.com/\" target=\"_blank\" rel=\"noopener\">GitHub for Windows</a></li>\n<li><a href=\"//assets-github.cheris.com.cn/file/git/TortoiseGit-1.8.12.0-64bit.msi\">TortoiseGit  1.8.12.0-64</a>(点击直接下载)</li>\n<li><a href=\"//assets-github.cheris.com.cn/file/git/TortoiseGit-LanguagePack-1.8.12.0-64bit-zh_CN.msi\">TortoiseGit-LanguagePack-zh_CN  1.8.12.0-64</a>(点击直接下载)</li>\n</ul>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>当安装完Git应该做的第一件事情就是设置用户名称和邮件地址。这样做很重要，因为每一个Git的提交都会使用这些信息，并且它会写入你的每一次提交中，不可更改：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git config --global user.name <span class=\"string\">\"username\"</span></span><br><span class=\"line\">$ git config --global user.email <span class=\"string\">\"username@example.com\"</span></span><br></pre></td></tr></table></figure></p>\n<p>对于user.email，因为在GitHub的commits信息上是可见的，所以如果你不想让人知道你的email，可以Keeping your email address private:</p>\n<ol>\n<li>在GitHub右上方点击你的头像，选择”Settings”；</li>\n<li>在右边的”Personal settings”侧边栏选择”Emails”；</li>\n<li>选择”Keep my email address private”。</li>\n</ol>\n<p>这样，你就可以使用如下格式的email进行配置：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --global user.email <span class=\"string\">\"username@users.noreply.github.com\"</span></span><br></pre></td></tr></table></figure></p>\n<p><img src=\"//assets-github.cheris.com.cn/images/github/20140730150425_610.jpg\" alt=\"git速查表\"><br><img src=\"//assets-github.cheris.com.cn/images/github/git%E9%80%9F%E6%9F%A5%E8%A1%A8.png\" alt=\"git常用命令\"></p>\n<h2 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h2><p>复制一个已创建的仓库:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> git@github.com:example/example.github.io.git</span><br></pre></td></tr></table></figure></p>\n<p>创建一个新的本地仓库:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git init</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"本地修改\"><a href=\"#本地修改\" class=\"headerlink\" title=\"本地修改\"></a>本地修改</h2><p>显示工作路径下已修改的文件：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br></pre></td></tr></table></figure></p>\n<p>显示与上次提交版本文件的不同：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git diff</span><br></pre></td></tr></table></figure></p>\n<p>把当前所有修改添加到下次提交中：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add</span><br></pre></td></tr></table></figure></p>\n<p>把对某个文件的修改添加到下次提交中：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add -p &lt;file&gt;</span><br></pre></td></tr></table></figure></p>\n<p>提交本地的所有修改：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit -a</span><br></pre></td></tr></table></figure></p>\n<p>提交之前已标记的变化：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit</span><br></pre></td></tr></table></figure></p>\n<p>附加消息提交：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit -m <span class=\"string\">'message here'</span></span><br></pre></td></tr></table></figure></p>\n<p>提交，并将提交时间设置为之前的某个日期:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit --date=<span class=\"string\">\"`date --date='n day ago'`\"</span> -am <span class=\"string\">\"Commit Message\"</span></span><br></pre></td></tr></table></figure></p>\n<p>修改上次提交<br>请勿修改已发布的提交记录!<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit --amend</span><br></pre></td></tr></table></figure></p>\n<p>把当前分支中未提交的修改移动到其他分支<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git stash</span><br><span class=\"line\">git checkout branch2</span><br><span class=\"line\">git stash pop</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"搜索\"><a href=\"#搜索\" class=\"headerlink\" title=\"搜索\"></a>搜索</h2><p>从当前目录的所有文件中查找文本内容：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git grep <span class=\"string\">\"Hello\"</span></span><br></pre></td></tr></table></figure></p>\n<p>在某一版本中搜索文本：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git grep <span class=\"string\">\"Hello\"</span> v2.5</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"提交历史\"><a href=\"#提交历史\" class=\"headerlink\" title=\"提交历史\"></a>提交历史</h2><p>从最新提交开始，显示所有的提交记录（显示hash， 作者信息，提交的标题和时间）：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">log</span></span><br></pre></td></tr></table></figure></p>\n<p>显示所有提交（仅显示提交的hash和message）：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">log</span> --oneline</span><br></pre></td></tr></table></figure></p>\n<p>显示某个用户的所有提交：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">log</span> --author=<span class=\"string\">\"username\"</span></span><br></pre></td></tr></table></figure></p>\n<p>显示某个文件的所有修改：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">log</span> -p &lt;file&gt;</span><br></pre></td></tr></table></figure></p>\n<p>谁，在什么时间，修改了文件的什么内容：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git blame &lt;file&gt;</span><br></pre></td></tr></table></figure></p>\n<p>#分支与标签<br>列出所有的分支：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch</span><br></pre></td></tr></table></figure></p>\n<p>切换分支：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout &lt;branch&gt;</span><br></pre></td></tr></table></figure></p>\n<p>创建并切换到新分支:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout -b &lt;branch&gt;</span><br></pre></td></tr></table></figure></p>\n<p>基于当前分支创建新分支：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch &lt;new-branch&gt;</span><br></pre></td></tr></table></figure></p>\n<p>基于远程分支创建新的可追溯的分支：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch --track &lt;new-branch&gt; &lt;remote-branch&gt;</span><br></pre></td></tr></table></figure></p>\n<p>删除本地分支:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch -d &lt;branch&gt;</span><br></pre></td></tr></table></figure></p>\n<p>给当前版本打标签：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag &lt;tag-name&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"更新与发布\"><a href=\"#更新与发布\" class=\"headerlink\" title=\"更新与发布\"></a>更新与发布</h2><p>列出当前配置的远程端：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote -v</span><br></pre></td></tr></table></figure></p>\n<p>显示远程端的信息：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote show &lt;remote&gt;</span><br></pre></td></tr></table></figure></p>\n<p>添加新的远程端：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote add &lt;remote&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure></p>\n<p>下载远程端版本，但不合并到HEAD中：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git fetch &lt;remote&gt;</span><br></pre></td></tr></table></figure></p>\n<p>下载远程端版本，并自动与HEAD版本合并：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote pull &lt;remote&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure></p>\n<p>将远程端版本合并到本地版本中：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git pull origin master</span><br></pre></td></tr></table></figure></p>\n<p>将本地版本发布到远程端：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push remote &lt;remote&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure></p>\n<p>删除远程端分支：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push &lt;remote&gt; :&lt;branch&gt; (since Git v1.5.0)</span><br><span class=\"line\">或</span><br><span class=\"line\">git push &lt;remote&gt; --delete &lt;branch&gt; (since Git v1.7.0)</span><br></pre></td></tr></table></figure></p>\n<p>发布标签:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push --tags</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"合并与重置\"><a href=\"#合并与重置\" class=\"headerlink\" title=\"合并与重置\"></a>合并与重置</h2><p>将分支合并到当前HEAD中：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git merge &lt;branch&gt;</span><br></pre></td></tr></table></figure></p>\n<p>将当前HEAD版本重置到分支中:<br>请勿重置已发布的提交!<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git rebase &lt;branch&gt;</span><br></pre></td></tr></table></figure></p>\n<p>退出重置:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git rebase --abort</span><br></pre></td></tr></table></figure></p>\n<p>解决冲突后继续重置：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git rebase --<span class=\"built_in\">continue</span></span><br></pre></td></tr></table></figure></p>\n<p>使用配置好的merge tool 解决冲突：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git mergetool</span><br></pre></td></tr></table></figure></p>\n<p>在编辑器中手动解决冲突后，标记文件为已解决冲突<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add &lt;resolved-file&gt;</span><br><span class=\"line\">$ git rm &lt;resolved-file&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"撤销\"><a href=\"#撤销\" class=\"headerlink\" title=\"撤销\"></a>撤销</h2><p>放弃工作目录下的所有修改：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset --hard HEAD</span><br></pre></td></tr></table></figure></p>\n<p>移除缓存区的所有文件（i.e. 撤销上次git add）:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset HEAD</span><br></pre></td></tr></table></figure></p>\n<p>放弃某个文件的所有本地修改：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure></p>\n<p>重置一个提交（通过创建一个截然不同的新提交）<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git revert &lt;commit&gt;</span><br></pre></td></tr></table></figure></p>\n<p>将HEAD重置到指定的版本，并抛弃该版本之后的所有修改：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset --hard &lt;commit&gt;</span><br></pre></td></tr></table></figure></p>\n<p>将HEAD重置到上一次提交的版本，并将之后的修改标记为未添加到缓存区的修改：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset &lt;commit&gt;</span><br></pre></td></tr></table></figure></p>\n<p>将HEAD重置到上一次提交的版本，并保留未提交的本地修改：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset --keep &lt;commit&gt;</span><br></pre></td></tr></table></figure></p>"},{"title":"Hexo 多设备管理","date":"2016-07-13T09:06:16.000Z","_content":"如何在不同设备快速、高效的管理自己的博客？\n<!--more-->\n这里采用分支的方法，在一个Github Pages项目上，实现不同终端的管理工作。\n\n实现原理：\n在项目上创建一个分支，暂定为hexo分支。\nmaster分支和hexo分支互不干扰，当然了，如果你没有操作错误，他们也许永远都不需要 merge\n\n* master 分支 存放线上静态站点\n\n* Hexo 分支 保存项目数据 方便随时随地获取项目 并在本地发布站点 （hexo 分支 是直接发布到master分支上的）。\n\n## 具体操作流程：\n\n1. 创建仓库，example.github.io；\n2. 创建两个分支：master 与 hexo；\n3. 设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；\n4. 拷贝仓库到本地；\n```\ngit clone git@github.com:example/example.github.io.git\n```\n4. 在本地 example.github.io 文件夹下通过Git bash(或其他shell)依次执行（此时当前分支应显示为hexo）如下命令;\n```\n$ npm install hexo\n$ hexo init \n$ npm install \n$ npm install hexo-deployer-git\n$ npm install hexo-deployer-git --save\n```\n需要注意的是，npm install hexo之后 git branch 查看当前分支为 hexo 分支，hexo init之后，发现找不到分支了，原因如下：\ngit是通过.git 文件来控制管理的，当在远端仓库clone项目时，项目中默认生成了一个.git 文件，然而操作hexo init 的时候，同样生成了一个.git 文件。\n这样之前生成的.git文件丢失，整个项目就失去版本控制。\n5. 配置hexo 博客\n6. 提交项目文件到hexo 分支，依次执行如下命令：\n```\n$ git add .\n$ git commit -m “…”\n$ git push origin hexo\n```\n7. 执行hexo generate -d生成网站并部署到GitHub上。\n\n\n## 日常维护\n1. 依次执行如下指令将改动推送到GitHub（此时当前分支应为hexo）：\n```\n$ git add .\n$ git commit -m “…”\n$ git push origin hexo\n```\n2. 执行hexo generate -d发布网站到master分支上。\n\n## 更换设备或者本地文件丢失的时候\n1. 拷贝远端仓库（默认分支为hexo）:\n```\ngit clone git@github.com:example/example.github.io.git\n```\n2. 在本地新拷贝的example.github.io文件夹下通过Git bash(或其他shell)依次执行下列指令：\n```\n$ npm install hexo\n$ npm install\n$ npm install hexo-deployer-git\n$ npm install hexo-deployer-git --save\n```\n这里不再需要hexo init这条指令。\n\n## Hexo deploy失败？\n简单说，删掉根目录下的文件夹：.deploy_git，重新deploy就可以了。\n在git提交时，忽略.deploy_git、public文件就好了，其中public是每次hexo g新生成的静态博客文件，不需要同步。\n修改根目录下的.gitignore文件为：\n``` bash\nvim .gitignore\n```\n``` txt\n/.deploy_git\n/public\n```\n\n然后 ‘Esc':wq\n\n\n","source":"_posts/Hexo 多设备管理.md","raw":"---\ntitle: Hexo 多设备管理\ndate: 2016-07-13 17:06:16\ntags: Hexo\ncategory: 前端\n---\n如何在不同设备快速、高效的管理自己的博客？\n<!--more-->\n这里采用分支的方法，在一个Github Pages项目上，实现不同终端的管理工作。\n\n实现原理：\n在项目上创建一个分支，暂定为hexo分支。\nmaster分支和hexo分支互不干扰，当然了，如果你没有操作错误，他们也许永远都不需要 merge\n\n* master 分支 存放线上静态站点\n\n* Hexo 分支 保存项目数据 方便随时随地获取项目 并在本地发布站点 （hexo 分支 是直接发布到master分支上的）。\n\n## 具体操作流程：\n\n1. 创建仓库，example.github.io；\n2. 创建两个分支：master 与 hexo；\n3. 设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；\n4. 拷贝仓库到本地；\n```\ngit clone git@github.com:example/example.github.io.git\n```\n4. 在本地 example.github.io 文件夹下通过Git bash(或其他shell)依次执行（此时当前分支应显示为hexo）如下命令;\n```\n$ npm install hexo\n$ hexo init \n$ npm install \n$ npm install hexo-deployer-git\n$ npm install hexo-deployer-git --save\n```\n需要注意的是，npm install hexo之后 git branch 查看当前分支为 hexo 分支，hexo init之后，发现找不到分支了，原因如下：\ngit是通过.git 文件来控制管理的，当在远端仓库clone项目时，项目中默认生成了一个.git 文件，然而操作hexo init 的时候，同样生成了一个.git 文件。\n这样之前生成的.git文件丢失，整个项目就失去版本控制。\n5. 配置hexo 博客\n6. 提交项目文件到hexo 分支，依次执行如下命令：\n```\n$ git add .\n$ git commit -m “…”\n$ git push origin hexo\n```\n7. 执行hexo generate -d生成网站并部署到GitHub上。\n\n\n## 日常维护\n1. 依次执行如下指令将改动推送到GitHub（此时当前分支应为hexo）：\n```\n$ git add .\n$ git commit -m “…”\n$ git push origin hexo\n```\n2. 执行hexo generate -d发布网站到master分支上。\n\n## 更换设备或者本地文件丢失的时候\n1. 拷贝远端仓库（默认分支为hexo）:\n```\ngit clone git@github.com:example/example.github.io.git\n```\n2. 在本地新拷贝的example.github.io文件夹下通过Git bash(或其他shell)依次执行下列指令：\n```\n$ npm install hexo\n$ npm install\n$ npm install hexo-deployer-git\n$ npm install hexo-deployer-git --save\n```\n这里不再需要hexo init这条指令。\n\n## Hexo deploy失败？\n简单说，删掉根目录下的文件夹：.deploy_git，重新deploy就可以了。\n在git提交时，忽略.deploy_git、public文件就好了，其中public是每次hexo g新生成的静态博客文件，不需要同步。\n修改根目录下的.gitignore文件为：\n``` bash\nvim .gitignore\n```\n``` txt\n/.deploy_git\n/public\n```\n\n然后 ‘Esc':wq\n\n\n","slug":"Hexo 多设备管理","published":1,"updated":"2019-03-21T03:42:03.283Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtifjpsw0006lohiyryushpo","content":"<p>如何在不同设备快速、高效的管理自己的博客？<br><a id=\"more\"></a><br>这里采用分支的方法，在一个Github Pages项目上，实现不同终端的管理工作。</p>\n<p>实现原理：<br>在项目上创建一个分支，暂定为hexo分支。<br>master分支和hexo分支互不干扰，当然了，如果你没有操作错误，他们也许永远都不需要 merge</p>\n<ul>\n<li><p>master 分支 存放线上静态站点</p>\n</li>\n<li><p>Hexo 分支 保存项目数据 方便随时随地获取项目 并在本地发布站点 （hexo 分支 是直接发布到master分支上的）。</p>\n</li>\n</ul>\n<h2 id=\"具体操作流程：\"><a href=\"#具体操作流程：\" class=\"headerlink\" title=\"具体操作流程：\"></a>具体操作流程：</h2><ol>\n<li>创建仓库，example.github.io；</li>\n<li>创建两个分支：master 与 hexo；</li>\n<li>设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；</li>\n<li><p>拷贝仓库到本地；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone git@github.com:example/example.github.io.git</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在本地 example.github.io 文件夹下通过Git bash(或其他shell)依次执行（此时当前分支应显示为hexo）如下命令;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo</span><br><span class=\"line\">$ hexo init </span><br><span class=\"line\">$ npm install </span><br><span class=\"line\">$ npm install hexo-deployer-git</span><br><span class=\"line\">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>需要注意的是，npm install hexo之后 git branch 查看当前分支为 hexo 分支，hexo init之后，发现找不到分支了，原因如下：<br>git是通过.git 文件来控制管理的，当在远端仓库clone项目时，项目中默认生成了一个.git 文件，然而操作hexo init 的时候，同样生成了一个.git 文件。<br>这样之前生成的.git文件丢失，整个项目就失去版本控制。</p>\n<ol start=\"5\">\n<li>配置hexo 博客</li>\n<li><p>提交项目文件到hexo 分支，依次执行如下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -m “…”</span><br><span class=\"line\">$ git push origin hexo</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>执行hexo generate -d生成网站并部署到GitHub上。</p>\n</li>\n</ol>\n<h2 id=\"日常维护\"><a href=\"#日常维护\" class=\"headerlink\" title=\"日常维护\"></a>日常维护</h2><ol>\n<li><p>依次执行如下指令将改动推送到GitHub（此时当前分支应为hexo）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -m “…”</span><br><span class=\"line\">$ git push origin hexo</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>执行hexo generate -d发布网站到master分支上。</p>\n</li>\n</ol>\n<h2 id=\"更换设备或者本地文件丢失的时候\"><a href=\"#更换设备或者本地文件丢失的时候\" class=\"headerlink\" title=\"更换设备或者本地文件丢失的时候\"></a>更换设备或者本地文件丢失的时候</h2><ol>\n<li><p>拷贝远端仓库（默认分支为hexo）:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone git@github.com:example/example.github.io.git</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在本地新拷贝的example.github.io文件夹下通过Git bash(或其他shell)依次执行下列指令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo</span><br><span class=\"line\">$ npm install</span><br><span class=\"line\">$ npm install hexo-deployer-git</span><br><span class=\"line\">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这里不再需要hexo init这条指令。</p>\n<h2 id=\"Hexo-deploy失败？\"><a href=\"#Hexo-deploy失败？\" class=\"headerlink\" title=\"Hexo deploy失败？\"></a>Hexo deploy失败？</h2><p>简单说，删掉根目录下的文件夹：.deploy_git，重新deploy就可以了。<br>在git提交时，忽略.deploy_git、public文件就好了，其中public是每次hexo g新生成的静态博客文件，不需要同步。<br>修改根目录下的.gitignore文件为：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim .gitignore</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/.deploy_git</span><br><span class=\"line\">/public</span><br></pre></td></tr></table></figure>\n<p>然后 ‘Esc’:wq</p>\n","site":{"data":{}},"excerpt":"<p>如何在不同设备快速、高效的管理自己的博客？<br>","more":"<br>这里采用分支的方法，在一个Github Pages项目上，实现不同终端的管理工作。</p>\n<p>实现原理：<br>在项目上创建一个分支，暂定为hexo分支。<br>master分支和hexo分支互不干扰，当然了，如果你没有操作错误，他们也许永远都不需要 merge</p>\n<ul>\n<li><p>master 分支 存放线上静态站点</p>\n</li>\n<li><p>Hexo 分支 保存项目数据 方便随时随地获取项目 并在本地发布站点 （hexo 分支 是直接发布到master分支上的）。</p>\n</li>\n</ul>\n<h2 id=\"具体操作流程：\"><a href=\"#具体操作流程：\" class=\"headerlink\" title=\"具体操作流程：\"></a>具体操作流程：</h2><ol>\n<li>创建仓库，example.github.io；</li>\n<li>创建两个分支：master 与 hexo；</li>\n<li>设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；</li>\n<li><p>拷贝仓库到本地；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone git@github.com:example/example.github.io.git</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在本地 example.github.io 文件夹下通过Git bash(或其他shell)依次执行（此时当前分支应显示为hexo）如下命令;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo</span><br><span class=\"line\">$ hexo init </span><br><span class=\"line\">$ npm install </span><br><span class=\"line\">$ npm install hexo-deployer-git</span><br><span class=\"line\">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>需要注意的是，npm install hexo之后 git branch 查看当前分支为 hexo 分支，hexo init之后，发现找不到分支了，原因如下：<br>git是通过.git 文件来控制管理的，当在远端仓库clone项目时，项目中默认生成了一个.git 文件，然而操作hexo init 的时候，同样生成了一个.git 文件。<br>这样之前生成的.git文件丢失，整个项目就失去版本控制。</p>\n<ol start=\"5\">\n<li>配置hexo 博客</li>\n<li><p>提交项目文件到hexo 分支，依次执行如下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -m “…”</span><br><span class=\"line\">$ git push origin hexo</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>执行hexo generate -d生成网站并部署到GitHub上。</p>\n</li>\n</ol>\n<h2 id=\"日常维护\"><a href=\"#日常维护\" class=\"headerlink\" title=\"日常维护\"></a>日常维护</h2><ol>\n<li><p>依次执行如下指令将改动推送到GitHub（此时当前分支应为hexo）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -m “…”</span><br><span class=\"line\">$ git push origin hexo</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>执行hexo generate -d发布网站到master分支上。</p>\n</li>\n</ol>\n<h2 id=\"更换设备或者本地文件丢失的时候\"><a href=\"#更换设备或者本地文件丢失的时候\" class=\"headerlink\" title=\"更换设备或者本地文件丢失的时候\"></a>更换设备或者本地文件丢失的时候</h2><ol>\n<li><p>拷贝远端仓库（默认分支为hexo）:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone git@github.com:example/example.github.io.git</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在本地新拷贝的example.github.io文件夹下通过Git bash(或其他shell)依次执行下列指令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo</span><br><span class=\"line\">$ npm install</span><br><span class=\"line\">$ npm install hexo-deployer-git</span><br><span class=\"line\">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这里不再需要hexo init这条指令。</p>\n<h2 id=\"Hexo-deploy失败？\"><a href=\"#Hexo-deploy失败？\" class=\"headerlink\" title=\"Hexo deploy失败？\"></a>Hexo deploy失败？</h2><p>简单说，删掉根目录下的文件夹：.deploy_git，重新deploy就可以了。<br>在git提交时，忽略.deploy_git、public文件就好了，其中public是每次hexo g新生成的静态博客文件，不需要同步。<br>修改根目录下的.gitignore文件为：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim .gitignore</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/.deploy_git</span><br><span class=\"line\">/public</span><br></pre></td></tr></table></figure>\n<p>然后 ‘Esc’:wq</p>"},{"title":"JavaScript ES7 中使用 async/await 解决回调函数嵌套问题","date":"2017-04-07T02:26:30.000Z","_content":"JavaScript 中最蛋疼的事情莫过于回调函数嵌套问题。以往在浏览器中，因为与服务器通讯是一种比较昂贵的操作，因此比较复杂的业务逻辑往往都放在服务器端，前端 JavaScript 只需要少数几次 AJAX 请求就可拿到全部数据。\n<!--more-->\n但是到了 webapp 风行的时代，前端业务逻辑越来越复杂，往往几个 AJAX 请求之间互有依赖，有些请求依赖前面请求的数据，有些请求需要并行进行。还有在类似 node.js 的后端 JavaScript 环境中，因为需要进行大量 IO 操作，问题更加明显。这个时候使用回调函数来组织代码往往会导致代码难以阅读。\n现在比较流行的解决这个问题的方法是使用 Promise，可以将嵌套的回调函数展平。但是写代码和阅读依然有额外的负担。\n另外一个方案是使用 ES6 中新增的 generator，因为 generator 的本质是可以将一个函数执行暂停，并保存上下文，再次调用时恢复当时的状态。co 模块是个不错的封装。但是这样略微有些滥用 generator 特性的感觉。\nES7 中有了更加标准的解决方案，新增了 async/await 两个关键词。async 可以声明一个异步函数，此函数需要返回一个 Promise 对象。await 可以等待一个 Promise 对象 resolve，并拿到结果。\n比如下面的例子，以往我们无法在 JavaScript 中使用常见的 sleep 函数，只能使用 setTimeout 来注册一个回调函数，在指定的时间之后再执行。有了 async/await 之后，我们就可以这样实现了：\n```\njsasync function sleep(timeout) {\n  return new Promise((resolve, reject) => {\n    setTimeout(function() {\n      resolve();\n    }, timeout);\n  });\n}\n\n(async function() {\n  console.log('Do some thing, ' + new Date());\n  await sleep(3000);\n  console.log('Do other things, ' + new Date());\n})();\n```\n执行此段代码，可以在终端中看到结果：\n```\nDo some thing, Mon Feb 23 2015 21:52:11 GMT+0800 (CST)\nDo other things, Mon Feb 23 2015 21:52:14 GMT+0800 (CST)\n```\n另外 async 函数可以正常的返回结果和抛出异常。await 函数调用即可拿到结果，在外面包上 try/catch 就可以捕获异常。下面是一个从豆瓣 API 获取数据的例子：\n```\njsvar fetchDoubanApi = function() {\n  return new Promise((resolve, reject) => {\n    var xhr = new XMLHttpRequest();\n    xhr.onreadystatechange = function() {\n      if (xhr.readyState === 4) {\n        if (xhr.status >= 200 && xhr.status < 300) {\n          var response;\n          try {\n            response = JSON.parse(xhr.responseText);\n          } catch (e) {\n            reject(e);\n          }\n          if (response) {\n            resolve(response, xhr.status, xhr);\n          }\n        } else {\n          reject(xhr);\n        }\n      }\n    };\n    xhr.open('GET', 'https://api.douban.com/v2/user/aisk', true);\n    xhr.setRequestHeader(\"Content-Type\", \"text/plain\");\n    xhr.send(data);\n  });\n};\n\n(async function() {\n  try {\n    let result = await fetchDoubanApi();\n    console.log(result);\n  } catch (e) {\n    console.log(e);\n  }\n})();\n```\n\n","source":"_posts/JavaScript-ES7-中使用-async-await-解决回调函数嵌套问题.md","raw":"---\ntitle: JavaScript ES7 中使用 async/await 解决回调函数嵌套问题\ndate: 2017-04-07 10:26:30\ntags:\n---\nJavaScript 中最蛋疼的事情莫过于回调函数嵌套问题。以往在浏览器中，因为与服务器通讯是一种比较昂贵的操作，因此比较复杂的业务逻辑往往都放在服务器端，前端 JavaScript 只需要少数几次 AJAX 请求就可拿到全部数据。\n<!--more-->\n但是到了 webapp 风行的时代，前端业务逻辑越来越复杂，往往几个 AJAX 请求之间互有依赖，有些请求依赖前面请求的数据，有些请求需要并行进行。还有在类似 node.js 的后端 JavaScript 环境中，因为需要进行大量 IO 操作，问题更加明显。这个时候使用回调函数来组织代码往往会导致代码难以阅读。\n现在比较流行的解决这个问题的方法是使用 Promise，可以将嵌套的回调函数展平。但是写代码和阅读依然有额外的负担。\n另外一个方案是使用 ES6 中新增的 generator，因为 generator 的本质是可以将一个函数执行暂停，并保存上下文，再次调用时恢复当时的状态。co 模块是个不错的封装。但是这样略微有些滥用 generator 特性的感觉。\nES7 中有了更加标准的解决方案，新增了 async/await 两个关键词。async 可以声明一个异步函数，此函数需要返回一个 Promise 对象。await 可以等待一个 Promise 对象 resolve，并拿到结果。\n比如下面的例子，以往我们无法在 JavaScript 中使用常见的 sleep 函数，只能使用 setTimeout 来注册一个回调函数，在指定的时间之后再执行。有了 async/await 之后，我们就可以这样实现了：\n```\njsasync function sleep(timeout) {\n  return new Promise((resolve, reject) => {\n    setTimeout(function() {\n      resolve();\n    }, timeout);\n  });\n}\n\n(async function() {\n  console.log('Do some thing, ' + new Date());\n  await sleep(3000);\n  console.log('Do other things, ' + new Date());\n})();\n```\n执行此段代码，可以在终端中看到结果：\n```\nDo some thing, Mon Feb 23 2015 21:52:11 GMT+0800 (CST)\nDo other things, Mon Feb 23 2015 21:52:14 GMT+0800 (CST)\n```\n另外 async 函数可以正常的返回结果和抛出异常。await 函数调用即可拿到结果，在外面包上 try/catch 就可以捕获异常。下面是一个从豆瓣 API 获取数据的例子：\n```\njsvar fetchDoubanApi = function() {\n  return new Promise((resolve, reject) => {\n    var xhr = new XMLHttpRequest();\n    xhr.onreadystatechange = function() {\n      if (xhr.readyState === 4) {\n        if (xhr.status >= 200 && xhr.status < 300) {\n          var response;\n          try {\n            response = JSON.parse(xhr.responseText);\n          } catch (e) {\n            reject(e);\n          }\n          if (response) {\n            resolve(response, xhr.status, xhr);\n          }\n        } else {\n          reject(xhr);\n        }\n      }\n    };\n    xhr.open('GET', 'https://api.douban.com/v2/user/aisk', true);\n    xhr.setRequestHeader(\"Content-Type\", \"text/plain\");\n    xhr.send(data);\n  });\n};\n\n(async function() {\n  try {\n    let result = await fetchDoubanApi();\n    console.log(result);\n  } catch (e) {\n    console.log(e);\n  }\n})();\n```\n\n","slug":"JavaScript-ES7-中使用-async-await-解决回调函数嵌套问题","published":1,"updated":"2019-03-21T03:42:03.283Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtifjpsx0007lohikki6hnc6","content":"<p>JavaScript 中最蛋疼的事情莫过于回调函数嵌套问题。以往在浏览器中，因为与服务器通讯是一种比较昂贵的操作，因此比较复杂的业务逻辑往往都放在服务器端，前端 JavaScript 只需要少数几次 AJAX 请求就可拿到全部数据。<br><a id=\"more\"></a><br>但是到了 webapp 风行的时代，前端业务逻辑越来越复杂，往往几个 AJAX 请求之间互有依赖，有些请求依赖前面请求的数据，有些请求需要并行进行。还有在类似 node.js 的后端 JavaScript 环境中，因为需要进行大量 IO 操作，问题更加明显。这个时候使用回调函数来组织代码往往会导致代码难以阅读。<br>现在比较流行的解决这个问题的方法是使用 Promise，可以将嵌套的回调函数展平。但是写代码和阅读依然有额外的负担。<br>另外一个方案是使用 ES6 中新增的 generator，因为 generator 的本质是可以将一个函数执行暂停，并保存上下文，再次调用时恢复当时的状态。co 模块是个不错的封装。但是这样略微有些滥用 generator 特性的感觉。<br>ES7 中有了更加标准的解决方案，新增了 async/await 两个关键词。async 可以声明一个异步函数，此函数需要返回一个 Promise 对象。await 可以等待一个 Promise 对象 resolve，并拿到结果。<br>比如下面的例子，以往我们无法在 JavaScript 中使用常见的 sleep 函数，只能使用 setTimeout 来注册一个回调函数，在指定的时间之后再执行。有了 async/await 之后，我们就可以这样实现了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jsasync function sleep(timeout) &#123;</span><br><span class=\"line\">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    setTimeout(function() &#123;</span><br><span class=\"line\">      resolve();</span><br><span class=\"line\">    &#125;, timeout);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">(async function() &#123;</span><br><span class=\"line\">  console.log(&apos;Do some thing, &apos; + new Date());</span><br><span class=\"line\">  await sleep(3000);</span><br><span class=\"line\">  console.log(&apos;Do other things, &apos; + new Date());</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure></p>\n<p>执行此段代码，可以在终端中看到结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Do some thing, Mon Feb 23 2015 21:52:11 GMT+0800 (CST)</span><br><span class=\"line\">Do other things, Mon Feb 23 2015 21:52:14 GMT+0800 (CST)</span><br></pre></td></tr></table></figure></p>\n<p>另外 async 函数可以正常的返回结果和抛出异常。await 函数调用即可拿到结果，在外面包上 try/catch 就可以捕获异常。下面是一个从豆瓣 API 获取数据的例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jsvar fetchDoubanApi = function() &#123;</span><br><span class=\"line\">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    var xhr = new XMLHttpRequest();</span><br><span class=\"line\">    xhr.onreadystatechange = function() &#123;</span><br><span class=\"line\">      if (xhr.readyState === 4) &#123;</span><br><span class=\"line\">        if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123;</span><br><span class=\"line\">          var response;</span><br><span class=\"line\">          try &#123;</span><br><span class=\"line\">            response = JSON.parse(xhr.responseText);</span><br><span class=\"line\">          &#125; catch (e) &#123;</span><br><span class=\"line\">            reject(e);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          if (response) &#123;</span><br><span class=\"line\">            resolve(response, xhr.status, xhr);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          reject(xhr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    xhr.open(&apos;GET&apos;, &apos;https://api.douban.com/v2/user/aisk&apos;, true);</span><br><span class=\"line\">    xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;text/plain&quot;);</span><br><span class=\"line\">    xhr.send(data);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">(async function() &#123;</span><br><span class=\"line\">  try &#123;</span><br><span class=\"line\">    let result = await fetchDoubanApi();</span><br><span class=\"line\">    console.log(result);</span><br><span class=\"line\">  &#125; catch (e) &#123;</span><br><span class=\"line\">    console.log(e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>JavaScript 中最蛋疼的事情莫过于回调函数嵌套问题。以往在浏览器中，因为与服务器通讯是一种比较昂贵的操作，因此比较复杂的业务逻辑往往都放在服务器端，前端 JavaScript 只需要少数几次 AJAX 请求就可拿到全部数据。<br>","more":"<br>但是到了 webapp 风行的时代，前端业务逻辑越来越复杂，往往几个 AJAX 请求之间互有依赖，有些请求依赖前面请求的数据，有些请求需要并行进行。还有在类似 node.js 的后端 JavaScript 环境中，因为需要进行大量 IO 操作，问题更加明显。这个时候使用回调函数来组织代码往往会导致代码难以阅读。<br>现在比较流行的解决这个问题的方法是使用 Promise，可以将嵌套的回调函数展平。但是写代码和阅读依然有额外的负担。<br>另外一个方案是使用 ES6 中新增的 generator，因为 generator 的本质是可以将一个函数执行暂停，并保存上下文，再次调用时恢复当时的状态。co 模块是个不错的封装。但是这样略微有些滥用 generator 特性的感觉。<br>ES7 中有了更加标准的解决方案，新增了 async/await 两个关键词。async 可以声明一个异步函数，此函数需要返回一个 Promise 对象。await 可以等待一个 Promise 对象 resolve，并拿到结果。<br>比如下面的例子，以往我们无法在 JavaScript 中使用常见的 sleep 函数，只能使用 setTimeout 来注册一个回调函数，在指定的时间之后再执行。有了 async/await 之后，我们就可以这样实现了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jsasync function sleep(timeout) &#123;</span><br><span class=\"line\">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    setTimeout(function() &#123;</span><br><span class=\"line\">      resolve();</span><br><span class=\"line\">    &#125;, timeout);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">(async function() &#123;</span><br><span class=\"line\">  console.log(&apos;Do some thing, &apos; + new Date());</span><br><span class=\"line\">  await sleep(3000);</span><br><span class=\"line\">  console.log(&apos;Do other things, &apos; + new Date());</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure></p>\n<p>执行此段代码，可以在终端中看到结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Do some thing, Mon Feb 23 2015 21:52:11 GMT+0800 (CST)</span><br><span class=\"line\">Do other things, Mon Feb 23 2015 21:52:14 GMT+0800 (CST)</span><br></pre></td></tr></table></figure></p>\n<p>另外 async 函数可以正常的返回结果和抛出异常。await 函数调用即可拿到结果，在外面包上 try/catch 就可以捕获异常。下面是一个从豆瓣 API 获取数据的例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jsvar fetchDoubanApi = function() &#123;</span><br><span class=\"line\">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    var xhr = new XMLHttpRequest();</span><br><span class=\"line\">    xhr.onreadystatechange = function() &#123;</span><br><span class=\"line\">      if (xhr.readyState === 4) &#123;</span><br><span class=\"line\">        if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123;</span><br><span class=\"line\">          var response;</span><br><span class=\"line\">          try &#123;</span><br><span class=\"line\">            response = JSON.parse(xhr.responseText);</span><br><span class=\"line\">          &#125; catch (e) &#123;</span><br><span class=\"line\">            reject(e);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          if (response) &#123;</span><br><span class=\"line\">            resolve(response, xhr.status, xhr);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          reject(xhr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    xhr.open(&apos;GET&apos;, &apos;https://api.douban.com/v2/user/aisk&apos;, true);</span><br><span class=\"line\">    xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;text/plain&quot;);</span><br><span class=\"line\">    xhr.send(data);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">(async function() &#123;</span><br><span class=\"line\">  try &#123;</span><br><span class=\"line\">    let result = await fetchDoubanApi();</span><br><span class=\"line\">    console.log(result);</span><br><span class=\"line\">  &#125; catch (e) &#123;</span><br><span class=\"line\">    console.log(e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure></p>"},{"title":"Sublime Text 3建议配置","date":"2016-08-04T06:55:56.000Z","_content":"Sublime Text3 是一款非常优秀的跨平台编辑器，工欲善其事必先利其器，作为一名开发同学，这里简单记录下Sublime Text3的配置。\n<!--more-->\n## 安装\n[Sublime Text3 官网](http://www.sublimetext.com/3)\n\n## 注册\n\n点击菜单： help－Enter License\nlicence key 如下:\n```\n// 如果失效 goooooo。。。\n—– BEGIN LICENSE —–\n\nAnthony Sansone\n\nSingle User License\n\nEA7E-878563\n\n28B9A648 42B99D8A F2E3E9E0 16DE076E\n\nE218B3DC F3606379 C33C1526 E8B58964\n\nB2CB3F63 BDF901BE D31424D2 082891B5\n\nF7058694 55FA46D8 EFC11878 0868F093\n\nB17CAFE7 63A78881 86B78E38 0F146238\n\nBAE22DBB D4EC71A1 0EC2E701 C7F9C648\n\n5CF29CA3 1CB14285 19A46991 E9A98676\n\n14FD4777 2D8A0AB6 A444EE0D CA009B54\n\n—— END LICENSE ——\n```\n\n## 安装 sublime3 Package Control\n按下 ctrl+`\n复制粘贴以下代码\n适用于 Sublime Text 3：\n```\nimport  urllib.request,os;pf='Package Control.sublime-package';ipp=sublime.installed_packages_path();urllib.request.install_opener(urllib.request.build_opener(urllib.request.ProxyHandler()));open(os.path.join(ipp,pf),'wb').write(urllib.request.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read())\n```\n适用于 Sublime Text 2：\n```\nimport  urllib2,os;pf='Package Control.sublime-package';ipp=sublime.installed_packages_path();os.makedirs(ipp)ifnotos.path.exists(ipp)elseNone;urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler()));open(os.path.join(ipp,pf),'wb').write(urllib2.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read());print('Please restart Sublime Text to finish installation')\n```\n## 安装sublime3插件\n按下 ctrl+shift+p，输入'ip'（Install Package）\n输入以下插件的名字，按顺序逐个进行安装：\n* Emmet                               撸HTML、CSS必备的\n* Color Highlighter&&Color Picker     这两个插件需要同时安装，然后就能显示十六进制的颜色的。但颜色这块没有webstorm的赞。\n* Prettify                            HTML、CSS、JS、JSON..... Ctrl+Shift+H 一键就能格式化了\n* ConvertToUTF8\n* EditorConfig\n* Sass\n* SublimeLinter\n* SublimeLinter-jscs\n* SublimeLinter-jshint\n* SublimeLinter-csslint\n* SublimeLinter-contrib-scss-lint\n* JSFormat\n* CSScomb\n*\n*\n*\n\n## 分屏\n```\nAlt+Shift+1/2/3/4/5/8/9\n```\n\n## 插件的配置文件\n将以下配置文件分别下载后放入项目根目录下：\nEditorConfig [配置文件](http://alloyteam.github.io/CodeGuide/.editorconfig)\nJSCS [配置文件](http://alloyteam.github.io/CodeGuide/.jscsrc)\nJSHint [配置文件](http://alloyteam.github.io/CodeGuide/.jshintrc)\n注意：全局变量需要手动加到配置文件的globals属性里，例：\n```\n{\n    \"globals\": {\n        \"ImageHandle\": true\n    }\n}\n```\nCSSLint [配置文件](http://alloyteam.github.io/CodeGuide/.csslintrc)\nSCSS-Lint [配置文件](http://alloyteam.github.io/CodeGuide/.scss-lint.yml)\n\n## 编辑器及插件设置\n* sublime3 自身\nPreferences->Setting-User，增加下面两个配置：\n```\n{\n    \"translate_tabs_to_spaces\": true,\n    \"word_wrap\": true\n}\n```\n点击右下角的Spaces->Convert Indentation to Spaces可以将文件中的所有tab转换成空格\n\n* JSFormat\n```\nPreferences->Package Settings->JSFormat->Setting-User，[下载配置文件](http://alloyteam.github.io/CodeGuide/jsformat_setting_user.json)覆盖\n```\n配置好后格式化的默认快捷键是 ctrl+alt+f\n\n* SublimeLinter\n右键->SublimeLinter->Lint Mode，有4种检查模式，建议选择 Load/save\n右键->SublimeLinter->Mark Style，建议选择 Outline\n右键->SublimeLinter->Choose Gutter Theme，建议选择 Blueberry-round\n右键->SublimeLinter->Open User Settings，将linter里面jscs的args改成 [\"--verbose\"]，将linter里面csslint的ignore改成\n```\"box-model,adjoining-classes,box-sizing,compatible-vendor-prefixes,gradients,text-indent,fallback-colors,star-property-hack,underscore-property-hack,bulletproof-font-face,font-faces,import,regex-selectors,universal-selector,unqualified-attributes,overqualified-elements,duplicate-background-images,floats,font-sizes,ids,important,outline-none,qualified-headings,unique-headings\"\n```\n当光标处于有错误的代码行时，详细的错误信息会显示在下面的状态栏中\n右键->SublimeLinter可以看到所有的快捷键，其中 ctrl+k, a 可以列出所有错误\n\n* CSScomb\nPreferences->Package Settings->CSScomb->Setting-User，[下载配置文件](http://alloyteam.github.io/CodeGuide/csscomb_setting_user.json)覆盖\n配置好后格式化的默认快捷键是 ctrl+shift+c\n","source":"_posts/Sublime Text 3建议配置.md","raw":"---\ntitle: Sublime Text 3建议配置\ndate: 2016-08-04 14:55:56\ntags: Sublime\ncategory: 编辑器\n---\nSublime Text3 是一款非常优秀的跨平台编辑器，工欲善其事必先利其器，作为一名开发同学，这里简单记录下Sublime Text3的配置。\n<!--more-->\n## 安装\n[Sublime Text3 官网](http://www.sublimetext.com/3)\n\n## 注册\n\n点击菜单： help－Enter License\nlicence key 如下:\n```\n// 如果失效 goooooo。。。\n—– BEGIN LICENSE —–\n\nAnthony Sansone\n\nSingle User License\n\nEA7E-878563\n\n28B9A648 42B99D8A F2E3E9E0 16DE076E\n\nE218B3DC F3606379 C33C1526 E8B58964\n\nB2CB3F63 BDF901BE D31424D2 082891B5\n\nF7058694 55FA46D8 EFC11878 0868F093\n\nB17CAFE7 63A78881 86B78E38 0F146238\n\nBAE22DBB D4EC71A1 0EC2E701 C7F9C648\n\n5CF29CA3 1CB14285 19A46991 E9A98676\n\n14FD4777 2D8A0AB6 A444EE0D CA009B54\n\n—— END LICENSE ——\n```\n\n## 安装 sublime3 Package Control\n按下 ctrl+`\n复制粘贴以下代码\n适用于 Sublime Text 3：\n```\nimport  urllib.request,os;pf='Package Control.sublime-package';ipp=sublime.installed_packages_path();urllib.request.install_opener(urllib.request.build_opener(urllib.request.ProxyHandler()));open(os.path.join(ipp,pf),'wb').write(urllib.request.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read())\n```\n适用于 Sublime Text 2：\n```\nimport  urllib2,os;pf='Package Control.sublime-package';ipp=sublime.installed_packages_path();os.makedirs(ipp)ifnotos.path.exists(ipp)elseNone;urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler()));open(os.path.join(ipp,pf),'wb').write(urllib2.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read());print('Please restart Sublime Text to finish installation')\n```\n## 安装sublime3插件\n按下 ctrl+shift+p，输入'ip'（Install Package）\n输入以下插件的名字，按顺序逐个进行安装：\n* Emmet                               撸HTML、CSS必备的\n* Color Highlighter&&Color Picker     这两个插件需要同时安装，然后就能显示十六进制的颜色的。但颜色这块没有webstorm的赞。\n* Prettify                            HTML、CSS、JS、JSON..... Ctrl+Shift+H 一键就能格式化了\n* ConvertToUTF8\n* EditorConfig\n* Sass\n* SublimeLinter\n* SublimeLinter-jscs\n* SublimeLinter-jshint\n* SublimeLinter-csslint\n* SublimeLinter-contrib-scss-lint\n* JSFormat\n* CSScomb\n*\n*\n*\n\n## 分屏\n```\nAlt+Shift+1/2/3/4/5/8/9\n```\n\n## 插件的配置文件\n将以下配置文件分别下载后放入项目根目录下：\nEditorConfig [配置文件](http://alloyteam.github.io/CodeGuide/.editorconfig)\nJSCS [配置文件](http://alloyteam.github.io/CodeGuide/.jscsrc)\nJSHint [配置文件](http://alloyteam.github.io/CodeGuide/.jshintrc)\n注意：全局变量需要手动加到配置文件的globals属性里，例：\n```\n{\n    \"globals\": {\n        \"ImageHandle\": true\n    }\n}\n```\nCSSLint [配置文件](http://alloyteam.github.io/CodeGuide/.csslintrc)\nSCSS-Lint [配置文件](http://alloyteam.github.io/CodeGuide/.scss-lint.yml)\n\n## 编辑器及插件设置\n* sublime3 自身\nPreferences->Setting-User，增加下面两个配置：\n```\n{\n    \"translate_tabs_to_spaces\": true,\n    \"word_wrap\": true\n}\n```\n点击右下角的Spaces->Convert Indentation to Spaces可以将文件中的所有tab转换成空格\n\n* JSFormat\n```\nPreferences->Package Settings->JSFormat->Setting-User，[下载配置文件](http://alloyteam.github.io/CodeGuide/jsformat_setting_user.json)覆盖\n```\n配置好后格式化的默认快捷键是 ctrl+alt+f\n\n* SublimeLinter\n右键->SublimeLinter->Lint Mode，有4种检查模式，建议选择 Load/save\n右键->SublimeLinter->Mark Style，建议选择 Outline\n右键->SublimeLinter->Choose Gutter Theme，建议选择 Blueberry-round\n右键->SublimeLinter->Open User Settings，将linter里面jscs的args改成 [\"--verbose\"]，将linter里面csslint的ignore改成\n```\"box-model,adjoining-classes,box-sizing,compatible-vendor-prefixes,gradients,text-indent,fallback-colors,star-property-hack,underscore-property-hack,bulletproof-font-face,font-faces,import,regex-selectors,universal-selector,unqualified-attributes,overqualified-elements,duplicate-background-images,floats,font-sizes,ids,important,outline-none,qualified-headings,unique-headings\"\n```\n当光标处于有错误的代码行时，详细的错误信息会显示在下面的状态栏中\n右键->SublimeLinter可以看到所有的快捷键，其中 ctrl+k, a 可以列出所有错误\n\n* CSScomb\nPreferences->Package Settings->CSScomb->Setting-User，[下载配置文件](http://alloyteam.github.io/CodeGuide/csscomb_setting_user.json)覆盖\n配置好后格式化的默认快捷键是 ctrl+shift+c\n","slug":"Sublime Text 3建议配置","published":1,"updated":"2019-03-21T03:42:03.283Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtifjpsz0008lohi9ootrfum","content":"<p>Sublime Text3 是一款非常优秀的跨平台编辑器，工欲善其事必先利其器，作为一名开发同学，这里简单记录下Sublime Text3的配置。<br><a id=\"more\"></a></p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p><a href=\"http://www.sublimetext.com/3\" target=\"_blank\" rel=\"noopener\">Sublime Text3 官网</a></p>\n<h2 id=\"注册\"><a href=\"#注册\" class=\"headerlink\" title=\"注册\"></a>注册</h2><p>点击菜单： help－Enter License<br>licence key 如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 如果失效 goooooo。。。</span><br><span class=\"line\">—– BEGIN LICENSE —–</span><br><span class=\"line\"></span><br><span class=\"line\">Anthony Sansone</span><br><span class=\"line\"></span><br><span class=\"line\">Single User License</span><br><span class=\"line\"></span><br><span class=\"line\">EA7E-878563</span><br><span class=\"line\"></span><br><span class=\"line\">28B9A648 42B99D8A F2E3E9E0 16DE076E</span><br><span class=\"line\"></span><br><span class=\"line\">E218B3DC F3606379 C33C1526 E8B58964</span><br><span class=\"line\"></span><br><span class=\"line\">B2CB3F63 BDF901BE D31424D2 082891B5</span><br><span class=\"line\"></span><br><span class=\"line\">F7058694 55FA46D8 EFC11878 0868F093</span><br><span class=\"line\"></span><br><span class=\"line\">B17CAFE7 63A78881 86B78E38 0F146238</span><br><span class=\"line\"></span><br><span class=\"line\">BAE22DBB D4EC71A1 0EC2E701 C7F9C648</span><br><span class=\"line\"></span><br><span class=\"line\">5CF29CA3 1CB14285 19A46991 E9A98676</span><br><span class=\"line\"></span><br><span class=\"line\">14FD4777 2D8A0AB6 A444EE0D CA009B54</span><br><span class=\"line\"></span><br><span class=\"line\">—— END LICENSE ——</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"安装-sublime3-Package-Control\"><a href=\"#安装-sublime3-Package-Control\" class=\"headerlink\" title=\"安装 sublime3 Package Control\"></a>安装 sublime3 Package Control</h2><p>按下 ctrl+`<br>复制粘贴以下代码<br>适用于 Sublime Text 3：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import  urllib.request,os;pf=&apos;Package Control.sublime-package&apos;;ipp=sublime.installed_packages_path();urllib.request.install_opener(urllib.request.build_opener(urllib.request.ProxyHandler()));open(os.path.join(ipp,pf),&apos;wb&apos;).write(urllib.request.urlopen(&apos;http://sublime.wbond.net/&apos;+pf.replace(&apos; &apos;,&apos;%20&apos;)).read())</span><br></pre></td></tr></table></figure></p>\n<p>适用于 Sublime Text 2：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import  urllib2,os;pf=&apos;Package Control.sublime-package&apos;;ipp=sublime.installed_packages_path();os.makedirs(ipp)ifnotos.path.exists(ipp)elseNone;urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler()));open(os.path.join(ipp,pf),&apos;wb&apos;).write(urllib2.urlopen(&apos;http://sublime.wbond.net/&apos;+pf.replace(&apos; &apos;,&apos;%20&apos;)).read());print(&apos;Please restart Sublime Text to finish installation&apos;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"安装sublime3插件\"><a href=\"#安装sublime3插件\" class=\"headerlink\" title=\"安装sublime3插件\"></a>安装sublime3插件</h2><p>按下 ctrl+shift+p，输入’ip’（Install Package）<br>输入以下插件的名字，按顺序逐个进行安装：</p>\n<ul>\n<li>Emmet                               撸HTML、CSS必备的</li>\n<li>Color Highlighter&amp;&amp;Color Picker     这两个插件需要同时安装，然后就能显示十六进制的颜色的。但颜色这块没有webstorm的赞。</li>\n<li>Prettify                            HTML、CSS、JS、JSON….. Ctrl+Shift+H 一键就能格式化了</li>\n<li>ConvertToUTF8</li>\n<li>EditorConfig</li>\n<li>Sass</li>\n<li>SublimeLinter</li>\n<li>SublimeLinter-jscs</li>\n<li>SublimeLinter-jshint</li>\n<li>SublimeLinter-csslint</li>\n<li>SublimeLinter-contrib-scss-lint</li>\n<li>JSFormat</li>\n<li>CSScomb<br><em>\n</em><br>*</li>\n</ul>\n<h2 id=\"分屏\"><a href=\"#分屏\" class=\"headerlink\" title=\"分屏\"></a>分屏</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Alt+Shift+1/2/3/4/5/8/9</span><br></pre></td></tr></table></figure>\n<h2 id=\"插件的配置文件\"><a href=\"#插件的配置文件\" class=\"headerlink\" title=\"插件的配置文件\"></a>插件的配置文件</h2><p>将以下配置文件分别下载后放入项目根目录下：<br>EditorConfig <a href=\"http://alloyteam.github.io/CodeGuide/.editorconfig\" target=\"_blank\" rel=\"noopener\">配置文件</a><br>JSCS <a href=\"http://alloyteam.github.io/CodeGuide/.jscsrc\" target=\"_blank\" rel=\"noopener\">配置文件</a><br>JSHint <a href=\"http://alloyteam.github.io/CodeGuide/.jshintrc\" target=\"_blank\" rel=\"noopener\">配置文件</a><br>注意：全局变量需要手动加到配置文件的globals属性里，例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;globals&quot;: &#123;</span><br><span class=\"line\">        &quot;ImageHandle&quot;: true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>CSSLint <a href=\"http://alloyteam.github.io/CodeGuide/.csslintrc\" target=\"_blank\" rel=\"noopener\">配置文件</a><br>SCSS-Lint <a href=\"http://alloyteam.github.io/CodeGuide/.scss-lint.yml\" target=\"_blank\" rel=\"noopener\">配置文件</a></p>\n<h2 id=\"编辑器及插件设置\"><a href=\"#编辑器及插件设置\" class=\"headerlink\" title=\"编辑器及插件设置\"></a>编辑器及插件设置</h2><ul>\n<li>sublime3 自身<br>Preferences-&gt;Setting-User，增加下面两个配置：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;translate_tabs_to_spaces&quot;: true,</span><br><span class=\"line\">    &quot;word_wrap&quot;: true</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>点击右下角的Spaces-&gt;Convert Indentation to Spaces可以将文件中的所有tab转换成空格</p>\n<ul>\n<li>JSFormat<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Preferences-&gt;Package Settings-&gt;JSFormat-&gt;Setting-User，[下载配置文件](http://alloyteam.github.io/CodeGuide/jsformat_setting_user.json)覆盖</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>配置好后格式化的默认快捷键是 ctrl+alt+f</p>\n<ul>\n<li><p>SublimeLinter<br>右键-&gt;SublimeLinter-&gt;Lint Mode，有4种检查模式，建议选择 Load/save<br>右键-&gt;SublimeLinter-&gt;Mark Style，建议选择 Outline<br>右键-&gt;SublimeLinter-&gt;Choose Gutter Theme，建议选择 Blueberry-round<br>右键-&gt;SublimeLinter-&gt;Open User Settings，将linter里面jscs的args改成 [“–verbose”]，将linter里面csslint的ignore改成</p>\n<pre><code class=\"&quot;box-model,adjoining-classes,box-sizing,compatible-vendor-prefixes,gradients,text-indent,fallback-colors,star-property-hack,underscore-property-hack,bulletproof-font-face,font-faces,import,regex-selectors,universal-selector,unqualified-attributes,overqualified-elements,duplicate-background-images,floats,font-sizes,ids,important,outline-none,qualified-headings,unique-headings&quot;\">\n</code></pre>\n<p>当光标处于有错误的代码行时，详细的错误信息会显示在下面的状态栏中<br>右键-&gt;SublimeLinter可以看到所有的快捷键，其中 ctrl+k, a 可以列出所有错误</p>\n</li>\n<li><p>CSScomb<br>Preferences-&gt;Package Settings-&gt;CSScomb-&gt;Setting-User，<a href=\"http://alloyteam.github.io/CodeGuide/csscomb_setting_user.json\" target=\"_blank\" rel=\"noopener\">下载配置文件</a>覆盖<br>配置好后格式化的默认快捷键是 ctrl+shift+c</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>Sublime Text3 是一款非常优秀的跨平台编辑器，工欲善其事必先利其器，作为一名开发同学，这里简单记录下Sublime Text3的配置。<br>","more":"</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p><a href=\"http://www.sublimetext.com/3\" target=\"_blank\" rel=\"noopener\">Sublime Text3 官网</a></p>\n<h2 id=\"注册\"><a href=\"#注册\" class=\"headerlink\" title=\"注册\"></a>注册</h2><p>点击菜单： help－Enter License<br>licence key 如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 如果失效 goooooo。。。</span><br><span class=\"line\">—– BEGIN LICENSE —–</span><br><span class=\"line\"></span><br><span class=\"line\">Anthony Sansone</span><br><span class=\"line\"></span><br><span class=\"line\">Single User License</span><br><span class=\"line\"></span><br><span class=\"line\">EA7E-878563</span><br><span class=\"line\"></span><br><span class=\"line\">28B9A648 42B99D8A F2E3E9E0 16DE076E</span><br><span class=\"line\"></span><br><span class=\"line\">E218B3DC F3606379 C33C1526 E8B58964</span><br><span class=\"line\"></span><br><span class=\"line\">B2CB3F63 BDF901BE D31424D2 082891B5</span><br><span class=\"line\"></span><br><span class=\"line\">F7058694 55FA46D8 EFC11878 0868F093</span><br><span class=\"line\"></span><br><span class=\"line\">B17CAFE7 63A78881 86B78E38 0F146238</span><br><span class=\"line\"></span><br><span class=\"line\">BAE22DBB D4EC71A1 0EC2E701 C7F9C648</span><br><span class=\"line\"></span><br><span class=\"line\">5CF29CA3 1CB14285 19A46991 E9A98676</span><br><span class=\"line\"></span><br><span class=\"line\">14FD4777 2D8A0AB6 A444EE0D CA009B54</span><br><span class=\"line\"></span><br><span class=\"line\">—— END LICENSE ——</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"安装-sublime3-Package-Control\"><a href=\"#安装-sublime3-Package-Control\" class=\"headerlink\" title=\"安装 sublime3 Package Control\"></a>安装 sublime3 Package Control</h2><p>按下 ctrl+`<br>复制粘贴以下代码<br>适用于 Sublime Text 3：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import  urllib.request,os;pf=&apos;Package Control.sublime-package&apos;;ipp=sublime.installed_packages_path();urllib.request.install_opener(urllib.request.build_opener(urllib.request.ProxyHandler()));open(os.path.join(ipp,pf),&apos;wb&apos;).write(urllib.request.urlopen(&apos;http://sublime.wbond.net/&apos;+pf.replace(&apos; &apos;,&apos;%20&apos;)).read())</span><br></pre></td></tr></table></figure></p>\n<p>适用于 Sublime Text 2：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import  urllib2,os;pf=&apos;Package Control.sublime-package&apos;;ipp=sublime.installed_packages_path();os.makedirs(ipp)ifnotos.path.exists(ipp)elseNone;urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler()));open(os.path.join(ipp,pf),&apos;wb&apos;).write(urllib2.urlopen(&apos;http://sublime.wbond.net/&apos;+pf.replace(&apos; &apos;,&apos;%20&apos;)).read());print(&apos;Please restart Sublime Text to finish installation&apos;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"安装sublime3插件\"><a href=\"#安装sublime3插件\" class=\"headerlink\" title=\"安装sublime3插件\"></a>安装sublime3插件</h2><p>按下 ctrl+shift+p，输入’ip’（Install Package）<br>输入以下插件的名字，按顺序逐个进行安装：</p>\n<ul>\n<li>Emmet                               撸HTML、CSS必备的</li>\n<li>Color Highlighter&amp;&amp;Color Picker     这两个插件需要同时安装，然后就能显示十六进制的颜色的。但颜色这块没有webstorm的赞。</li>\n<li>Prettify                            HTML、CSS、JS、JSON….. Ctrl+Shift+H 一键就能格式化了</li>\n<li>ConvertToUTF8</li>\n<li>EditorConfig</li>\n<li>Sass</li>\n<li>SublimeLinter</li>\n<li>SublimeLinter-jscs</li>\n<li>SublimeLinter-jshint</li>\n<li>SublimeLinter-csslint</li>\n<li>SublimeLinter-contrib-scss-lint</li>\n<li>JSFormat</li>\n<li>CSScomb<br><em>\n</em><br>*</li>\n</ul>\n<h2 id=\"分屏\"><a href=\"#分屏\" class=\"headerlink\" title=\"分屏\"></a>分屏</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Alt+Shift+1/2/3/4/5/8/9</span><br></pre></td></tr></table></figure>\n<h2 id=\"插件的配置文件\"><a href=\"#插件的配置文件\" class=\"headerlink\" title=\"插件的配置文件\"></a>插件的配置文件</h2><p>将以下配置文件分别下载后放入项目根目录下：<br>EditorConfig <a href=\"http://alloyteam.github.io/CodeGuide/.editorconfig\" target=\"_blank\" rel=\"noopener\">配置文件</a><br>JSCS <a href=\"http://alloyteam.github.io/CodeGuide/.jscsrc\" target=\"_blank\" rel=\"noopener\">配置文件</a><br>JSHint <a href=\"http://alloyteam.github.io/CodeGuide/.jshintrc\" target=\"_blank\" rel=\"noopener\">配置文件</a><br>注意：全局变量需要手动加到配置文件的globals属性里，例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;globals&quot;: &#123;</span><br><span class=\"line\">        &quot;ImageHandle&quot;: true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>CSSLint <a href=\"http://alloyteam.github.io/CodeGuide/.csslintrc\" target=\"_blank\" rel=\"noopener\">配置文件</a><br>SCSS-Lint <a href=\"http://alloyteam.github.io/CodeGuide/.scss-lint.yml\" target=\"_blank\" rel=\"noopener\">配置文件</a></p>\n<h2 id=\"编辑器及插件设置\"><a href=\"#编辑器及插件设置\" class=\"headerlink\" title=\"编辑器及插件设置\"></a>编辑器及插件设置</h2><ul>\n<li>sublime3 自身<br>Preferences-&gt;Setting-User，增加下面两个配置：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;translate_tabs_to_spaces&quot;: true,</span><br><span class=\"line\">    &quot;word_wrap&quot;: true</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>点击右下角的Spaces-&gt;Convert Indentation to Spaces可以将文件中的所有tab转换成空格</p>\n<ul>\n<li>JSFormat<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Preferences-&gt;Package Settings-&gt;JSFormat-&gt;Setting-User，[下载配置文件](http://alloyteam.github.io/CodeGuide/jsformat_setting_user.json)覆盖</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>配置好后格式化的默认快捷键是 ctrl+alt+f</p>\n<ul>\n<li><p>SublimeLinter<br>右键-&gt;SublimeLinter-&gt;Lint Mode，有4种检查模式，建议选择 Load/save<br>右键-&gt;SublimeLinter-&gt;Mark Style，建议选择 Outline<br>右键-&gt;SublimeLinter-&gt;Choose Gutter Theme，建议选择 Blueberry-round<br>右键-&gt;SublimeLinter-&gt;Open User Settings，将linter里面jscs的args改成 [“–verbose”]，将linter里面csslint的ignore改成</p>\n<pre><code class=\"&quot;box-model,adjoining-classes,box-sizing,compatible-vendor-prefixes,gradients,text-indent,fallback-colors,star-property-hack,underscore-property-hack,bulletproof-font-face,font-faces,import,regex-selectors,universal-selector,unqualified-attributes,overqualified-elements,duplicate-background-images,floats,font-sizes,ids,important,outline-none,qualified-headings,unique-headings&quot;\">\n</code></pre>\n<p>当光标处于有错误的代码行时，详细的错误信息会显示在下面的状态栏中<br>右键-&gt;SublimeLinter可以看到所有的快捷键，其中 ctrl+k, a 可以列出所有错误</p>\n</li>\n<li><p>CSScomb<br>Preferences-&gt;Package Settings-&gt;CSScomb-&gt;Setting-User，<a href=\"http://alloyteam.github.io/CodeGuide/csscomb_setting_user.json\" target=\"_blank\" rel=\"noopener\">下载配置文件</a>覆盖<br>配置好后格式化的默认快捷键是 ctrl+shift+c</p>\n</li>\n</ul>"},{"title":"发布自己模块到NPM","date":"2017-08-10T01:09:18.000Z","_content":"把自己写的 node.js 模块发布到 npm 开源社区。\n<!--more-->\n\n### 准备工作\nnode环境，[npm官网](https://www.npmjs.com/) 账号。\n### 创建项目\n```\n$ npm init\n```\n一路Enter\n```\n{\n  \"name\": \"npm-name\",\n  \"version\": \"1.0.1\",\n  \"description\": \"desc...\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/cherislive/snb.git\"\n  },\n  \"keywords\": [\n    \"keywords\"\n  ],\n  \"author\": \"cheris\",\n  \"license\": \"ISC\",\n  \"bugs\": {\n    \"url\": \"https://github.com/cherislive/snb/issues\"\n  },\n  \"homepage\": \"https://github.com/cherislive/snb#readme\"\n}\n\n```\n* **name**:  模块名，之后发布之后就可以让用户npm install xxxx来引用你的开源模块了。\n* **version**:  版本号，语义版本号分为 **X.Y.Z** 三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。\n-  如果只是修复bug，需要更新**Z**位。\n- 如果是新增了功能，但是向下兼容，需要更新**Y**位。\n- 如果有大变动，向下不兼容，需要更新**X**位。\n* **description**:  简单介绍自己的模块。\n* **main**:  入口文件，必要，当通过require('xxx')时，是读取main里声明的文件。\n* **test command**:  测试命令。\n* **git repository**:  git仓库地址。\n* **keywords**:  关键词，可以通过npm搜索你填写的关键词找到你的模块。\n* **author**:  作者信息，可以之后编辑更详细一些。\n* **license**:  代码授权许可。\n\n### 编写代码\n这里需要考虑不同的引入方式（import | require | src）。\n```\n;(function (root, factory) {\n  if (typeof exports === 'object' && typeof module !== 'undefined') {\n    module.exports = factory()\n  } else if (typeof define === 'function' && define.amd) {\n    define([], factory)\n  } else if (typeof exports === 'object') {\n    exports['snb'] = factory()\n  } else {\n    global['snb'] = factory()\n  }\n})(this, function () {\n  class snb {\n    ...\n    }\n  return snb\n})\n```\n\n### 发布模块\n1、 在npm  [注册用户](https://www.npmjs.com/signup)。\n2、 在本地登录自己的npm账号 `$ npm login` 。\n3、发布模块。\n```\n$ npm publish\n+ snb@1.0.2 // 返回本条信息就是发布成功了\n```\n4、撤销发布自己发布过的某个版本代码。\n```\n$ npm unpublish <package>@<version>\n```\n5、 其他命令\n```\n// 更新模块至最新版\n$ npm update <package>\n\n// 可以清空NPM本地缓存（使用了相同版本号发布新版本的情况）。\n$ npm cache clear\n```\n\n还可以给自己的模块的来个图片徽章，可以放在github仓库的README.md里可以让访问到这项目的人看到项目的状态\nhttp://shields.io/\nhttps://nodei.co/\n\n\n<center>\n[![Version](https://img.shields.io/npm/v/snb.svg)](https://www.npmjs.com/package/snb)  [![Download](https://img.shields.io/npm/dm/snb.svg)](https://www.npmjs.com/package/snb)  [![GitHub forks](https://img.shields.io/github/forks/cherislive/snb.svg)](https://github.com/cherislive/snb/network)  [![GitHub stars](https://img.shields.io/github/stars/cherislive/snb.svg)](https://github.com/cherislive/snb/stargazers)</center>\n<center>\n[![NPM](https://nodei.co/npm/snb.png?downloads=true&downloadRank=true&stars=true)](https://nodei.co/npm/snb/)\n</center>\n","source":"_posts/发布自己模块到NPM.md","raw":"---\ntitle: 发布自己模块到NPM\ndate: 2017-08-10 09:09:18\ntags:\n---\n把自己写的 node.js 模块发布到 npm 开源社区。\n<!--more-->\n\n### 准备工作\nnode环境，[npm官网](https://www.npmjs.com/) 账号。\n### 创建项目\n```\n$ npm init\n```\n一路Enter\n```\n{\n  \"name\": \"npm-name\",\n  \"version\": \"1.0.1\",\n  \"description\": \"desc...\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/cherislive/snb.git\"\n  },\n  \"keywords\": [\n    \"keywords\"\n  ],\n  \"author\": \"cheris\",\n  \"license\": \"ISC\",\n  \"bugs\": {\n    \"url\": \"https://github.com/cherislive/snb/issues\"\n  },\n  \"homepage\": \"https://github.com/cherislive/snb#readme\"\n}\n\n```\n* **name**:  模块名，之后发布之后就可以让用户npm install xxxx来引用你的开源模块了。\n* **version**:  版本号，语义版本号分为 **X.Y.Z** 三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。\n-  如果只是修复bug，需要更新**Z**位。\n- 如果是新增了功能，但是向下兼容，需要更新**Y**位。\n- 如果有大变动，向下不兼容，需要更新**X**位。\n* **description**:  简单介绍自己的模块。\n* **main**:  入口文件，必要，当通过require('xxx')时，是读取main里声明的文件。\n* **test command**:  测试命令。\n* **git repository**:  git仓库地址。\n* **keywords**:  关键词，可以通过npm搜索你填写的关键词找到你的模块。\n* **author**:  作者信息，可以之后编辑更详细一些。\n* **license**:  代码授权许可。\n\n### 编写代码\n这里需要考虑不同的引入方式（import | require | src）。\n```\n;(function (root, factory) {\n  if (typeof exports === 'object' && typeof module !== 'undefined') {\n    module.exports = factory()\n  } else if (typeof define === 'function' && define.amd) {\n    define([], factory)\n  } else if (typeof exports === 'object') {\n    exports['snb'] = factory()\n  } else {\n    global['snb'] = factory()\n  }\n})(this, function () {\n  class snb {\n    ...\n    }\n  return snb\n})\n```\n\n### 发布模块\n1、 在npm  [注册用户](https://www.npmjs.com/signup)。\n2、 在本地登录自己的npm账号 `$ npm login` 。\n3、发布模块。\n```\n$ npm publish\n+ snb@1.0.2 // 返回本条信息就是发布成功了\n```\n4、撤销发布自己发布过的某个版本代码。\n```\n$ npm unpublish <package>@<version>\n```\n5、 其他命令\n```\n// 更新模块至最新版\n$ npm update <package>\n\n// 可以清空NPM本地缓存（使用了相同版本号发布新版本的情况）。\n$ npm cache clear\n```\n\n还可以给自己的模块的来个图片徽章，可以放在github仓库的README.md里可以让访问到这项目的人看到项目的状态\nhttp://shields.io/\nhttps://nodei.co/\n\n\n<center>\n[![Version](https://img.shields.io/npm/v/snb.svg)](https://www.npmjs.com/package/snb)  [![Download](https://img.shields.io/npm/dm/snb.svg)](https://www.npmjs.com/package/snb)  [![GitHub forks](https://img.shields.io/github/forks/cherislive/snb.svg)](https://github.com/cherislive/snb/network)  [![GitHub stars](https://img.shields.io/github/stars/cherislive/snb.svg)](https://github.com/cherislive/snb/stargazers)</center>\n<center>\n[![NPM](https://nodei.co/npm/snb.png?downloads=true&downloadRank=true&stars=true)](https://nodei.co/npm/snb/)\n</center>\n","slug":"发布自己模块到NPM","published":1,"updated":"2019-03-21T03:42:03.284Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtifjpt1000clohirag72sm1","content":"<p>把自己写的 node.js 模块发布到 npm 开源社区。<br><a id=\"more\"></a></p>\n<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p>node环境，<a href=\"https://www.npmjs.com/\" target=\"_blank\" rel=\"noopener\">npm官网</a> 账号。</p>\n<h3 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm init</span><br></pre></td></tr></table></figure>\n<p>一路Enter<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;: &quot;npm-name&quot;,</span><br><span class=\"line\">  &quot;version&quot;: &quot;1.0.1&quot;,</span><br><span class=\"line\">  &quot;description&quot;: &quot;desc...&quot;,</span><br><span class=\"line\">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class=\"line\">  &quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;repository&quot;: &#123;</span><br><span class=\"line\">    &quot;type&quot;: &quot;git&quot;,</span><br><span class=\"line\">    &quot;url&quot;: &quot;git+https://github.com/cherislive/snb.git&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;keywords&quot;: [</span><br><span class=\"line\">    &quot;keywords&quot;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;author&quot;: &quot;cheris&quot;,</span><br><span class=\"line\">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class=\"line\">  &quot;bugs&quot;: &#123;</span><br><span class=\"line\">    &quot;url&quot;: &quot;https://github.com/cherislive/snb/issues&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;homepage&quot;: &quot;https://github.com/cherislive/snb#readme&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>name</strong>:  模块名，之后发布之后就可以让用户npm install xxxx来引用你的开源模块了。</li>\n<li><strong>version</strong>:  版本号，语义版本号分为 <strong>X.Y.Z</strong> 三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。</li>\n</ul>\n<ul>\n<li>如果只是修复bug，需要更新<strong>Z</strong>位。</li>\n<li>如果是新增了功能，但是向下兼容，需要更新<strong>Y</strong>位。</li>\n<li>如果有大变动，向下不兼容，需要更新<strong>X</strong>位。</li>\n</ul>\n<ul>\n<li><strong>description</strong>:  简单介绍自己的模块。</li>\n<li><strong>main</strong>:  入口文件，必要，当通过require(‘xxx’)时，是读取main里声明的文件。</li>\n<li><strong>test command</strong>:  测试命令。</li>\n<li><strong>git repository</strong>:  git仓库地址。</li>\n<li><strong>keywords</strong>:  关键词，可以通过npm搜索你填写的关键词找到你的模块。</li>\n<li><strong>author</strong>:  作者信息，可以之后编辑更详细一些。</li>\n<li><strong>license</strong>:  代码授权许可。</li>\n</ul>\n<h3 id=\"编写代码\"><a href=\"#编写代码\" class=\"headerlink\" title=\"编写代码\"></a>编写代码</h3><p>这里需要考虑不同的引入方式（import | require | src）。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;(function (root, factory) &#123;</span><br><span class=\"line\">  if (typeof exports === &apos;object&apos; &amp;&amp; typeof module !== &apos;undefined&apos;) &#123;</span><br><span class=\"line\">    module.exports = factory()</span><br><span class=\"line\">  &#125; else if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123;</span><br><span class=\"line\">    define([], factory)</span><br><span class=\"line\">  &#125; else if (typeof exports === &apos;object&apos;) &#123;</span><br><span class=\"line\">    exports[&apos;snb&apos;] = factory()</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    global[&apos;snb&apos;] = factory()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)(this, function () &#123;</span><br><span class=\"line\">  class snb &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  return snb</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"发布模块\"><a href=\"#发布模块\" class=\"headerlink\" title=\"发布模块\"></a>发布模块</h3><p>1、 在npm  <a href=\"https://www.npmjs.com/signup\" target=\"_blank\" rel=\"noopener\">注册用户</a>。<br>2、 在本地登录自己的npm账号 <code>$ npm login</code> 。<br>3、发布模块。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm publish</span><br><span class=\"line\">+ snb@1.0.2 // 返回本条信息就是发布成功了</span><br></pre></td></tr></table></figure></p>\n<p>4、撤销发布自己发布过的某个版本代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm unpublish &lt;package&gt;@&lt;version&gt;</span><br></pre></td></tr></table></figure></p>\n<p>5、 其他命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 更新模块至最新版</span><br><span class=\"line\">$ npm update &lt;package&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 可以清空NPM本地缓存（使用了相同版本号发布新版本的情况）。</span><br><span class=\"line\">$ npm cache clear</span><br></pre></td></tr></table></figure></p>\n<p>还可以给自己的模块的来个图片徽章，可以放在github仓库的README.md里可以让访问到这项目的人看到项目的状态<br><a href=\"http://shields.io/\" target=\"_blank\" rel=\"noopener\">http://shields.io/</a><br><a href=\"https://nodei.co/\" target=\"_blank\" rel=\"noopener\">https://nodei.co/</a></p>\n<center><br><a href=\"https://www.npmjs.com/package/snb\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/npm/v/snb.svg\" alt=\"Version\"></a>  <a href=\"https://www.npmjs.com/package/snb\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/npm/dm/snb.svg\" alt=\"Download\"></a>  <a href=\"https://github.com/cherislive/snb/network\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/github/forks/cherislive/snb.svg\" alt=\"GitHub forks\"></a>  <a href=\"https://github.com/cherislive/snb/stargazers\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/github/stars/cherislive/snb.svg\" alt=\"GitHub stars\"></a></center><br><center><br><a href=\"https://nodei.co/npm/snb/\" target=\"_blank\" rel=\"noopener\"><img src=\"https://nodei.co/npm/snb.png?downloads=true&amp;downloadRank=true&amp;stars=true\" alt=\"NPM\"></a><br></center>\n","site":{"data":{}},"excerpt":"<p>把自己写的 node.js 模块发布到 npm 开源社区。<br>","more":"</p>\n<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p>node环境，<a href=\"https://www.npmjs.com/\" target=\"_blank\" rel=\"noopener\">npm官网</a> 账号。</p>\n<h3 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm init</span><br></pre></td></tr></table></figure>\n<p>一路Enter<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;: &quot;npm-name&quot;,</span><br><span class=\"line\">  &quot;version&quot;: &quot;1.0.1&quot;,</span><br><span class=\"line\">  &quot;description&quot;: &quot;desc...&quot;,</span><br><span class=\"line\">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class=\"line\">  &quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;repository&quot;: &#123;</span><br><span class=\"line\">    &quot;type&quot;: &quot;git&quot;,</span><br><span class=\"line\">    &quot;url&quot;: &quot;git+https://github.com/cherislive/snb.git&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;keywords&quot;: [</span><br><span class=\"line\">    &quot;keywords&quot;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;author&quot;: &quot;cheris&quot;,</span><br><span class=\"line\">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class=\"line\">  &quot;bugs&quot;: &#123;</span><br><span class=\"line\">    &quot;url&quot;: &quot;https://github.com/cherislive/snb/issues&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;homepage&quot;: &quot;https://github.com/cherislive/snb#readme&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>name</strong>:  模块名，之后发布之后就可以让用户npm install xxxx来引用你的开源模块了。</li>\n<li><strong>version</strong>:  版本号，语义版本号分为 <strong>X.Y.Z</strong> 三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。</li>\n</ul>\n<ul>\n<li>如果只是修复bug，需要更新<strong>Z</strong>位。</li>\n<li>如果是新增了功能，但是向下兼容，需要更新<strong>Y</strong>位。</li>\n<li>如果有大变动，向下不兼容，需要更新<strong>X</strong>位。</li>\n</ul>\n<ul>\n<li><strong>description</strong>:  简单介绍自己的模块。</li>\n<li><strong>main</strong>:  入口文件，必要，当通过require(‘xxx’)时，是读取main里声明的文件。</li>\n<li><strong>test command</strong>:  测试命令。</li>\n<li><strong>git repository</strong>:  git仓库地址。</li>\n<li><strong>keywords</strong>:  关键词，可以通过npm搜索你填写的关键词找到你的模块。</li>\n<li><strong>author</strong>:  作者信息，可以之后编辑更详细一些。</li>\n<li><strong>license</strong>:  代码授权许可。</li>\n</ul>\n<h3 id=\"编写代码\"><a href=\"#编写代码\" class=\"headerlink\" title=\"编写代码\"></a>编写代码</h3><p>这里需要考虑不同的引入方式（import | require | src）。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;(function (root, factory) &#123;</span><br><span class=\"line\">  if (typeof exports === &apos;object&apos; &amp;&amp; typeof module !== &apos;undefined&apos;) &#123;</span><br><span class=\"line\">    module.exports = factory()</span><br><span class=\"line\">  &#125; else if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123;</span><br><span class=\"line\">    define([], factory)</span><br><span class=\"line\">  &#125; else if (typeof exports === &apos;object&apos;) &#123;</span><br><span class=\"line\">    exports[&apos;snb&apos;] = factory()</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    global[&apos;snb&apos;] = factory()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)(this, function () &#123;</span><br><span class=\"line\">  class snb &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  return snb</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"发布模块\"><a href=\"#发布模块\" class=\"headerlink\" title=\"发布模块\"></a>发布模块</h3><p>1、 在npm  <a href=\"https://www.npmjs.com/signup\" target=\"_blank\" rel=\"noopener\">注册用户</a>。<br>2、 在本地登录自己的npm账号 <code>$ npm login</code> 。<br>3、发布模块。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm publish</span><br><span class=\"line\">+ snb@1.0.2 // 返回本条信息就是发布成功了</span><br></pre></td></tr></table></figure></p>\n<p>4、撤销发布自己发布过的某个版本代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm unpublish &lt;package&gt;@&lt;version&gt;</span><br></pre></td></tr></table></figure></p>\n<p>5、 其他命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 更新模块至最新版</span><br><span class=\"line\">$ npm update &lt;package&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 可以清空NPM本地缓存（使用了相同版本号发布新版本的情况）。</span><br><span class=\"line\">$ npm cache clear</span><br></pre></td></tr></table></figure></p>\n<p>还可以给自己的模块的来个图片徽章，可以放在github仓库的README.md里可以让访问到这项目的人看到项目的状态<br><a href=\"http://shields.io/\" target=\"_blank\" rel=\"noopener\">http://shields.io/</a><br><a href=\"https://nodei.co/\" target=\"_blank\" rel=\"noopener\">https://nodei.co/</a></p>\n<center><br><a href=\"https://www.npmjs.com/package/snb\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/npm/v/snb.svg\" alt=\"Version\"></a>  <a href=\"https://www.npmjs.com/package/snb\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/npm/dm/snb.svg\" alt=\"Download\"></a>  <a href=\"https://github.com/cherislive/snb/network\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/github/forks/cherislive/snb.svg\" alt=\"GitHub forks\"></a>  <a href=\"https://github.com/cherislive/snb/stargazers\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/github/stars/cherislive/snb.svg\" alt=\"GitHub stars\"></a></center><br><center><br><a href=\"https://nodei.co/npm/snb/\" target=\"_blank\" rel=\"noopener\"><img src=\"https://nodei.co/npm/snb.png?downloads=true&amp;downloadRank=true&amp;stars=true\" alt=\"NPM\"></a><br></center>"},{"title":"响应式图片","date":"2017-03-28T03:30:10.000Z","_content":"早在2010年响应式网页的概念就已经出现，对于响应式网页设计，带来多设备适配的同时，也存在一些问题。使用同一图像源，要么在手机上加载一个巨大的图像，要么在一个大显示器上显示模糊、马赛克状的图像。\n<!--more-->\n我们无法预测用户在何地以及如何访问我们的网站，所以我们需要浏览器自身根据情况选择最好的图像。\n\nimg元素增加了两个新属性：srcset和sizes。\n* srcset用来声明一组图像源，浏览器根据我们使用描述符指定的条件来选择图像。\n描述符x表示图像的像素密度，描述符w表示图像的宽度；浏览器使用这些信息从列表中选择合适的图像。\n*  sizes属性为浏览器提供将要显示图像的尺寸信息，srcset使用w描述符时必须包含此属性。这种方法尤其适用于可变宽度的图像。\n \n> 基于设备象素比（device-pixel-radio）选择\n> 基于viewport选择\n> 基于Art direction（美术设计）选择\n> 基于图像格式选择\n\n## 相同质量不同图像的加载\n\n### 固定宽度图像：基于设备像素比选择\n在 视网膜屏幕，4K显示器，UltraHD 等设备上，不仅要考虑屏幕的分辨率，而且需要考虑像素密度，它们都比相同尺寸的标准分辨率显示器填充了更多的像素。更多的像素=更清晰的图像。\n有些图片不管屏幕尺寸，始终以固定宽度显示，如logo、头像，浏览器需要根据像素比来选择加载哪张图像。\n\n> *srcset* 属性列出了浏览器可选择加载的源图像池，由逗号（,）分隔，描述符x表示图像的设备像素比，浏览器根据运行环境选择实弹的图像。低版本浏览器忽略*srcset*属性。 \n\n```\n<img srcset=\"crest-300.jpg 1.5x, crest-400.jpg 2x\" src=\"crest-200.jpg\" alt=\"crest\" >\n```\n<img  srcset=\"https://assets-github.cheris.com.cn/responsive/crest-300.jpg 1.5x, https://assets-github.cheris.com.cn/responsive/crest-400.jpg 2x\"  src=\"https://assets-github.cheris.com.cn/responsive/crest-200.jpg\" />\n\n\n### 可变宽度的图像：基于viewport选择\n与内容相关的图片，通常也需要响应式，它们的大小往往随viewport改变。\n\n>  *srcset* 属性搭配描述符w，w告诉浏览器列表中每个图像的宽度。\n>  *sizes* 属性列出了媒体列表，由逗号（,）分隔。第一个条件是媒体条件，第二个是源图尺寸值，此值决定图片的宽度，vw是唯一可用的css单位。\n\n```\n<img srcset=\"uswnt-480.jpg 480w,\n             uswnt-640.jpg 640w,\n             uswnt-960.jpg 960w,\n             uswnt-1280.jpg 1280w\" \n     sizes=\"(max-width: 400px) 100vw, \n            (max-width: 960px) 75vw, \n            640px\" src=\"uswnt-640.jpg\" alt=\"uswnt\">\n```\n<img srcset=\"https://assets-github.cheris.com.cn/responsive/uswnt-480.jpg 480w,\n             https://assets-github.cheris.com.cn/responsive/uswnt-640.jpg 640w,\n             https://assets-github.cheris.com.cn/responsive/uswnt-960.jpg 960w,\n             https://assets-github.cheris.com.cn/responsive/uswnt-1280.jpg 1280w\" \n     sizes=\"(max-width: 400px) 100vw, \n            (max-width: 960px) 75vw, \n            640px\" src=\"https://assets-github.cheris.com.cn/responsive/uswnt-640.jpg\" alt=\"uswnt\">\n\n\n浏览器在viewport宽度小于400像素时，使图像的宽度与viewport等宽。在viewport宽度小于960像素时，使图像的宽度为viewport宽度的75％。当viewport大于960像素时，使图像的宽度为640像素 。\n\n浏览器利用srcset和sizes信息来选择最符合规定条件的图像。如果浏览器的viewport是600像素，图像最可能以75vw的宽度显示。浏览器将尝试加载第一张大于450像素（600*0.75）的图像，也就是uswnt-480.jpg。如果我的是dpr为2的Retina显示屏，那么浏览器就会尝试加载第一张大于900像素（600*0.75*2）的图像，也就是uswnt-960.jpg。我们无法确定究竟显示哪张图像，因为每个浏览器根据我们提供的信息挑选适当图像的算法是有差异的。\n> srcset和size列表是对浏览器的一个建议(hint)，而非指令。例如，设备像素比(dpr)为1.5的设备，亦可用1x也可用2x的图像，由浏览器根据其能力、网络等因素来决定。\n\n## 不同宽度不同图像\n不同宽度下显示稍微不同的图像，比如在较窄屏幕下仅显示图像的关键部分，那么要使用picture元素。\n### picture：基于Art direction（美术设计）选择\npicture元素就像是图像和其源的容器。浏览器仍然需要img元素，用来表明需要加载图片，如果没有img，那么什么都不会渲染。source为浏览器提供了要显示图像的供选版本。基于美术设计选择的适用场景为：在一个特定的转效点（breakpoint）需要显示一个特定的图像。使用picture元素选择图像，不会有歧义。\n\n```\n<picture>\n  <source media=\"(min-width: 960px)\" srcset=\"ticker-tape-large.jpg\">\n  <source media=\"(min-width: 575px)\" srcset=\"ticker-tape-medium.jpg\">\n  <img src=\"ticker-tape-small.jpg\" alt=\"USWNT ticker-tape parade\">\n</picture>\n```\n<picture>\n  <source media=\"(min-width: 960px)\" srcset=\"https://assets-github.cheris.com.cn/responsive/ticker-tape-large.jpg\">\n  <source media=\"(min-width: 575px)\" srcset=\"https://assets-github.cheris.com.cn/responsive/ticker-tape-medium.jpg\">\n  <img src=\"https://assets-github.cheris.com.cn/responsive/ticker-tape-small.jpg\" alt=\"USWNT ticker-tape parade\">\n</picture>\n\n\n在本例中，当viewport大于960像素时，会加载图像的风景模式版本（ticker-tape-large.jpg）。当viewport宽度大于575像素时，浏览器会加载图像的裁剪过的肖像模式版本（ticker-tape-medium.jpg）。而当宽度小于575像素时，加载的图像（ ticker-tape-small.jpg）已经被裁剪成焦点仅在一个球员上了。\npicture元素是向后兼容的；不支持picture元素的浏览器将显示img。图像的所有标准属性（如alt），应该作用在img上而不是picture上。\n\n### source：基于图片格式选择\n最近几年出现了一些新的图片格式，这些新图像格式在较小的文件大小情况下保证了较好的图片质量。听起来还不错，但残酷的事实是没有一个新格式被所有浏览器支持。谷歌的WebP表现不错，但只有Chrome和Opera原声支持。JPEG-XR，最初被称为高清照片，是微软发布的一个专有图像格式，仅Internet Explorer支持。\n\n```\n<picture>\n  <source type=\"image/vnd.ms-photo\" src=\"wwc2017.jxr\">\n  <source type=\"image/jp2\" src=\"wwc2017.jp2\">\n  <source type=\"image/webp\" src=\"wwc2017.webp\">\n  <img src=\"wwc2017.png\" alt=\"WWC 2015\">\n</picture>\n```\nsource的type属性用来指定每个图像的MIME类型，浏览器会选择第一个含有其支持的MIME类型的源。源的顺序是至关重要的，如果浏览器无法识别所有的图象类型，它会回退至原来的img元素。","source":"_posts/响应式图片.md","raw":"---\ntitle: 响应式图片\ndate: 2017-03-28 11:30:10\ntags:\n---\n早在2010年响应式网页的概念就已经出现，对于响应式网页设计，带来多设备适配的同时，也存在一些问题。使用同一图像源，要么在手机上加载一个巨大的图像，要么在一个大显示器上显示模糊、马赛克状的图像。\n<!--more-->\n我们无法预测用户在何地以及如何访问我们的网站，所以我们需要浏览器自身根据情况选择最好的图像。\n\nimg元素增加了两个新属性：srcset和sizes。\n* srcset用来声明一组图像源，浏览器根据我们使用描述符指定的条件来选择图像。\n描述符x表示图像的像素密度，描述符w表示图像的宽度；浏览器使用这些信息从列表中选择合适的图像。\n*  sizes属性为浏览器提供将要显示图像的尺寸信息，srcset使用w描述符时必须包含此属性。这种方法尤其适用于可变宽度的图像。\n \n> 基于设备象素比（device-pixel-radio）选择\n> 基于viewport选择\n> 基于Art direction（美术设计）选择\n> 基于图像格式选择\n\n## 相同质量不同图像的加载\n\n### 固定宽度图像：基于设备像素比选择\n在 视网膜屏幕，4K显示器，UltraHD 等设备上，不仅要考虑屏幕的分辨率，而且需要考虑像素密度，它们都比相同尺寸的标准分辨率显示器填充了更多的像素。更多的像素=更清晰的图像。\n有些图片不管屏幕尺寸，始终以固定宽度显示，如logo、头像，浏览器需要根据像素比来选择加载哪张图像。\n\n> *srcset* 属性列出了浏览器可选择加载的源图像池，由逗号（,）分隔，描述符x表示图像的设备像素比，浏览器根据运行环境选择实弹的图像。低版本浏览器忽略*srcset*属性。 \n\n```\n<img srcset=\"crest-300.jpg 1.5x, crest-400.jpg 2x\" src=\"crest-200.jpg\" alt=\"crest\" >\n```\n<img  srcset=\"https://assets-github.cheris.com.cn/responsive/crest-300.jpg 1.5x, https://assets-github.cheris.com.cn/responsive/crest-400.jpg 2x\"  src=\"https://assets-github.cheris.com.cn/responsive/crest-200.jpg\" />\n\n\n### 可变宽度的图像：基于viewport选择\n与内容相关的图片，通常也需要响应式，它们的大小往往随viewport改变。\n\n>  *srcset* 属性搭配描述符w，w告诉浏览器列表中每个图像的宽度。\n>  *sizes* 属性列出了媒体列表，由逗号（,）分隔。第一个条件是媒体条件，第二个是源图尺寸值，此值决定图片的宽度，vw是唯一可用的css单位。\n\n```\n<img srcset=\"uswnt-480.jpg 480w,\n             uswnt-640.jpg 640w,\n             uswnt-960.jpg 960w,\n             uswnt-1280.jpg 1280w\" \n     sizes=\"(max-width: 400px) 100vw, \n            (max-width: 960px) 75vw, \n            640px\" src=\"uswnt-640.jpg\" alt=\"uswnt\">\n```\n<img srcset=\"https://assets-github.cheris.com.cn/responsive/uswnt-480.jpg 480w,\n             https://assets-github.cheris.com.cn/responsive/uswnt-640.jpg 640w,\n             https://assets-github.cheris.com.cn/responsive/uswnt-960.jpg 960w,\n             https://assets-github.cheris.com.cn/responsive/uswnt-1280.jpg 1280w\" \n     sizes=\"(max-width: 400px) 100vw, \n            (max-width: 960px) 75vw, \n            640px\" src=\"https://assets-github.cheris.com.cn/responsive/uswnt-640.jpg\" alt=\"uswnt\">\n\n\n浏览器在viewport宽度小于400像素时，使图像的宽度与viewport等宽。在viewport宽度小于960像素时，使图像的宽度为viewport宽度的75％。当viewport大于960像素时，使图像的宽度为640像素 。\n\n浏览器利用srcset和sizes信息来选择最符合规定条件的图像。如果浏览器的viewport是600像素，图像最可能以75vw的宽度显示。浏览器将尝试加载第一张大于450像素（600*0.75）的图像，也就是uswnt-480.jpg。如果我的是dpr为2的Retina显示屏，那么浏览器就会尝试加载第一张大于900像素（600*0.75*2）的图像，也就是uswnt-960.jpg。我们无法确定究竟显示哪张图像，因为每个浏览器根据我们提供的信息挑选适当图像的算法是有差异的。\n> srcset和size列表是对浏览器的一个建议(hint)，而非指令。例如，设备像素比(dpr)为1.5的设备，亦可用1x也可用2x的图像，由浏览器根据其能力、网络等因素来决定。\n\n## 不同宽度不同图像\n不同宽度下显示稍微不同的图像，比如在较窄屏幕下仅显示图像的关键部分，那么要使用picture元素。\n### picture：基于Art direction（美术设计）选择\npicture元素就像是图像和其源的容器。浏览器仍然需要img元素，用来表明需要加载图片，如果没有img，那么什么都不会渲染。source为浏览器提供了要显示图像的供选版本。基于美术设计选择的适用场景为：在一个特定的转效点（breakpoint）需要显示一个特定的图像。使用picture元素选择图像，不会有歧义。\n\n```\n<picture>\n  <source media=\"(min-width: 960px)\" srcset=\"ticker-tape-large.jpg\">\n  <source media=\"(min-width: 575px)\" srcset=\"ticker-tape-medium.jpg\">\n  <img src=\"ticker-tape-small.jpg\" alt=\"USWNT ticker-tape parade\">\n</picture>\n```\n<picture>\n  <source media=\"(min-width: 960px)\" srcset=\"https://assets-github.cheris.com.cn/responsive/ticker-tape-large.jpg\">\n  <source media=\"(min-width: 575px)\" srcset=\"https://assets-github.cheris.com.cn/responsive/ticker-tape-medium.jpg\">\n  <img src=\"https://assets-github.cheris.com.cn/responsive/ticker-tape-small.jpg\" alt=\"USWNT ticker-tape parade\">\n</picture>\n\n\n在本例中，当viewport大于960像素时，会加载图像的风景模式版本（ticker-tape-large.jpg）。当viewport宽度大于575像素时，浏览器会加载图像的裁剪过的肖像模式版本（ticker-tape-medium.jpg）。而当宽度小于575像素时，加载的图像（ ticker-tape-small.jpg）已经被裁剪成焦点仅在一个球员上了。\npicture元素是向后兼容的；不支持picture元素的浏览器将显示img。图像的所有标准属性（如alt），应该作用在img上而不是picture上。\n\n### source：基于图片格式选择\n最近几年出现了一些新的图片格式，这些新图像格式在较小的文件大小情况下保证了较好的图片质量。听起来还不错，但残酷的事实是没有一个新格式被所有浏览器支持。谷歌的WebP表现不错，但只有Chrome和Opera原声支持。JPEG-XR，最初被称为高清照片，是微软发布的一个专有图像格式，仅Internet Explorer支持。\n\n```\n<picture>\n  <source type=\"image/vnd.ms-photo\" src=\"wwc2017.jxr\">\n  <source type=\"image/jp2\" src=\"wwc2017.jp2\">\n  <source type=\"image/webp\" src=\"wwc2017.webp\">\n  <img src=\"wwc2017.png\" alt=\"WWC 2015\">\n</picture>\n```\nsource的type属性用来指定每个图像的MIME类型，浏览器会选择第一个含有其支持的MIME类型的源。源的顺序是至关重要的，如果浏览器无法识别所有的图象类型，它会回退至原来的img元素。","slug":"响应式图片","published":1,"updated":"2019-03-21T03:42:03.284Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtifjpt2000dlohi2l29mve9","content":"<p>早在2010年响应式网页的概念就已经出现，对于响应式网页设计，带来多设备适配的同时，也存在一些问题。使用同一图像源，要么在手机上加载一个巨大的图像，要么在一个大显示器上显示模糊、马赛克状的图像。<br><a id=\"more\"></a><br>我们无法预测用户在何地以及如何访问我们的网站，所以我们需要浏览器自身根据情况选择最好的图像。</p>\n<p>img元素增加了两个新属性：srcset和sizes。</p>\n<ul>\n<li>srcset用来声明一组图像源，浏览器根据我们使用描述符指定的条件来选择图像。<br>描述符x表示图像的像素密度，描述符w表示图像的宽度；浏览器使用这些信息从列表中选择合适的图像。</li>\n<li>sizes属性为浏览器提供将要显示图像的尺寸信息，srcset使用w描述符时必须包含此属性。这种方法尤其适用于可变宽度的图像。</li>\n</ul>\n<blockquote>\n<p>基于设备象素比（device-pixel-radio）选择<br>基于viewport选择<br>基于Art direction（美术设计）选择<br>基于图像格式选择</p>\n</blockquote>\n<h2 id=\"相同质量不同图像的加载\"><a href=\"#相同质量不同图像的加载\" class=\"headerlink\" title=\"相同质量不同图像的加载\"></a>相同质量不同图像的加载</h2><h3 id=\"固定宽度图像：基于设备像素比选择\"><a href=\"#固定宽度图像：基于设备像素比选择\" class=\"headerlink\" title=\"固定宽度图像：基于设备像素比选择\"></a>固定宽度图像：基于设备像素比选择</h3><p>在 视网膜屏幕，4K显示器，UltraHD 等设备上，不仅要考虑屏幕的分辨率，而且需要考虑像素密度，它们都比相同尺寸的标准分辨率显示器填充了更多的像素。更多的像素=更清晰的图像。<br>有些图片不管屏幕尺寸，始终以固定宽度显示，如logo、头像，浏览器需要根据像素比来选择加载哪张图像。</p>\n<blockquote>\n<p><em>srcset</em> 属性列出了浏览器可选择加载的源图像池，由逗号（,）分隔，描述符x表示图像的设备像素比，浏览器根据运行环境选择实弹的图像。低版本浏览器忽略<em>srcset</em>属性。 </p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;img srcset=&quot;crest-300.jpg 1.5x, crest-400.jpg 2x&quot; src=&quot;crest-200.jpg&quot; alt=&quot;crest&quot; &gt;</span><br></pre></td></tr></table></figure>\n<p><img srcset=\"https://assets-github.cheris.com.cn/responsive/crest-300.jpg 1.5x, https://assets-github.cheris.com.cn/responsive/crest-400.jpg 2x\" src=\"https://assets-github.cheris.com.cn/responsive/crest-200.jpg\"></p>\n<h3 id=\"可变宽度的图像：基于viewport选择\"><a href=\"#可变宽度的图像：基于viewport选择\" class=\"headerlink\" title=\"可变宽度的图像：基于viewport选择\"></a>可变宽度的图像：基于viewport选择</h3><p>与内容相关的图片，通常也需要响应式，它们的大小往往随viewport改变。</p>\n<blockquote>\n<p> <em>srcset</em> 属性搭配描述符w，w告诉浏览器列表中每个图像的宽度。<br> <em>sizes</em> 属性列出了媒体列表，由逗号（,）分隔。第一个条件是媒体条件，第二个是源图尺寸值，此值决定图片的宽度，vw是唯一可用的css单位。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;img srcset=&quot;uswnt-480.jpg 480w,</span><br><span class=\"line\">             uswnt-640.jpg 640w,</span><br><span class=\"line\">             uswnt-960.jpg 960w,</span><br><span class=\"line\">             uswnt-1280.jpg 1280w&quot; </span><br><span class=\"line\">     sizes=&quot;(max-width: 400px) 100vw, </span><br><span class=\"line\">            (max-width: 960px) 75vw, </span><br><span class=\"line\">            640px&quot; src=&quot;uswnt-640.jpg&quot; alt=&quot;uswnt&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p><img srcset=\"https://assets-github.cheris.com.cn/responsive/uswnt-480.jpg 480w,\n             https://assets-github.cheris.com.cn/responsive/uswnt-640.jpg 640w,\n             https://assets-github.cheris.com.cn/responsive/uswnt-960.jpg 960w,\n             https://assets-github.cheris.com.cn/responsive/uswnt-1280.jpg 1280w\" sizes=\"(max-width: 400px) 100vw, \n            (max-width: 960px) 75vw, \n            640px\" src=\"https://assets-github.cheris.com.cn/responsive/uswnt-640.jpg\" alt=\"uswnt\"></p>\n<p>浏览器在viewport宽度小于400像素时，使图像的宽度与viewport等宽。在viewport宽度小于960像素时，使图像的宽度为viewport宽度的75％。当viewport大于960像素时，使图像的宽度为640像素 。</p>\n<p>浏览器利用srcset和sizes信息来选择最符合规定条件的图像。如果浏览器的viewport是600像素，图像最可能以75vw的宽度显示。浏览器将尝试加载第一张大于450像素（600<em>0.75）的图像，也就是uswnt-480.jpg。如果我的是dpr为2的Retina显示屏，那么浏览器就会尝试加载第一张大于900像素（600</em>0.75*2）的图像，也就是uswnt-960.jpg。我们无法确定究竟显示哪张图像，因为每个浏览器根据我们提供的信息挑选适当图像的算法是有差异的。</p>\n<blockquote>\n<p>srcset和size列表是对浏览器的一个建议(hint)，而非指令。例如，设备像素比(dpr)为1.5的设备，亦可用1x也可用2x的图像，由浏览器根据其能力、网络等因素来决定。</p>\n</blockquote>\n<h2 id=\"不同宽度不同图像\"><a href=\"#不同宽度不同图像\" class=\"headerlink\" title=\"不同宽度不同图像\"></a>不同宽度不同图像</h2><p>不同宽度下显示稍微不同的图像，比如在较窄屏幕下仅显示图像的关键部分，那么要使用picture元素。</p>\n<h3 id=\"picture：基于Art-direction（美术设计）选择\"><a href=\"#picture：基于Art-direction（美术设计）选择\" class=\"headerlink\" title=\"picture：基于Art direction（美术设计）选择\"></a>picture：基于Art direction（美术设计）选择</h3><p>picture元素就像是图像和其源的容器。浏览器仍然需要img元素，用来表明需要加载图片，如果没有img，那么什么都不会渲染。source为浏览器提供了要显示图像的供选版本。基于美术设计选择的适用场景为：在一个特定的转效点（breakpoint）需要显示一个特定的图像。使用picture元素选择图像，不会有歧义。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;picture&gt;</span><br><span class=\"line\">  &lt;source media=&quot;(min-width: 960px)&quot; srcset=&quot;ticker-tape-large.jpg&quot;&gt;</span><br><span class=\"line\">  &lt;source media=&quot;(min-width: 575px)&quot; srcset=&quot;ticker-tape-medium.jpg&quot;&gt;</span><br><span class=\"line\">  &lt;img src=&quot;ticker-tape-small.jpg&quot; alt=&quot;USWNT ticker-tape parade&quot;&gt;</span><br><span class=\"line\">&lt;/picture&gt;</span><br></pre></td></tr></table></figure>\n<picture><br>  <source media=\"(min-width: 960px)\" srcset=\"https://assets-github.cheris.com.cn/responsive/ticker-tape-large.jpg\"><br>  <source media=\"(min-width: 575px)\" srcset=\"https://assets-github.cheris.com.cn/responsive/ticker-tape-medium.jpg\"><br>  <img src=\"https://assets-github.cheris.com.cn/responsive/ticker-tape-small.jpg\" alt=\"USWNT ticker-tape parade\"><br></picture>\n\n\n<p>在本例中，当viewport大于960像素时，会加载图像的风景模式版本（ticker-tape-large.jpg）。当viewport宽度大于575像素时，浏览器会加载图像的裁剪过的肖像模式版本（ticker-tape-medium.jpg）。而当宽度小于575像素时，加载的图像（ ticker-tape-small.jpg）已经被裁剪成焦点仅在一个球员上了。<br>picture元素是向后兼容的；不支持picture元素的浏览器将显示img。图像的所有标准属性（如alt），应该作用在img上而不是picture上。</p>\n<h3 id=\"source：基于图片格式选择\"><a href=\"#source：基于图片格式选择\" class=\"headerlink\" title=\"source：基于图片格式选择\"></a>source：基于图片格式选择</h3><p>最近几年出现了一些新的图片格式，这些新图像格式在较小的文件大小情况下保证了较好的图片质量。听起来还不错，但残酷的事实是没有一个新格式被所有浏览器支持。谷歌的WebP表现不错，但只有Chrome和Opera原声支持。JPEG-XR，最初被称为高清照片，是微软发布的一个专有图像格式，仅Internet Explorer支持。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;picture&gt;</span><br><span class=\"line\">  &lt;source type=&quot;image/vnd.ms-photo&quot; src=&quot;wwc2017.jxr&quot;&gt;</span><br><span class=\"line\">  &lt;source type=&quot;image/jp2&quot; src=&quot;wwc2017.jp2&quot;&gt;</span><br><span class=\"line\">  &lt;source type=&quot;image/webp&quot; src=&quot;wwc2017.webp&quot;&gt;</span><br><span class=\"line\">  &lt;img src=&quot;wwc2017.png&quot; alt=&quot;WWC 2015&quot;&gt;</span><br><span class=\"line\">&lt;/picture&gt;</span><br></pre></td></tr></table></figure>\n<p>source的type属性用来指定每个图像的MIME类型，浏览器会选择第一个含有其支持的MIME类型的源。源的顺序是至关重要的，如果浏览器无法识别所有的图象类型，它会回退至原来的img元素。</p>\n","site":{"data":{}},"excerpt":"<p>早在2010年响应式网页的概念就已经出现，对于响应式网页设计，带来多设备适配的同时，也存在一些问题。使用同一图像源，要么在手机上加载一个巨大的图像，要么在一个大显示器上显示模糊、马赛克状的图像。<br>","more":"<br>我们无法预测用户在何地以及如何访问我们的网站，所以我们需要浏览器自身根据情况选择最好的图像。</p>\n<p>img元素增加了两个新属性：srcset和sizes。</p>\n<ul>\n<li>srcset用来声明一组图像源，浏览器根据我们使用描述符指定的条件来选择图像。<br>描述符x表示图像的像素密度，描述符w表示图像的宽度；浏览器使用这些信息从列表中选择合适的图像。</li>\n<li>sizes属性为浏览器提供将要显示图像的尺寸信息，srcset使用w描述符时必须包含此属性。这种方法尤其适用于可变宽度的图像。</li>\n</ul>\n<blockquote>\n<p>基于设备象素比（device-pixel-radio）选择<br>基于viewport选择<br>基于Art direction（美术设计）选择<br>基于图像格式选择</p>\n</blockquote>\n<h2 id=\"相同质量不同图像的加载\"><a href=\"#相同质量不同图像的加载\" class=\"headerlink\" title=\"相同质量不同图像的加载\"></a>相同质量不同图像的加载</h2><h3 id=\"固定宽度图像：基于设备像素比选择\"><a href=\"#固定宽度图像：基于设备像素比选择\" class=\"headerlink\" title=\"固定宽度图像：基于设备像素比选择\"></a>固定宽度图像：基于设备像素比选择</h3><p>在 视网膜屏幕，4K显示器，UltraHD 等设备上，不仅要考虑屏幕的分辨率，而且需要考虑像素密度，它们都比相同尺寸的标准分辨率显示器填充了更多的像素。更多的像素=更清晰的图像。<br>有些图片不管屏幕尺寸，始终以固定宽度显示，如logo、头像，浏览器需要根据像素比来选择加载哪张图像。</p>\n<blockquote>\n<p><em>srcset</em> 属性列出了浏览器可选择加载的源图像池，由逗号（,）分隔，描述符x表示图像的设备像素比，浏览器根据运行环境选择实弹的图像。低版本浏览器忽略<em>srcset</em>属性。 </p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;img srcset=&quot;crest-300.jpg 1.5x, crest-400.jpg 2x&quot; src=&quot;crest-200.jpg&quot; alt=&quot;crest&quot; &gt;</span><br></pre></td></tr></table></figure>\n<p><img srcset=\"https://assets-github.cheris.com.cn/responsive/crest-300.jpg 1.5x, https://assets-github.cheris.com.cn/responsive/crest-400.jpg 2x\" src=\"https://assets-github.cheris.com.cn/responsive/crest-200.jpg\"></p>\n<h3 id=\"可变宽度的图像：基于viewport选择\"><a href=\"#可变宽度的图像：基于viewport选择\" class=\"headerlink\" title=\"可变宽度的图像：基于viewport选择\"></a>可变宽度的图像：基于viewport选择</h3><p>与内容相关的图片，通常也需要响应式，它们的大小往往随viewport改变。</p>\n<blockquote>\n<p> <em>srcset</em> 属性搭配描述符w，w告诉浏览器列表中每个图像的宽度。<br> <em>sizes</em> 属性列出了媒体列表，由逗号（,）分隔。第一个条件是媒体条件，第二个是源图尺寸值，此值决定图片的宽度，vw是唯一可用的css单位。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;img srcset=&quot;uswnt-480.jpg 480w,</span><br><span class=\"line\">             uswnt-640.jpg 640w,</span><br><span class=\"line\">             uswnt-960.jpg 960w,</span><br><span class=\"line\">             uswnt-1280.jpg 1280w&quot; </span><br><span class=\"line\">     sizes=&quot;(max-width: 400px) 100vw, </span><br><span class=\"line\">            (max-width: 960px) 75vw, </span><br><span class=\"line\">            640px&quot; src=&quot;uswnt-640.jpg&quot; alt=&quot;uswnt&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p><img srcset=\"https://assets-github.cheris.com.cn/responsive/uswnt-480.jpg 480w,\n             https://assets-github.cheris.com.cn/responsive/uswnt-640.jpg 640w,\n             https://assets-github.cheris.com.cn/responsive/uswnt-960.jpg 960w,\n             https://assets-github.cheris.com.cn/responsive/uswnt-1280.jpg 1280w\" sizes=\"(max-width: 400px) 100vw, \n            (max-width: 960px) 75vw, \n            640px\" src=\"https://assets-github.cheris.com.cn/responsive/uswnt-640.jpg\" alt=\"uswnt\"></p>\n<p>浏览器在viewport宽度小于400像素时，使图像的宽度与viewport等宽。在viewport宽度小于960像素时，使图像的宽度为viewport宽度的75％。当viewport大于960像素时，使图像的宽度为640像素 。</p>\n<p>浏览器利用srcset和sizes信息来选择最符合规定条件的图像。如果浏览器的viewport是600像素，图像最可能以75vw的宽度显示。浏览器将尝试加载第一张大于450像素（600<em>0.75）的图像，也就是uswnt-480.jpg。如果我的是dpr为2的Retina显示屏，那么浏览器就会尝试加载第一张大于900像素（600</em>0.75*2）的图像，也就是uswnt-960.jpg。我们无法确定究竟显示哪张图像，因为每个浏览器根据我们提供的信息挑选适当图像的算法是有差异的。</p>\n<blockquote>\n<p>srcset和size列表是对浏览器的一个建议(hint)，而非指令。例如，设备像素比(dpr)为1.5的设备，亦可用1x也可用2x的图像，由浏览器根据其能力、网络等因素来决定。</p>\n</blockquote>\n<h2 id=\"不同宽度不同图像\"><a href=\"#不同宽度不同图像\" class=\"headerlink\" title=\"不同宽度不同图像\"></a>不同宽度不同图像</h2><p>不同宽度下显示稍微不同的图像，比如在较窄屏幕下仅显示图像的关键部分，那么要使用picture元素。</p>\n<h3 id=\"picture：基于Art-direction（美术设计）选择\"><a href=\"#picture：基于Art-direction（美术设计）选择\" class=\"headerlink\" title=\"picture：基于Art direction（美术设计）选择\"></a>picture：基于Art direction（美术设计）选择</h3><p>picture元素就像是图像和其源的容器。浏览器仍然需要img元素，用来表明需要加载图片，如果没有img，那么什么都不会渲染。source为浏览器提供了要显示图像的供选版本。基于美术设计选择的适用场景为：在一个特定的转效点（breakpoint）需要显示一个特定的图像。使用picture元素选择图像，不会有歧义。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;picture&gt;</span><br><span class=\"line\">  &lt;source media=&quot;(min-width: 960px)&quot; srcset=&quot;ticker-tape-large.jpg&quot;&gt;</span><br><span class=\"line\">  &lt;source media=&quot;(min-width: 575px)&quot; srcset=&quot;ticker-tape-medium.jpg&quot;&gt;</span><br><span class=\"line\">  &lt;img src=&quot;ticker-tape-small.jpg&quot; alt=&quot;USWNT ticker-tape parade&quot;&gt;</span><br><span class=\"line\">&lt;/picture&gt;</span><br></pre></td></tr></table></figure>\n<picture><br>  <source media=\"(min-width: 960px)\" srcset=\"https://assets-github.cheris.com.cn/responsive/ticker-tape-large.jpg\"><br>  <source media=\"(min-width: 575px)\" srcset=\"https://assets-github.cheris.com.cn/responsive/ticker-tape-medium.jpg\"><br>  <img src=\"https://assets-github.cheris.com.cn/responsive/ticker-tape-small.jpg\" alt=\"USWNT ticker-tape parade\"><br></picture>\n\n\n<p>在本例中，当viewport大于960像素时，会加载图像的风景模式版本（ticker-tape-large.jpg）。当viewport宽度大于575像素时，浏览器会加载图像的裁剪过的肖像模式版本（ticker-tape-medium.jpg）。而当宽度小于575像素时，加载的图像（ ticker-tape-small.jpg）已经被裁剪成焦点仅在一个球员上了。<br>picture元素是向后兼容的；不支持picture元素的浏览器将显示img。图像的所有标准属性（如alt），应该作用在img上而不是picture上。</p>\n<h3 id=\"source：基于图片格式选择\"><a href=\"#source：基于图片格式选择\" class=\"headerlink\" title=\"source：基于图片格式选择\"></a>source：基于图片格式选择</h3><p>最近几年出现了一些新的图片格式，这些新图像格式在较小的文件大小情况下保证了较好的图片质量。听起来还不错，但残酷的事实是没有一个新格式被所有浏览器支持。谷歌的WebP表现不错，但只有Chrome和Opera原声支持。JPEG-XR，最初被称为高清照片，是微软发布的一个专有图像格式，仅Internet Explorer支持。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;picture&gt;</span><br><span class=\"line\">  &lt;source type=&quot;image/vnd.ms-photo&quot; src=&quot;wwc2017.jxr&quot;&gt;</span><br><span class=\"line\">  &lt;source type=&quot;image/jp2&quot; src=&quot;wwc2017.jp2&quot;&gt;</span><br><span class=\"line\">  &lt;source type=&quot;image/webp&quot; src=&quot;wwc2017.webp&quot;&gt;</span><br><span class=\"line\">  &lt;img src=&quot;wwc2017.png&quot; alt=&quot;WWC 2015&quot;&gt;</span><br><span class=\"line\">&lt;/picture&gt;</span><br></pre></td></tr></table></figure>\n<p>source的type属性用来指定每个图像的MIME类型，浏览器会选择第一个含有其支持的MIME类型的源。源的顺序是至关重要的，如果浏览器无法识别所有的图象类型，它会回退至原来的img元素。</p>"},{"title":"如何使用Gulp构建项目","date":"2016-07-14T02:06:16.000Z","_content":"[Gulp](http://gulpjs.com/) 是一个自动化工具，前端开发者可以使用它来处理常见任务：\n搭建web服务器;文件保存时自动重载浏览器;使用预处理器如Sass、LESS;优化资源，比如压缩CSS、JavaScript、压缩图片等。\n<!--more-->\n## 安装\n使用Terminal(终端，win下是cmd)用下面命令安装Gulp\n```\n$ sudo npm install gulp -g\n```\n\n## 创建Gulp项目\n新建一个project文件夹，并在该目录下执行npm init命令：\n```\n$ npm init\n```\n\n---未完待续---\n\n","source":"_posts/如何使用Gulp构建项目.md","raw":"---\ntitle: 如何使用Gulp构建项目\ndate: 2016-07-14 10:06:16\ntags: Gulp\ncategory: 前端\n---\n[Gulp](http://gulpjs.com/) 是一个自动化工具，前端开发者可以使用它来处理常见任务：\n搭建web服务器;文件保存时自动重载浏览器;使用预处理器如Sass、LESS;优化资源，比如压缩CSS、JavaScript、压缩图片等。\n<!--more-->\n## 安装\n使用Terminal(终端，win下是cmd)用下面命令安装Gulp\n```\n$ sudo npm install gulp -g\n```\n\n## 创建Gulp项目\n新建一个project文件夹，并在该目录下执行npm init命令：\n```\n$ npm init\n```\n\n---未完待续---\n\n","slug":"如何使用Gulp构建项目","published":1,"updated":"2019-03-21T03:42:03.284Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtifjpt8000hlohipircw2sh","content":"<p><a href=\"http://gulpjs.com/\" target=\"_blank\" rel=\"noopener\">Gulp</a> 是一个自动化工具，前端开发者可以使用它来处理常见任务：<br>搭建web服务器;文件保存时自动重载浏览器;使用预处理器如Sass、LESS;优化资源，比如压缩CSS、JavaScript、压缩图片等。<br><a id=\"more\"></a></p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>使用Terminal(终端，win下是cmd)用下面命令安装Gulp<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo npm install gulp -g</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"创建Gulp项目\"><a href=\"#创建Gulp项目\" class=\"headerlink\" title=\"创建Gulp项目\"></a>创建Gulp项目</h2><p>新建一个project文件夹，并在该目录下执行npm init命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm init</span><br></pre></td></tr></table></figure></p>\n<p>—未完待续—</p>\n","site":{"data":{}},"excerpt":"<p><a href=\"http://gulpjs.com/\" target=\"_blank\" rel=\"noopener\">Gulp</a> 是一个自动化工具，前端开发者可以使用它来处理常见任务：<br>搭建web服务器;文件保存时自动重载浏览器;使用预处理器如Sass、LESS;优化资源，比如压缩CSS、JavaScript、压缩图片等。<br>","more":"</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>使用Terminal(终端，win下是cmd)用下面命令安装Gulp<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo npm install gulp -g</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"创建Gulp项目\"><a href=\"#创建Gulp项目\" class=\"headerlink\" title=\"创建Gulp项目\"></a>创建Gulp项目</h2><p>新建一个project文件夹，并在该目录下执行npm init命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm init</span><br></pre></td></tr></table></figure></p>\n<p>—未完待续—</p>"},{"title":"抛弃jquery，你仍然可以","date":"2016-10-20T08:06:06.000Z","_content":"框架能够让我们走的更快，但只有了解原生的JS才能让我们走的更远。这里分享一些基础东西，这将可能帮你深入纯 JavaScript的世界，让你能更简单的做出决定——jQuery在你下个工程中是否需要。\n<!--more-->\n> 从来没有一个js库能像jQuery这般影响着这个行业，她不仅改变了人们对JavaScript的传统认知，更让人们给予了她一种新的语言地位。jQuery在前端开发领域可真是被宠坏了，她的关注指数是js的两倍，有人说是她成就了js，也有人说是它害了js，而无论舆论偏向何方，我们都必须正视这门传奇的库。\n\n### Document Ready 事件\n``` javascript\n$(document).ready(function() {\n  // do something\n});\n```\nJavaScript 示例:\n```\ndocument.addEventListener(\"DOMContentLoaded\", function() {\n  // do something\n}, false);\n```\n\n\n### 选择器\n```\nvar el = $('div');\n```\nJavaScript 示例:\n```\nvar el = document.querySelector(\"div\");\n// var el = document.querySelectorAll(\".container div\");\nvar navigation = document.querySelector(\"nav\");\nvar links = navigation.querySelectorAll(\"a\");\n\n\n// This gives us simple dollar function and event binding\nvar $ = document.querySelectorAll.bind(document);\nElement.prototype.on = Element.prototype.addEventListener;\n\n// This is how you use it\n$(\".element\")[0].on(\"touchstart\", handleTouch, false);\n```\n\n### 遍历DOM\nJavaScript 示例:\n```\n// Getting the parent node\nvar parent = document.querySelector(\"div\").parentNode;\n\n// Getting the next node\nvar next = document.querySelector(\"div\").nextSibling;\n\n// Getting the previous node\nvar next = document.querySelector(\"div\").previousSibling;\n\n// Getting the first child element\nvar child = document.querySelector(\"div\").children[0];\n\n// Getting the last child\nvar last = document.querySelector(\"div\").lastElementChild;\n\n```\n\n### 添加和删除样式名（class name)\nJavaScript 示例:\n```\nvar element = document.querySelector(\".some-class\");\n// Give class \"foo\" to the element\nelement.className = \"foo\";\nelement.className += \" foo\";\n```\n\nremoveClass:\n```\n// removeClass, takes two params: element and classname\nfunction removeClass(el, cls) {\n  var reg = new RegExp(\"(\\\\s|^)\" + cls + \"(\\\\s|$)\");\n  el.className = el.className.replace(reg, \" \").replace(/(^\\s*)|(\\s*$)/g,\"\");\n}\n\nremoveClass(element, \"foo\");\n```\n\nhasClass:\n```\n// hasClass, takes two params: element and classname\nfunction hasClass(el, cls) {\n  return el.className && new RegExp(\"(\\\\s|^)\" + cls + \"(\\\\s|$)\").test(el.className);\n}\n\n// Check if an element has class \"foo\"\nif (hasClass(element, \"foo\")) {\n  // Show an alert message if it does\n  alert(\"Element has the class!\");\n}\n\n```\n\n### HTML5 的  classList API 简介\n检测出浏览器是否支持\n```\nif (\"classList\" in document.documentElement) {\n  // classList is supported, now do something with it\n}\n```\n\nJavaScript 示例:\n```\n// Adding a class\nelement.classList.add(\"bar\");\n\n// Removing a class\nelement.classList.remove(\"foo\");\n\n// Checking if has a class\nelement.classList.contains(\"foo\");\n\n// Toggle a class\nelement.classList.toggle(\"active\");\n```\n代码对比：\n```\n<div id=\"test\" class=\"one two three\"></div>\nvar element = document.querySelector(\"#test\");\naddClass(element, \"two\");\nremoveClass(element, \"four\");\n```\n\n```\n<div id=\"test\" class=\"one two three\"></div>\nvar element = document.querySelector(\"#test\");\nelement.classList.add(\"two\");\nelement.classList.remove(\"four\");\n```\n### 事件监听器\n```\nelement.addEventListener(\"click\", function() {\n  alert(\"You clicked\");\n}, false);\n```\n```\n// Select all links\nvar links = document.querySelectorAll(\"a\");\n\n// For each link element\nlinks.forEach.call(links, function(el) {\n\n  // Add event listener\n  el.addEventListener(\"click\", function(event) {\n    event.preventDefault();\n    alert(\"You clicked\");\n  }, false);\n\n});\n```\n```\nvar button =  document.querySelector(\"#test\");\nvar object = {\n  init: function() {\n    button.addEventListener(\"click\", this, false);\n    button.addEventListener(\"touchstart\", this, false);\n  },\n  handleEvent: function(e) {\n    switch(e.type) {\n      case \"click\":\n        this.action();\n        break;\n      case \"touchstart\":\n        this.action();\n        break;\n    }\n  },\n  action: function() {\n    alert(\"Clicked or touched!\");\n  }\n};\n\n// Init\nobject.init();\n```\n\n### 操作DOM\n用纯JavaScript来操作DOM刚开始听起来就像一个可怕的想法，但比使用jQuery其实它并没有复杂多少。下面，我们会有一个例子，选择DOM的元素，克隆它，用JavaScript来操作克隆的样式，然后用被操纵的东西来替代原始的元素。\n```\n// Select an element\nvar element = document.querySelector(\".class\");\n\n// Clone it\nvar clone = element.cloneNode(true);\n\n// Do some manipulation off the DOM\nclone.style.background = \"#000\";\n\n// Replaces the original element with the new cloned one\nelement.parentNode.replaceChild(clone, element);\n```\n\n在DOM中，如果除了附加在<body>中新创建div，你不想替代任何东西，那么你可以这样做：\n```\ndocument.body.appendChild(clone);\n```\n### 在JS中决定响应图片的最大宽度\n```\nvar maxWidth = img.naturalWidth;\n```\n这将会给我们提供最大宽度100%像素的图片，且IE9,Chrome,Firefox,Safari和Opera都支持这个方法。我们也可以保留这个特性然后通过加载图片到内存中添加老浏览器的支持：\n```\n// Get image's max-width:100%; in pixels\nfunction getMaxWidth(img) {\n  var maxWidth;\n\n  // Check if naturalWidth is supported\n  if (img.naturalWidth !== undefined) {\n    maxWidth = img.naturalWidth;\n\n  // Not supported, use in-memory solution as fallback\n  } else {\n    var image = new Image();\n    image.src = img.src;\n    maxWidth = image.width;\n  }\n\n  // Return the max-width\n  return maxWidth;\n}\n```\n你应该注意到在检查宽度前，图片必须完全被加载。这是我们一直使用的用于确定它们有尺寸的方法：\n```\nfunction hasDimensions(img) {\n  return !!((img.complete && typeof img.naturalWidth !== \"undefined\") || img.width);\n}\n```\n### 判断一个元素是否在视图窗口中:\n通过使用getBoundingClientRect方法，你可以获取页面中任何元素的位置。以下是一个简单的函数来表明它有多简单和多强大。这个函数有一个参数，那就是你想要检查的元素。当元素为可见时，函数将返回true：\n```\n// Determine if an element is in the visible viewport\nfunction isInViewport(element) {\n  var rect = element.getBoundingClientRect();\n  var html = document.documentElement;\n  return (\n    rect.top >= 0 &&\n    rect.left >= 0 &&\n    rect.bottom <= (window.innerHeight || html.clientHeight) &&\n    rect.right <= (window.innerWidth || html.clientWidth)\n  );\n}\n```\n\n","source":"_posts/抛弃jquery，你仍然可以.md","raw":"---\ntitle: 抛弃jquery，你仍然可以\ndate: 2016-10-20 16:06:06\ntags: JavaScript\n---\n框架能够让我们走的更快，但只有了解原生的JS才能让我们走的更远。这里分享一些基础东西，这将可能帮你深入纯 JavaScript的世界，让你能更简单的做出决定——jQuery在你下个工程中是否需要。\n<!--more-->\n> 从来没有一个js库能像jQuery这般影响着这个行业，她不仅改变了人们对JavaScript的传统认知，更让人们给予了她一种新的语言地位。jQuery在前端开发领域可真是被宠坏了，她的关注指数是js的两倍，有人说是她成就了js，也有人说是它害了js，而无论舆论偏向何方，我们都必须正视这门传奇的库。\n\n### Document Ready 事件\n``` javascript\n$(document).ready(function() {\n  // do something\n});\n```\nJavaScript 示例:\n```\ndocument.addEventListener(\"DOMContentLoaded\", function() {\n  // do something\n}, false);\n```\n\n\n### 选择器\n```\nvar el = $('div');\n```\nJavaScript 示例:\n```\nvar el = document.querySelector(\"div\");\n// var el = document.querySelectorAll(\".container div\");\nvar navigation = document.querySelector(\"nav\");\nvar links = navigation.querySelectorAll(\"a\");\n\n\n// This gives us simple dollar function and event binding\nvar $ = document.querySelectorAll.bind(document);\nElement.prototype.on = Element.prototype.addEventListener;\n\n// This is how you use it\n$(\".element\")[0].on(\"touchstart\", handleTouch, false);\n```\n\n### 遍历DOM\nJavaScript 示例:\n```\n// Getting the parent node\nvar parent = document.querySelector(\"div\").parentNode;\n\n// Getting the next node\nvar next = document.querySelector(\"div\").nextSibling;\n\n// Getting the previous node\nvar next = document.querySelector(\"div\").previousSibling;\n\n// Getting the first child element\nvar child = document.querySelector(\"div\").children[0];\n\n// Getting the last child\nvar last = document.querySelector(\"div\").lastElementChild;\n\n```\n\n### 添加和删除样式名（class name)\nJavaScript 示例:\n```\nvar element = document.querySelector(\".some-class\");\n// Give class \"foo\" to the element\nelement.className = \"foo\";\nelement.className += \" foo\";\n```\n\nremoveClass:\n```\n// removeClass, takes two params: element and classname\nfunction removeClass(el, cls) {\n  var reg = new RegExp(\"(\\\\s|^)\" + cls + \"(\\\\s|$)\");\n  el.className = el.className.replace(reg, \" \").replace(/(^\\s*)|(\\s*$)/g,\"\");\n}\n\nremoveClass(element, \"foo\");\n```\n\nhasClass:\n```\n// hasClass, takes two params: element and classname\nfunction hasClass(el, cls) {\n  return el.className && new RegExp(\"(\\\\s|^)\" + cls + \"(\\\\s|$)\").test(el.className);\n}\n\n// Check if an element has class \"foo\"\nif (hasClass(element, \"foo\")) {\n  // Show an alert message if it does\n  alert(\"Element has the class!\");\n}\n\n```\n\n### HTML5 的  classList API 简介\n检测出浏览器是否支持\n```\nif (\"classList\" in document.documentElement) {\n  // classList is supported, now do something with it\n}\n```\n\nJavaScript 示例:\n```\n// Adding a class\nelement.classList.add(\"bar\");\n\n// Removing a class\nelement.classList.remove(\"foo\");\n\n// Checking if has a class\nelement.classList.contains(\"foo\");\n\n// Toggle a class\nelement.classList.toggle(\"active\");\n```\n代码对比：\n```\n<div id=\"test\" class=\"one two three\"></div>\nvar element = document.querySelector(\"#test\");\naddClass(element, \"two\");\nremoveClass(element, \"four\");\n```\n\n```\n<div id=\"test\" class=\"one two three\"></div>\nvar element = document.querySelector(\"#test\");\nelement.classList.add(\"two\");\nelement.classList.remove(\"four\");\n```\n### 事件监听器\n```\nelement.addEventListener(\"click\", function() {\n  alert(\"You clicked\");\n}, false);\n```\n```\n// Select all links\nvar links = document.querySelectorAll(\"a\");\n\n// For each link element\nlinks.forEach.call(links, function(el) {\n\n  // Add event listener\n  el.addEventListener(\"click\", function(event) {\n    event.preventDefault();\n    alert(\"You clicked\");\n  }, false);\n\n});\n```\n```\nvar button =  document.querySelector(\"#test\");\nvar object = {\n  init: function() {\n    button.addEventListener(\"click\", this, false);\n    button.addEventListener(\"touchstart\", this, false);\n  },\n  handleEvent: function(e) {\n    switch(e.type) {\n      case \"click\":\n        this.action();\n        break;\n      case \"touchstart\":\n        this.action();\n        break;\n    }\n  },\n  action: function() {\n    alert(\"Clicked or touched!\");\n  }\n};\n\n// Init\nobject.init();\n```\n\n### 操作DOM\n用纯JavaScript来操作DOM刚开始听起来就像一个可怕的想法，但比使用jQuery其实它并没有复杂多少。下面，我们会有一个例子，选择DOM的元素，克隆它，用JavaScript来操作克隆的样式，然后用被操纵的东西来替代原始的元素。\n```\n// Select an element\nvar element = document.querySelector(\".class\");\n\n// Clone it\nvar clone = element.cloneNode(true);\n\n// Do some manipulation off the DOM\nclone.style.background = \"#000\";\n\n// Replaces the original element with the new cloned one\nelement.parentNode.replaceChild(clone, element);\n```\n\n在DOM中，如果除了附加在<body>中新创建div，你不想替代任何东西，那么你可以这样做：\n```\ndocument.body.appendChild(clone);\n```\n### 在JS中决定响应图片的最大宽度\n```\nvar maxWidth = img.naturalWidth;\n```\n这将会给我们提供最大宽度100%像素的图片，且IE9,Chrome,Firefox,Safari和Opera都支持这个方法。我们也可以保留这个特性然后通过加载图片到内存中添加老浏览器的支持：\n```\n// Get image's max-width:100%; in pixels\nfunction getMaxWidth(img) {\n  var maxWidth;\n\n  // Check if naturalWidth is supported\n  if (img.naturalWidth !== undefined) {\n    maxWidth = img.naturalWidth;\n\n  // Not supported, use in-memory solution as fallback\n  } else {\n    var image = new Image();\n    image.src = img.src;\n    maxWidth = image.width;\n  }\n\n  // Return the max-width\n  return maxWidth;\n}\n```\n你应该注意到在检查宽度前，图片必须完全被加载。这是我们一直使用的用于确定它们有尺寸的方法：\n```\nfunction hasDimensions(img) {\n  return !!((img.complete && typeof img.naturalWidth !== \"undefined\") || img.width);\n}\n```\n### 判断一个元素是否在视图窗口中:\n通过使用getBoundingClientRect方法，你可以获取页面中任何元素的位置。以下是一个简单的函数来表明它有多简单和多强大。这个函数有一个参数，那就是你想要检查的元素。当元素为可见时，函数将返回true：\n```\n// Determine if an element is in the visible viewport\nfunction isInViewport(element) {\n  var rect = element.getBoundingClientRect();\n  var html = document.documentElement;\n  return (\n    rect.top >= 0 &&\n    rect.left >= 0 &&\n    rect.bottom <= (window.innerHeight || html.clientHeight) &&\n    rect.right <= (window.innerWidth || html.clientWidth)\n  );\n}\n```\n\n","slug":"抛弃jquery，你仍然可以","published":1,"updated":"2019-03-21T03:42:03.284Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtifjpt9000jlohid4fxwi2j","content":"<p>框架能够让我们走的更快，但只有了解原生的JS才能让我们走的更远。这里分享一些基础东西，这将可能帮你深入纯 JavaScript的世界，让你能更简单的做出决定——jQuery在你下个工程中是否需要。<br><a id=\"more\"></a></p>\n<blockquote>\n<p>从来没有一个js库能像jQuery这般影响着这个行业，她不仅改变了人们对JavaScript的传统认知，更让人们给予了她一种新的语言地位。jQuery在前端开发领域可真是被宠坏了，她的关注指数是js的两倍，有人说是她成就了js，也有人说是它害了js，而无论舆论偏向何方，我们都必须正视这门传奇的库。</p>\n</blockquote>\n<h3 id=\"Document-Ready-事件\"><a href=\"#Document-Ready-事件\" class=\"headerlink\" title=\"Document Ready 事件\"></a>Document Ready 事件</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"built_in\">document</span>).ready(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>JavaScript 示例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.addEventListener(&quot;DOMContentLoaded&quot;, function() &#123;</span><br><span class=\"line\">  // do something</span><br><span class=\"line\">&#125;, false);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"选择器\"><a href=\"#选择器\" class=\"headerlink\" title=\"选择器\"></a>选择器</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var el = $(&apos;div&apos;);</span><br></pre></td></tr></table></figure>\n<p>JavaScript 示例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var el = document.querySelector(&quot;div&quot;);</span><br><span class=\"line\">// var el = document.querySelectorAll(&quot;.container div&quot;);</span><br><span class=\"line\">var navigation = document.querySelector(&quot;nav&quot;);</span><br><span class=\"line\">var links = navigation.querySelectorAll(&quot;a&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// This gives us simple dollar function and event binding</span><br><span class=\"line\">var $ = document.querySelectorAll.bind(document);</span><br><span class=\"line\">Element.prototype.on = Element.prototype.addEventListener;</span><br><span class=\"line\"></span><br><span class=\"line\">// This is how you use it</span><br><span class=\"line\">$(&quot;.element&quot;)[0].on(&quot;touchstart&quot;, handleTouch, false);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"遍历DOM\"><a href=\"#遍历DOM\" class=\"headerlink\" title=\"遍历DOM\"></a>遍历DOM</h3><p>JavaScript 示例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Getting the parent node</span><br><span class=\"line\">var parent = document.querySelector(&quot;div&quot;).parentNode;</span><br><span class=\"line\"></span><br><span class=\"line\">// Getting the next node</span><br><span class=\"line\">var next = document.querySelector(&quot;div&quot;).nextSibling;</span><br><span class=\"line\"></span><br><span class=\"line\">// Getting the previous node</span><br><span class=\"line\">var next = document.querySelector(&quot;div&quot;).previousSibling;</span><br><span class=\"line\"></span><br><span class=\"line\">// Getting the first child element</span><br><span class=\"line\">var child = document.querySelector(&quot;div&quot;).children[0];</span><br><span class=\"line\"></span><br><span class=\"line\">// Getting the last child</span><br><span class=\"line\">var last = document.querySelector(&quot;div&quot;).lastElementChild;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"添加和删除样式名（class-name\"><a href=\"#添加和删除样式名（class-name\" class=\"headerlink\" title=\"添加和删除样式名（class name)\"></a>添加和删除样式名（class name)</h3><p>JavaScript 示例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var element = document.querySelector(&quot;.some-class&quot;);</span><br><span class=\"line\">// Give class &quot;foo&quot; to the element</span><br><span class=\"line\">element.className = &quot;foo&quot;;</span><br><span class=\"line\">element.className += &quot; foo&quot;;</span><br></pre></td></tr></table></figure></p>\n<p>removeClass:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// removeClass, takes two params: element and classname</span><br><span class=\"line\">function removeClass(el, cls) &#123;</span><br><span class=\"line\">  var reg = new RegExp(&quot;(\\\\s|^)&quot; + cls + &quot;(\\\\s|$)&quot;);</span><br><span class=\"line\">  el.className = el.className.replace(reg, &quot; &quot;).replace(/(^\\s*)|(\\s*$)/g,&quot;&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">removeClass(element, &quot;foo&quot;);</span><br></pre></td></tr></table></figure></p>\n<p>hasClass:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// hasClass, takes two params: element and classname</span><br><span class=\"line\">function hasClass(el, cls) &#123;</span><br><span class=\"line\">  return el.className &amp;&amp; new RegExp(&quot;(\\\\s|^)&quot; + cls + &quot;(\\\\s|$)&quot;).test(el.className);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Check if an element has class &quot;foo&quot;</span><br><span class=\"line\">if (hasClass(element, &quot;foo&quot;)) &#123;</span><br><span class=\"line\">  // Show an alert message if it does</span><br><span class=\"line\">  alert(&quot;Element has the class!&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"HTML5-的-classList-API-简介\"><a href=\"#HTML5-的-classList-API-简介\" class=\"headerlink\" title=\"HTML5 的  classList API 简介\"></a>HTML5 的  classList API 简介</h3><p>检测出浏览器是否支持<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (&quot;classList&quot; in document.documentElement) &#123;</span><br><span class=\"line\">  // classList is supported, now do something with it</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>JavaScript 示例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Adding a class</span><br><span class=\"line\">element.classList.add(&quot;bar&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">// Removing a class</span><br><span class=\"line\">element.classList.remove(&quot;foo&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">// Checking if has a class</span><br><span class=\"line\">element.classList.contains(&quot;foo&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">// Toggle a class</span><br><span class=\"line\">element.classList.toggle(&quot;active&quot;);</span><br></pre></td></tr></table></figure></p>\n<p>代码对比：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;test&quot; class=&quot;one two three&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">var element = document.querySelector(&quot;#test&quot;);</span><br><span class=\"line\">addClass(element, &quot;two&quot;);</span><br><span class=\"line\">removeClass(element, &quot;four&quot;);</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;test&quot; class=&quot;one two three&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">var element = document.querySelector(&quot;#test&quot;);</span><br><span class=\"line\">element.classList.add(&quot;two&quot;);</span><br><span class=\"line\">element.classList.remove(&quot;four&quot;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"事件监听器\"><a href=\"#事件监听器\" class=\"headerlink\" title=\"事件监听器\"></a>事件监听器</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">element.addEventListener(&quot;click&quot;, function() &#123;</span><br><span class=\"line\">  alert(&quot;You clicked&quot;);</span><br><span class=\"line\">&#125;, false);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Select all links</span><br><span class=\"line\">var links = document.querySelectorAll(&quot;a&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">// For each link element</span><br><span class=\"line\">links.forEach.call(links, function(el) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  // Add event listener</span><br><span class=\"line\">  el.addEventListener(&quot;click&quot;, function(event) &#123;</span><br><span class=\"line\">    event.preventDefault();</span><br><span class=\"line\">    alert(&quot;You clicked&quot;);</span><br><span class=\"line\">  &#125;, false);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var button =  document.querySelector(&quot;#test&quot;);</span><br><span class=\"line\">var object = &#123;</span><br><span class=\"line\">  init: function() &#123;</span><br><span class=\"line\">    button.addEventListener(&quot;click&quot;, this, false);</span><br><span class=\"line\">    button.addEventListener(&quot;touchstart&quot;, this, false);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  handleEvent: function(e) &#123;</span><br><span class=\"line\">    switch(e.type) &#123;</span><br><span class=\"line\">      case &quot;click&quot;:</span><br><span class=\"line\">        this.action();</span><br><span class=\"line\">        break;</span><br><span class=\"line\">      case &quot;touchstart&quot;:</span><br><span class=\"line\">        this.action();</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  action: function() &#123;</span><br><span class=\"line\">    alert(&quot;Clicked or touched!&quot;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// Init</span><br><span class=\"line\">object.init();</span><br></pre></td></tr></table></figure>\n<h3 id=\"操作DOM\"><a href=\"#操作DOM\" class=\"headerlink\" title=\"操作DOM\"></a>操作DOM</h3><p>用纯JavaScript来操作DOM刚开始听起来就像一个可怕的想法，但比使用jQuery其实它并没有复杂多少。下面，我们会有一个例子，选择DOM的元素，克隆它，用JavaScript来操作克隆的样式，然后用被操纵的东西来替代原始的元素。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Select an element</span><br><span class=\"line\">var element = document.querySelector(&quot;.class&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">// Clone it</span><br><span class=\"line\">var clone = element.cloneNode(true);</span><br><span class=\"line\"></span><br><span class=\"line\">// Do some manipulation off the DOM</span><br><span class=\"line\">clone.style.background = &quot;#000&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// Replaces the original element with the new cloned one</span><br><span class=\"line\">element.parentNode.replaceChild(clone, element);</span><br></pre></td></tr></table></figure></p>\n<p>在DOM中，如果除了附加在<body>中新创建div，你不想替代任何东西，那么你可以这样做：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.body.appendChild(clone);</span><br></pre></td></tr></table></figure></body></p>\n<h3 id=\"在JS中决定响应图片的最大宽度\"><a href=\"#在JS中决定响应图片的最大宽度\" class=\"headerlink\" title=\"在JS中决定响应图片的最大宽度\"></a>在JS中决定响应图片的最大宽度</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var maxWidth = img.naturalWidth;</span><br></pre></td></tr></table></figure>\n<p>这将会给我们提供最大宽度100%像素的图片，且IE9,Chrome,Firefox,Safari和Opera都支持这个方法。我们也可以保留这个特性然后通过加载图片到内存中添加老浏览器的支持：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Get image&apos;s max-width:100%; in pixels</span><br><span class=\"line\">function getMaxWidth(img) &#123;</span><br><span class=\"line\">  var maxWidth;</span><br><span class=\"line\"></span><br><span class=\"line\">  // Check if naturalWidth is supported</span><br><span class=\"line\">  if (img.naturalWidth !== undefined) &#123;</span><br><span class=\"line\">    maxWidth = img.naturalWidth;</span><br><span class=\"line\"></span><br><span class=\"line\">  // Not supported, use in-memory solution as fallback</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    var image = new Image();</span><br><span class=\"line\">    image.src = img.src;</span><br><span class=\"line\">    maxWidth = image.width;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // Return the max-width</span><br><span class=\"line\">  return maxWidth;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>你应该注意到在检查宽度前，图片必须完全被加载。这是我们一直使用的用于确定它们有尺寸的方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function hasDimensions(img) &#123;</span><br><span class=\"line\">  return !!((img.complete &amp;&amp; typeof img.naturalWidth !== &quot;undefined&quot;) || img.width);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"判断一个元素是否在视图窗口中\"><a href=\"#判断一个元素是否在视图窗口中\" class=\"headerlink\" title=\"判断一个元素是否在视图窗口中:\"></a>判断一个元素是否在视图窗口中:</h3><p>通过使用getBoundingClientRect方法，你可以获取页面中任何元素的位置。以下是一个简单的函数来表明它有多简单和多强大。这个函数有一个参数，那就是你想要检查的元素。当元素为可见时，函数将返回true：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Determine if an element is in the visible viewport</span><br><span class=\"line\">function isInViewport(element) &#123;</span><br><span class=\"line\">  var rect = element.getBoundingClientRect();</span><br><span class=\"line\">  var html = document.documentElement;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    rect.top &gt;= 0 &amp;&amp;</span><br><span class=\"line\">    rect.left &gt;= 0 &amp;&amp;</span><br><span class=\"line\">    rect.bottom &lt;= (window.innerHeight || html.clientHeight) &amp;&amp;</span><br><span class=\"line\">    rect.right &lt;= (window.innerWidth || html.clientWidth)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>框架能够让我们走的更快，但只有了解原生的JS才能让我们走的更远。这里分享一些基础东西，这将可能帮你深入纯 JavaScript的世界，让你能更简单的做出决定——jQuery在你下个工程中是否需要。<br>","more":"</p>\n<blockquote>\n<p>从来没有一个js库能像jQuery这般影响着这个行业，她不仅改变了人们对JavaScript的传统认知，更让人们给予了她一种新的语言地位。jQuery在前端开发领域可真是被宠坏了，她的关注指数是js的两倍，有人说是她成就了js，也有人说是它害了js，而无论舆论偏向何方，我们都必须正视这门传奇的库。</p>\n</blockquote>\n<h3 id=\"Document-Ready-事件\"><a href=\"#Document-Ready-事件\" class=\"headerlink\" title=\"Document Ready 事件\"></a>Document Ready 事件</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"built_in\">document</span>).ready(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>JavaScript 示例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.addEventListener(&quot;DOMContentLoaded&quot;, function() &#123;</span><br><span class=\"line\">  // do something</span><br><span class=\"line\">&#125;, false);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"选择器\"><a href=\"#选择器\" class=\"headerlink\" title=\"选择器\"></a>选择器</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var el = $(&apos;div&apos;);</span><br></pre></td></tr></table></figure>\n<p>JavaScript 示例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var el = document.querySelector(&quot;div&quot;);</span><br><span class=\"line\">// var el = document.querySelectorAll(&quot;.container div&quot;);</span><br><span class=\"line\">var navigation = document.querySelector(&quot;nav&quot;);</span><br><span class=\"line\">var links = navigation.querySelectorAll(&quot;a&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// This gives us simple dollar function and event binding</span><br><span class=\"line\">var $ = document.querySelectorAll.bind(document);</span><br><span class=\"line\">Element.prototype.on = Element.prototype.addEventListener;</span><br><span class=\"line\"></span><br><span class=\"line\">// This is how you use it</span><br><span class=\"line\">$(&quot;.element&quot;)[0].on(&quot;touchstart&quot;, handleTouch, false);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"遍历DOM\"><a href=\"#遍历DOM\" class=\"headerlink\" title=\"遍历DOM\"></a>遍历DOM</h3><p>JavaScript 示例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Getting the parent node</span><br><span class=\"line\">var parent = document.querySelector(&quot;div&quot;).parentNode;</span><br><span class=\"line\"></span><br><span class=\"line\">// Getting the next node</span><br><span class=\"line\">var next = document.querySelector(&quot;div&quot;).nextSibling;</span><br><span class=\"line\"></span><br><span class=\"line\">// Getting the previous node</span><br><span class=\"line\">var next = document.querySelector(&quot;div&quot;).previousSibling;</span><br><span class=\"line\"></span><br><span class=\"line\">// Getting the first child element</span><br><span class=\"line\">var child = document.querySelector(&quot;div&quot;).children[0];</span><br><span class=\"line\"></span><br><span class=\"line\">// Getting the last child</span><br><span class=\"line\">var last = document.querySelector(&quot;div&quot;).lastElementChild;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"添加和删除样式名（class-name\"><a href=\"#添加和删除样式名（class-name\" class=\"headerlink\" title=\"添加和删除样式名（class name)\"></a>添加和删除样式名（class name)</h3><p>JavaScript 示例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var element = document.querySelector(&quot;.some-class&quot;);</span><br><span class=\"line\">// Give class &quot;foo&quot; to the element</span><br><span class=\"line\">element.className = &quot;foo&quot;;</span><br><span class=\"line\">element.className += &quot; foo&quot;;</span><br></pre></td></tr></table></figure></p>\n<p>removeClass:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// removeClass, takes two params: element and classname</span><br><span class=\"line\">function removeClass(el, cls) &#123;</span><br><span class=\"line\">  var reg = new RegExp(&quot;(\\\\s|^)&quot; + cls + &quot;(\\\\s|$)&quot;);</span><br><span class=\"line\">  el.className = el.className.replace(reg, &quot; &quot;).replace(/(^\\s*)|(\\s*$)/g,&quot;&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">removeClass(element, &quot;foo&quot;);</span><br></pre></td></tr></table></figure></p>\n<p>hasClass:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// hasClass, takes two params: element and classname</span><br><span class=\"line\">function hasClass(el, cls) &#123;</span><br><span class=\"line\">  return el.className &amp;&amp; new RegExp(&quot;(\\\\s|^)&quot; + cls + &quot;(\\\\s|$)&quot;).test(el.className);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Check if an element has class &quot;foo&quot;</span><br><span class=\"line\">if (hasClass(element, &quot;foo&quot;)) &#123;</span><br><span class=\"line\">  // Show an alert message if it does</span><br><span class=\"line\">  alert(&quot;Element has the class!&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"HTML5-的-classList-API-简介\"><a href=\"#HTML5-的-classList-API-简介\" class=\"headerlink\" title=\"HTML5 的  classList API 简介\"></a>HTML5 的  classList API 简介</h3><p>检测出浏览器是否支持<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (&quot;classList&quot; in document.documentElement) &#123;</span><br><span class=\"line\">  // classList is supported, now do something with it</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>JavaScript 示例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Adding a class</span><br><span class=\"line\">element.classList.add(&quot;bar&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">// Removing a class</span><br><span class=\"line\">element.classList.remove(&quot;foo&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">// Checking if has a class</span><br><span class=\"line\">element.classList.contains(&quot;foo&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">// Toggle a class</span><br><span class=\"line\">element.classList.toggle(&quot;active&quot;);</span><br></pre></td></tr></table></figure></p>\n<p>代码对比：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;test&quot; class=&quot;one two three&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">var element = document.querySelector(&quot;#test&quot;);</span><br><span class=\"line\">addClass(element, &quot;two&quot;);</span><br><span class=\"line\">removeClass(element, &quot;four&quot;);</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;test&quot; class=&quot;one two three&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">var element = document.querySelector(&quot;#test&quot;);</span><br><span class=\"line\">element.classList.add(&quot;two&quot;);</span><br><span class=\"line\">element.classList.remove(&quot;four&quot;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"事件监听器\"><a href=\"#事件监听器\" class=\"headerlink\" title=\"事件监听器\"></a>事件监听器</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">element.addEventListener(&quot;click&quot;, function() &#123;</span><br><span class=\"line\">  alert(&quot;You clicked&quot;);</span><br><span class=\"line\">&#125;, false);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Select all links</span><br><span class=\"line\">var links = document.querySelectorAll(&quot;a&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">// For each link element</span><br><span class=\"line\">links.forEach.call(links, function(el) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  // Add event listener</span><br><span class=\"line\">  el.addEventListener(&quot;click&quot;, function(event) &#123;</span><br><span class=\"line\">    event.preventDefault();</span><br><span class=\"line\">    alert(&quot;You clicked&quot;);</span><br><span class=\"line\">  &#125;, false);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var button =  document.querySelector(&quot;#test&quot;);</span><br><span class=\"line\">var object = &#123;</span><br><span class=\"line\">  init: function() &#123;</span><br><span class=\"line\">    button.addEventListener(&quot;click&quot;, this, false);</span><br><span class=\"line\">    button.addEventListener(&quot;touchstart&quot;, this, false);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  handleEvent: function(e) &#123;</span><br><span class=\"line\">    switch(e.type) &#123;</span><br><span class=\"line\">      case &quot;click&quot;:</span><br><span class=\"line\">        this.action();</span><br><span class=\"line\">        break;</span><br><span class=\"line\">      case &quot;touchstart&quot;:</span><br><span class=\"line\">        this.action();</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  action: function() &#123;</span><br><span class=\"line\">    alert(&quot;Clicked or touched!&quot;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// Init</span><br><span class=\"line\">object.init();</span><br></pre></td></tr></table></figure>\n<h3 id=\"操作DOM\"><a href=\"#操作DOM\" class=\"headerlink\" title=\"操作DOM\"></a>操作DOM</h3><p>用纯JavaScript来操作DOM刚开始听起来就像一个可怕的想法，但比使用jQuery其实它并没有复杂多少。下面，我们会有一个例子，选择DOM的元素，克隆它，用JavaScript来操作克隆的样式，然后用被操纵的东西来替代原始的元素。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Select an element</span><br><span class=\"line\">var element = document.querySelector(&quot;.class&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">// Clone it</span><br><span class=\"line\">var clone = element.cloneNode(true);</span><br><span class=\"line\"></span><br><span class=\"line\">// Do some manipulation off the DOM</span><br><span class=\"line\">clone.style.background = &quot;#000&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// Replaces the original element with the new cloned one</span><br><span class=\"line\">element.parentNode.replaceChild(clone, element);</span><br></pre></td></tr></table></figure></p>\n<p>在DOM中，如果除了附加在<body>中新创建div，你不想替代任何东西，那么你可以这样做：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.body.appendChild(clone);</span><br></pre></td></tr></table></figure></body></p>\n<h3 id=\"在JS中决定响应图片的最大宽度\"><a href=\"#在JS中决定响应图片的最大宽度\" class=\"headerlink\" title=\"在JS中决定响应图片的最大宽度\"></a>在JS中决定响应图片的最大宽度</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var maxWidth = img.naturalWidth;</span><br></pre></td></tr></table></figure>\n<p>这将会给我们提供最大宽度100%像素的图片，且IE9,Chrome,Firefox,Safari和Opera都支持这个方法。我们也可以保留这个特性然后通过加载图片到内存中添加老浏览器的支持：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Get image&apos;s max-width:100%; in pixels</span><br><span class=\"line\">function getMaxWidth(img) &#123;</span><br><span class=\"line\">  var maxWidth;</span><br><span class=\"line\"></span><br><span class=\"line\">  // Check if naturalWidth is supported</span><br><span class=\"line\">  if (img.naturalWidth !== undefined) &#123;</span><br><span class=\"line\">    maxWidth = img.naturalWidth;</span><br><span class=\"line\"></span><br><span class=\"line\">  // Not supported, use in-memory solution as fallback</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    var image = new Image();</span><br><span class=\"line\">    image.src = img.src;</span><br><span class=\"line\">    maxWidth = image.width;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // Return the max-width</span><br><span class=\"line\">  return maxWidth;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>你应该注意到在检查宽度前，图片必须完全被加载。这是我们一直使用的用于确定它们有尺寸的方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function hasDimensions(img) &#123;</span><br><span class=\"line\">  return !!((img.complete &amp;&amp; typeof img.naturalWidth !== &quot;undefined&quot;) || img.width);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"判断一个元素是否在视图窗口中\"><a href=\"#判断一个元素是否在视图窗口中\" class=\"headerlink\" title=\"判断一个元素是否在视图窗口中:\"></a>判断一个元素是否在视图窗口中:</h3><p>通过使用getBoundingClientRect方法，你可以获取页面中任何元素的位置。以下是一个简单的函数来表明它有多简单和多强大。这个函数有一个参数，那就是你想要检查的元素。当元素为可见时，函数将返回true：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Determine if an element is in the visible viewport</span><br><span class=\"line\">function isInViewport(element) &#123;</span><br><span class=\"line\">  var rect = element.getBoundingClientRect();</span><br><span class=\"line\">  var html = document.documentElement;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    rect.top &gt;= 0 &amp;&amp;</span><br><span class=\"line\">    rect.left &gt;= 0 &amp;&amp;</span><br><span class=\"line\">    rect.bottom &lt;= (window.innerHeight || html.clientHeight) &amp;&amp;</span><br><span class=\"line\">    rect.right &lt;= (window.innerWidth || html.clientWidth)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"搭建一个Hexo 博客","date":"2016-07-13T08:06:16.000Z","_content":"博客使用 Github + Hexo 实现并托管整个网站\n<!--more-->\nHexo 是一个优秀的静态博客生成器。至于怎么怎么好，这里就不在啰嗦了。\n\n## 准备工作\n* [Git](https://git-scm.com/book/zh/v2)\n* [Github](https://github.com/)\n* [Github Pages](https://pages.github.com/)\n* [nodejs](http://nodejs.org/)\n* [Hexo](https://hexo.io/)\n\n## 安装Hexo\n安装前确保电脑上已经安装：[nodejs](http://nodejs.org/)、[Git](https://git-scm.com/book/zh/v2)。\n使用npm 安装Hexo\n\n```\n$ npm install -g hexo-cli\n$ hexo init <folder>\n$ cd <folder>\n$ npm install\n```\n可以在项目目录下看到如下结构的文件：\n\n```\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n```\n\n打开_config.yml文件，你就可以配置自己的博客了。[官方文档](https://hexo.io/docs/configuration.html)\n站点配置用到两个文件，一个是对整站的配置 hexo\\_config.yml ，另一个是对主题的配置 hexo\\themes\\config.yml 。\nhexo\\_config.yml 文件如下：\n\n```\n# Hexo Configuration\n## Docs: http://zespia.tw/hexo/docs/configure.html\n## Source: https://github.com/tommy351/hexo/\n\n# Site 这里的配置，哪项配置反映在哪里，可以参考我的博客\ntitle: Xiaomiya's blog #站点名，站点左上角\nsubtitle: Walk steps step by step #副标题，站点左上角\ndescription: Walk steps step by step #给搜索引擎看的，对站点的描述，可以自定义\nauthor: xiaomiya#在站点左下角可以看到\nemail: #你的联系邮箱\nlanguage: zh-CN #中国人嘛，用中文\n\n# URL #这项暂不配置，绑定域名后，欲创建sitemap.xml需要配置该项\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nurl: http://yoursite.com\nroot: /\npermalink: :year/:month/:day/:title/\ntag_dir: tags\narchive_dir: archives\ncategory_dir: categories\n\n# Writing 文章布局、写作格式的定义，不修改\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post\nauto_spacing: false # Add spaces between asian characters and western characters\ntitlecase: false # Transform title into titlecase\nmax_open_file: 100\nfilename_case: 0\nhighlight:\n  enable: true\n  backtick_code_block: true\n  line_number: true\n  tab_replace:\n\n# Category & Tag\ndefault_category: uncategorized\ncategory_map:\ntag_map:\n\n# Archives 默认值为2，这里都修改为1，相应页面就只会列出标题，而非全文\n## 2: Enable pagination\n## 1: Disable pagination\n## 0: Fully Disable\narchive: 1\ncategory: 1\ntag: 1\n\n# Server 不修改\n## Hexo uses Connect as a server\n## You can customize the logger format as defined in\n## http://www.senchalabs.org/connect/logger.html\nport: 4000\nlogger: false\nlogger_format:\n\n# Date / Time format 日期格式，不修改\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: MMM D YYYY\ntime_format: H:mm:ss\n\n# Pagination 每页显示文章数，可以自定义，我将10改成了5\n## Set per_page to 0 to disable pagination\nper_page: 5\npagination_dir: page\n\n# Disqus Disqus插件，我们会替换成“多说”，不修改\ndisqus_shortname:\n\n# Extensions 这里配置站点所用主题和插件，暂默认，后面会介绍怎么修改\n## Plugins: https://github.com/tommy351/hexo/wiki/Plugins\n## Themes: https://github.com/tommy351/hexo/wiki/Themes\ntheme: light\nexclude_generator:\nplugins:\n- hexo-generator-feed\n- hexo-generator-sitemap\n\n# Deployment 站点部署到github要配置，上一节中已经讲过\n## Docs: http://zespia.tw/hexo/docs/deploy.html\ndeploy:\n  type: github\n  repository: https://github.com/xiaomiya/xiaomiya.github.com.git\n  branch: master\n```\n\n  现在可以 hexo generate ， hexo server ，打开 localhost:4000 查看效果了。\n\n\nhexo\\themes\\config.yml\n\n```\nmenu: #站点右上角导航栏，暂时默认，后面介绍修改\n  首页: /\n  存档: /archives\n  关于: /about\n  ToDo: /todolist\n  \n\nwidgets: #站点右边栏，暂时默认，后面介绍修改和添加\n- search\n- category\n- tagcloud\n- weibo\n- blogroll\n\n\nexcerpt_link: 阅读全文 #替换为中文\n\nplugins: \n\n\ntwitter: #右边栏要显示twitter展示的话，需要在此设置\n  username: moxie198\n  show_replies: false\n  tweet_count: 5\n\naddthis: #SNS分享，身在天朝，当然用“百度分享”，暂时默认，后面会介绍\n  enable: true\n  pubid:\n  facebook: true\n  twitter: true\n  google: true\n  pinterest: true\n\nfancybox: true #图片效果，默认\n\ngoogle_analytics: #要使用google_analytics进行统计的话，这里需要配置ID，暂时默认，后面介绍\nrss:  #生成RSS，需要配置路径，暂时默认，后面介绍\n```\n为了能够使Hexo部署到GitHub上，需要安装一个插件：(在执行 hexo deploy 后,出现 error deployer not found:github 的错误也是这个原因。)\n\n\n```\n$ npm install hexo-deployer-git --save\n```\n\n下面是一些常用命令\n```\nhexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\nhexo deploy #将.deploy目录部署到GitHub\n```\n常用复合命令：\n\n```\nhexo deploy -g\nhexo server -g\n```\n\n简写：\n```\nhexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy\n```","source":"_posts/搭建一个Hexo博客.md","raw":"---\ntitle: 搭建一个Hexo 博客\ndate: 2016-07-13 16:06:16\ntags: Hexo\ncategory: 前端\n---\n博客使用 Github + Hexo 实现并托管整个网站\n<!--more-->\nHexo 是一个优秀的静态博客生成器。至于怎么怎么好，这里就不在啰嗦了。\n\n## 准备工作\n* [Git](https://git-scm.com/book/zh/v2)\n* [Github](https://github.com/)\n* [Github Pages](https://pages.github.com/)\n* [nodejs](http://nodejs.org/)\n* [Hexo](https://hexo.io/)\n\n## 安装Hexo\n安装前确保电脑上已经安装：[nodejs](http://nodejs.org/)、[Git](https://git-scm.com/book/zh/v2)。\n使用npm 安装Hexo\n\n```\n$ npm install -g hexo-cli\n$ hexo init <folder>\n$ cd <folder>\n$ npm install\n```\n可以在项目目录下看到如下结构的文件：\n\n```\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n```\n\n打开_config.yml文件，你就可以配置自己的博客了。[官方文档](https://hexo.io/docs/configuration.html)\n站点配置用到两个文件，一个是对整站的配置 hexo\\_config.yml ，另一个是对主题的配置 hexo\\themes\\config.yml 。\nhexo\\_config.yml 文件如下：\n\n```\n# Hexo Configuration\n## Docs: http://zespia.tw/hexo/docs/configure.html\n## Source: https://github.com/tommy351/hexo/\n\n# Site 这里的配置，哪项配置反映在哪里，可以参考我的博客\ntitle: Xiaomiya's blog #站点名，站点左上角\nsubtitle: Walk steps step by step #副标题，站点左上角\ndescription: Walk steps step by step #给搜索引擎看的，对站点的描述，可以自定义\nauthor: xiaomiya#在站点左下角可以看到\nemail: #你的联系邮箱\nlanguage: zh-CN #中国人嘛，用中文\n\n# URL #这项暂不配置，绑定域名后，欲创建sitemap.xml需要配置该项\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nurl: http://yoursite.com\nroot: /\npermalink: :year/:month/:day/:title/\ntag_dir: tags\narchive_dir: archives\ncategory_dir: categories\n\n# Writing 文章布局、写作格式的定义，不修改\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post\nauto_spacing: false # Add spaces between asian characters and western characters\ntitlecase: false # Transform title into titlecase\nmax_open_file: 100\nfilename_case: 0\nhighlight:\n  enable: true\n  backtick_code_block: true\n  line_number: true\n  tab_replace:\n\n# Category & Tag\ndefault_category: uncategorized\ncategory_map:\ntag_map:\n\n# Archives 默认值为2，这里都修改为1，相应页面就只会列出标题，而非全文\n## 2: Enable pagination\n## 1: Disable pagination\n## 0: Fully Disable\narchive: 1\ncategory: 1\ntag: 1\n\n# Server 不修改\n## Hexo uses Connect as a server\n## You can customize the logger format as defined in\n## http://www.senchalabs.org/connect/logger.html\nport: 4000\nlogger: false\nlogger_format:\n\n# Date / Time format 日期格式，不修改\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: MMM D YYYY\ntime_format: H:mm:ss\n\n# Pagination 每页显示文章数，可以自定义，我将10改成了5\n## Set per_page to 0 to disable pagination\nper_page: 5\npagination_dir: page\n\n# Disqus Disqus插件，我们会替换成“多说”，不修改\ndisqus_shortname:\n\n# Extensions 这里配置站点所用主题和插件，暂默认，后面会介绍怎么修改\n## Plugins: https://github.com/tommy351/hexo/wiki/Plugins\n## Themes: https://github.com/tommy351/hexo/wiki/Themes\ntheme: light\nexclude_generator:\nplugins:\n- hexo-generator-feed\n- hexo-generator-sitemap\n\n# Deployment 站点部署到github要配置，上一节中已经讲过\n## Docs: http://zespia.tw/hexo/docs/deploy.html\ndeploy:\n  type: github\n  repository: https://github.com/xiaomiya/xiaomiya.github.com.git\n  branch: master\n```\n\n  现在可以 hexo generate ， hexo server ，打开 localhost:4000 查看效果了。\n\n\nhexo\\themes\\config.yml\n\n```\nmenu: #站点右上角导航栏，暂时默认，后面介绍修改\n  首页: /\n  存档: /archives\n  关于: /about\n  ToDo: /todolist\n  \n\nwidgets: #站点右边栏，暂时默认，后面介绍修改和添加\n- search\n- category\n- tagcloud\n- weibo\n- blogroll\n\n\nexcerpt_link: 阅读全文 #替换为中文\n\nplugins: \n\n\ntwitter: #右边栏要显示twitter展示的话，需要在此设置\n  username: moxie198\n  show_replies: false\n  tweet_count: 5\n\naddthis: #SNS分享，身在天朝，当然用“百度分享”，暂时默认，后面会介绍\n  enable: true\n  pubid:\n  facebook: true\n  twitter: true\n  google: true\n  pinterest: true\n\nfancybox: true #图片效果，默认\n\ngoogle_analytics: #要使用google_analytics进行统计的话，这里需要配置ID，暂时默认，后面介绍\nrss:  #生成RSS，需要配置路径，暂时默认，后面介绍\n```\n为了能够使Hexo部署到GitHub上，需要安装一个插件：(在执行 hexo deploy 后,出现 error deployer not found:github 的错误也是这个原因。)\n\n\n```\n$ npm install hexo-deployer-git --save\n```\n\n下面是一些常用命令\n```\nhexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\nhexo deploy #将.deploy目录部署到GitHub\n```\n常用复合命令：\n\n```\nhexo deploy -g\nhexo server -g\n```\n\n简写：\n```\nhexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy\n```","slug":"搭建一个Hexo博客","published":1,"updated":"2019-03-21T03:42:03.284Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtifjptc000nlohi3vo6w05x","content":"<p>博客使用 Github + Hexo 实现并托管整个网站<br><a id=\"more\"></a><br>Hexo 是一个优秀的静态博客生成器。至于怎么怎么好，这里就不在啰嗦了。</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><ul>\n<li><a href=\"https://git-scm.com/book/zh/v2\" target=\"_blank\" rel=\"noopener\">Git</a></li>\n<li><a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">Github</a></li>\n<li><a href=\"https://pages.github.com/\" target=\"_blank\" rel=\"noopener\">Github Pages</a></li>\n<li><a href=\"http://nodejs.org/\" target=\"_blank\" rel=\"noopener\">nodejs</a></li>\n<li><a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a></li>\n</ul>\n<h2 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h2><p>安装前确保电脑上已经安装：<a href=\"http://nodejs.org/\" target=\"_blank\" rel=\"noopener\">nodejs</a>、<a href=\"https://git-scm.com/book/zh/v2\" target=\"_blank\" rel=\"noopener\">Git</a>。<br>使用npm 安装Hexo</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br><span class=\"line\">$ hexo init &lt;folder&gt;</span><br><span class=\"line\">$ cd &lt;folder&gt;</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n<p>可以在项目目录下看到如下结构的文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── _config.yml</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── scaffolds</span><br><span class=\"line\">├── source</span><br><span class=\"line\">|   ├── _drafts</span><br><span class=\"line\">|   └── _posts</span><br><span class=\"line\">└── themes</span><br></pre></td></tr></table></figure>\n<p>打开_config.yml文件，你就可以配置自己的博客了。<a href=\"https://hexo.io/docs/configuration.html\" target=\"_blank\" rel=\"noopener\">官方文档</a><br>站点配置用到两个文件，一个是对整站的配置 hexo_config.yml ，另一个是对主题的配置 hexo\\themes\\config.yml 。<br>hexo_config.yml 文件如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Hexo Configuration</span><br><span class=\"line\">## Docs: http://zespia.tw/hexo/docs/configure.html</span><br><span class=\"line\">## Source: https://github.com/tommy351/hexo/</span><br><span class=\"line\"></span><br><span class=\"line\"># Site 这里的配置，哪项配置反映在哪里，可以参考我的博客</span><br><span class=\"line\">title: Xiaomiya&apos;s blog #站点名，站点左上角</span><br><span class=\"line\">subtitle: Walk steps step by step #副标题，站点左上角</span><br><span class=\"line\">description: Walk steps step by step #给搜索引擎看的，对站点的描述，可以自定义</span><br><span class=\"line\">author: xiaomiya#在站点左下角可以看到</span><br><span class=\"line\">email: #你的联系邮箱</span><br><span class=\"line\">language: zh-CN #中国人嘛，用中文</span><br><span class=\"line\"></span><br><span class=\"line\"># URL #这项暂不配置，绑定域名后，欲创建sitemap.xml需要配置该项</span><br><span class=\"line\">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class=\"line\">url: http://yoursite.com</span><br><span class=\"line\">root: /</span><br><span class=\"line\">permalink: :year/:month/:day/:title/</span><br><span class=\"line\">tag_dir: tags</span><br><span class=\"line\">archive_dir: archives</span><br><span class=\"line\">category_dir: categories</span><br><span class=\"line\"></span><br><span class=\"line\"># Writing 文章布局、写作格式的定义，不修改</span><br><span class=\"line\">new_post_name: :title.md # File name of new posts</span><br><span class=\"line\">default_layout: post</span><br><span class=\"line\">auto_spacing: false # Add spaces between asian characters and western characters</span><br><span class=\"line\">titlecase: false # Transform title into titlecase</span><br><span class=\"line\">max_open_file: 100</span><br><span class=\"line\">filename_case: 0</span><br><span class=\"line\">highlight:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  backtick_code_block: true</span><br><span class=\"line\">  line_number: true</span><br><span class=\"line\">  tab_replace:</span><br><span class=\"line\"></span><br><span class=\"line\"># Category &amp; Tag</span><br><span class=\"line\">default_category: uncategorized</span><br><span class=\"line\">category_map:</span><br><span class=\"line\">tag_map:</span><br><span class=\"line\"></span><br><span class=\"line\"># Archives 默认值为2，这里都修改为1，相应页面就只会列出标题，而非全文</span><br><span class=\"line\">## 2: Enable pagination</span><br><span class=\"line\">## 1: Disable pagination</span><br><span class=\"line\">## 0: Fully Disable</span><br><span class=\"line\">archive: 1</span><br><span class=\"line\">category: 1</span><br><span class=\"line\">tag: 1</span><br><span class=\"line\"></span><br><span class=\"line\"># Server 不修改</span><br><span class=\"line\">## Hexo uses Connect as a server</span><br><span class=\"line\">## You can customize the logger format as defined in</span><br><span class=\"line\">## http://www.senchalabs.org/connect/logger.html</span><br><span class=\"line\">port: 4000</span><br><span class=\"line\">logger: false</span><br><span class=\"line\">logger_format:</span><br><span class=\"line\"></span><br><span class=\"line\"># Date / Time format 日期格式，不修改</span><br><span class=\"line\">## Hexo uses Moment.js to parse and display date</span><br><span class=\"line\">## You can customize the date format as defined in</span><br><span class=\"line\">## http://momentjs.com/docs/#/displaying/format/</span><br><span class=\"line\">date_format: MMM D YYYY</span><br><span class=\"line\">time_format: H:mm:ss</span><br><span class=\"line\"></span><br><span class=\"line\"># Pagination 每页显示文章数，可以自定义，我将10改成了5</span><br><span class=\"line\">## Set per_page to 0 to disable pagination</span><br><span class=\"line\">per_page: 5</span><br><span class=\"line\">pagination_dir: page</span><br><span class=\"line\"></span><br><span class=\"line\"># Disqus Disqus插件，我们会替换成“多说”，不修改</span><br><span class=\"line\">disqus_shortname:</span><br><span class=\"line\"></span><br><span class=\"line\"># Extensions 这里配置站点所用主题和插件，暂默认，后面会介绍怎么修改</span><br><span class=\"line\">## Plugins: https://github.com/tommy351/hexo/wiki/Plugins</span><br><span class=\"line\">## Themes: https://github.com/tommy351/hexo/wiki/Themes</span><br><span class=\"line\">theme: light</span><br><span class=\"line\">exclude_generator:</span><br><span class=\"line\">plugins:</span><br><span class=\"line\">- hexo-generator-feed</span><br><span class=\"line\">- hexo-generator-sitemap</span><br><span class=\"line\"></span><br><span class=\"line\"># Deployment 站点部署到github要配置，上一节中已经讲过</span><br><span class=\"line\">## Docs: http://zespia.tw/hexo/docs/deploy.html</span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  type: github</span><br><span class=\"line\">  repository: https://github.com/xiaomiya/xiaomiya.github.com.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n<p>  现在可以 hexo generate ， hexo server ，打开 localhost:4000 查看效果了。</p>\n<p>hexo\\themes\\config.yml</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu: #站点右上角导航栏，暂时默认，后面介绍修改</span><br><span class=\"line\">  首页: /</span><br><span class=\"line\">  存档: /archives</span><br><span class=\"line\">  关于: /about</span><br><span class=\"line\">  ToDo: /todolist</span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">widgets: #站点右边栏，暂时默认，后面介绍修改和添加</span><br><span class=\"line\">- search</span><br><span class=\"line\">- category</span><br><span class=\"line\">- tagcloud</span><br><span class=\"line\">- weibo</span><br><span class=\"line\">- blogroll</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">excerpt_link: 阅读全文 #替换为中文</span><br><span class=\"line\"></span><br><span class=\"line\">plugins: </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">twitter: #右边栏要显示twitter展示的话，需要在此设置</span><br><span class=\"line\">  username: moxie198</span><br><span class=\"line\">  show_replies: false</span><br><span class=\"line\">  tweet_count: 5</span><br><span class=\"line\"></span><br><span class=\"line\">addthis: #SNS分享，身在天朝，当然用“百度分享”，暂时默认，后面会介绍</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  pubid:</span><br><span class=\"line\">  facebook: true</span><br><span class=\"line\">  twitter: true</span><br><span class=\"line\">  google: true</span><br><span class=\"line\">  pinterest: true</span><br><span class=\"line\"></span><br><span class=\"line\">fancybox: true #图片效果，默认</span><br><span class=\"line\"></span><br><span class=\"line\">google_analytics: #要使用google_analytics进行统计的话，这里需要配置ID，暂时默认，后面介绍</span><br><span class=\"line\">rss:  #生成RSS，需要配置路径，暂时默认，后面介绍</span><br></pre></td></tr></table></figure>\n<p>为了能够使Hexo部署到GitHub上，需要安装一个插件：(在执行 hexo deploy 后,出现 error deployer not found:github 的错误也是这个原因。)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n<p>下面是一些常用命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new &quot;postName&quot; #新建文章</span><br><span class=\"line\">hexo new page &quot;pageName&quot; #新建页面</span><br><span class=\"line\">hexo generate #生成静态页面至public目录</span><br><span class=\"line\">hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）</span><br><span class=\"line\">hexo deploy #将.deploy目录部署到GitHub</span><br></pre></td></tr></table></figure></p>\n<p>常用复合命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo deploy -g</span><br><span class=\"line\">hexo server -g</span><br></pre></td></tr></table></figure>\n<p>简写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo n == hexo new</span><br><span class=\"line\">hexo g == hexo generate</span><br><span class=\"line\">hexo s == hexo server</span><br><span class=\"line\">hexo d == hexo deploy</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>博客使用 Github + Hexo 实现并托管整个网站<br>","more":"<br>Hexo 是一个优秀的静态博客生成器。至于怎么怎么好，这里就不在啰嗦了。</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><ul>\n<li><a href=\"https://git-scm.com/book/zh/v2\" target=\"_blank\" rel=\"noopener\">Git</a></li>\n<li><a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">Github</a></li>\n<li><a href=\"https://pages.github.com/\" target=\"_blank\" rel=\"noopener\">Github Pages</a></li>\n<li><a href=\"http://nodejs.org/\" target=\"_blank\" rel=\"noopener\">nodejs</a></li>\n<li><a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a></li>\n</ul>\n<h2 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h2><p>安装前确保电脑上已经安装：<a href=\"http://nodejs.org/\" target=\"_blank\" rel=\"noopener\">nodejs</a>、<a href=\"https://git-scm.com/book/zh/v2\" target=\"_blank\" rel=\"noopener\">Git</a>。<br>使用npm 安装Hexo</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br><span class=\"line\">$ hexo init &lt;folder&gt;</span><br><span class=\"line\">$ cd &lt;folder&gt;</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n<p>可以在项目目录下看到如下结构的文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── _config.yml</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── scaffolds</span><br><span class=\"line\">├── source</span><br><span class=\"line\">|   ├── _drafts</span><br><span class=\"line\">|   └── _posts</span><br><span class=\"line\">└── themes</span><br></pre></td></tr></table></figure>\n<p>打开_config.yml文件，你就可以配置自己的博客了。<a href=\"https://hexo.io/docs/configuration.html\" target=\"_blank\" rel=\"noopener\">官方文档</a><br>站点配置用到两个文件，一个是对整站的配置 hexo_config.yml ，另一个是对主题的配置 hexo\\themes\\config.yml 。<br>hexo_config.yml 文件如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Hexo Configuration</span><br><span class=\"line\">## Docs: http://zespia.tw/hexo/docs/configure.html</span><br><span class=\"line\">## Source: https://github.com/tommy351/hexo/</span><br><span class=\"line\"></span><br><span class=\"line\"># Site 这里的配置，哪项配置反映在哪里，可以参考我的博客</span><br><span class=\"line\">title: Xiaomiya&apos;s blog #站点名，站点左上角</span><br><span class=\"line\">subtitle: Walk steps step by step #副标题，站点左上角</span><br><span class=\"line\">description: Walk steps step by step #给搜索引擎看的，对站点的描述，可以自定义</span><br><span class=\"line\">author: xiaomiya#在站点左下角可以看到</span><br><span class=\"line\">email: #你的联系邮箱</span><br><span class=\"line\">language: zh-CN #中国人嘛，用中文</span><br><span class=\"line\"></span><br><span class=\"line\"># URL #这项暂不配置，绑定域名后，欲创建sitemap.xml需要配置该项</span><br><span class=\"line\">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class=\"line\">url: http://yoursite.com</span><br><span class=\"line\">root: /</span><br><span class=\"line\">permalink: :year/:month/:day/:title/</span><br><span class=\"line\">tag_dir: tags</span><br><span class=\"line\">archive_dir: archives</span><br><span class=\"line\">category_dir: categories</span><br><span class=\"line\"></span><br><span class=\"line\"># Writing 文章布局、写作格式的定义，不修改</span><br><span class=\"line\">new_post_name: :title.md # File name of new posts</span><br><span class=\"line\">default_layout: post</span><br><span class=\"line\">auto_spacing: false # Add spaces between asian characters and western characters</span><br><span class=\"line\">titlecase: false # Transform title into titlecase</span><br><span class=\"line\">max_open_file: 100</span><br><span class=\"line\">filename_case: 0</span><br><span class=\"line\">highlight:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  backtick_code_block: true</span><br><span class=\"line\">  line_number: true</span><br><span class=\"line\">  tab_replace:</span><br><span class=\"line\"></span><br><span class=\"line\"># Category &amp; Tag</span><br><span class=\"line\">default_category: uncategorized</span><br><span class=\"line\">category_map:</span><br><span class=\"line\">tag_map:</span><br><span class=\"line\"></span><br><span class=\"line\"># Archives 默认值为2，这里都修改为1，相应页面就只会列出标题，而非全文</span><br><span class=\"line\">## 2: Enable pagination</span><br><span class=\"line\">## 1: Disable pagination</span><br><span class=\"line\">## 0: Fully Disable</span><br><span class=\"line\">archive: 1</span><br><span class=\"line\">category: 1</span><br><span class=\"line\">tag: 1</span><br><span class=\"line\"></span><br><span class=\"line\"># Server 不修改</span><br><span class=\"line\">## Hexo uses Connect as a server</span><br><span class=\"line\">## You can customize the logger format as defined in</span><br><span class=\"line\">## http://www.senchalabs.org/connect/logger.html</span><br><span class=\"line\">port: 4000</span><br><span class=\"line\">logger: false</span><br><span class=\"line\">logger_format:</span><br><span class=\"line\"></span><br><span class=\"line\"># Date / Time format 日期格式，不修改</span><br><span class=\"line\">## Hexo uses Moment.js to parse and display date</span><br><span class=\"line\">## You can customize the date format as defined in</span><br><span class=\"line\">## http://momentjs.com/docs/#/displaying/format/</span><br><span class=\"line\">date_format: MMM D YYYY</span><br><span class=\"line\">time_format: H:mm:ss</span><br><span class=\"line\"></span><br><span class=\"line\"># Pagination 每页显示文章数，可以自定义，我将10改成了5</span><br><span class=\"line\">## Set per_page to 0 to disable pagination</span><br><span class=\"line\">per_page: 5</span><br><span class=\"line\">pagination_dir: page</span><br><span class=\"line\"></span><br><span class=\"line\"># Disqus Disqus插件，我们会替换成“多说”，不修改</span><br><span class=\"line\">disqus_shortname:</span><br><span class=\"line\"></span><br><span class=\"line\"># Extensions 这里配置站点所用主题和插件，暂默认，后面会介绍怎么修改</span><br><span class=\"line\">## Plugins: https://github.com/tommy351/hexo/wiki/Plugins</span><br><span class=\"line\">## Themes: https://github.com/tommy351/hexo/wiki/Themes</span><br><span class=\"line\">theme: light</span><br><span class=\"line\">exclude_generator:</span><br><span class=\"line\">plugins:</span><br><span class=\"line\">- hexo-generator-feed</span><br><span class=\"line\">- hexo-generator-sitemap</span><br><span class=\"line\"></span><br><span class=\"line\"># Deployment 站点部署到github要配置，上一节中已经讲过</span><br><span class=\"line\">## Docs: http://zespia.tw/hexo/docs/deploy.html</span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  type: github</span><br><span class=\"line\">  repository: https://github.com/xiaomiya/xiaomiya.github.com.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n<p>  现在可以 hexo generate ， hexo server ，打开 localhost:4000 查看效果了。</p>\n<p>hexo\\themes\\config.yml</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu: #站点右上角导航栏，暂时默认，后面介绍修改</span><br><span class=\"line\">  首页: /</span><br><span class=\"line\">  存档: /archives</span><br><span class=\"line\">  关于: /about</span><br><span class=\"line\">  ToDo: /todolist</span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">widgets: #站点右边栏，暂时默认，后面介绍修改和添加</span><br><span class=\"line\">- search</span><br><span class=\"line\">- category</span><br><span class=\"line\">- tagcloud</span><br><span class=\"line\">- weibo</span><br><span class=\"line\">- blogroll</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">excerpt_link: 阅读全文 #替换为中文</span><br><span class=\"line\"></span><br><span class=\"line\">plugins: </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">twitter: #右边栏要显示twitter展示的话，需要在此设置</span><br><span class=\"line\">  username: moxie198</span><br><span class=\"line\">  show_replies: false</span><br><span class=\"line\">  tweet_count: 5</span><br><span class=\"line\"></span><br><span class=\"line\">addthis: #SNS分享，身在天朝，当然用“百度分享”，暂时默认，后面会介绍</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  pubid:</span><br><span class=\"line\">  facebook: true</span><br><span class=\"line\">  twitter: true</span><br><span class=\"line\">  google: true</span><br><span class=\"line\">  pinterest: true</span><br><span class=\"line\"></span><br><span class=\"line\">fancybox: true #图片效果，默认</span><br><span class=\"line\"></span><br><span class=\"line\">google_analytics: #要使用google_analytics进行统计的话，这里需要配置ID，暂时默认，后面介绍</span><br><span class=\"line\">rss:  #生成RSS，需要配置路径，暂时默认，后面介绍</span><br></pre></td></tr></table></figure>\n<p>为了能够使Hexo部署到GitHub上，需要安装一个插件：(在执行 hexo deploy 后,出现 error deployer not found:github 的错误也是这个原因。)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n<p>下面是一些常用命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new &quot;postName&quot; #新建文章</span><br><span class=\"line\">hexo new page &quot;pageName&quot; #新建页面</span><br><span class=\"line\">hexo generate #生成静态页面至public目录</span><br><span class=\"line\">hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）</span><br><span class=\"line\">hexo deploy #将.deploy目录部署到GitHub</span><br></pre></td></tr></table></figure></p>\n<p>常用复合命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo deploy -g</span><br><span class=\"line\">hexo server -g</span><br></pre></td></tr></table></figure>\n<p>简写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo n == hexo new</span><br><span class=\"line\">hexo g == hexo generate</span><br><span class=\"line\">hexo s == hexo server</span><br><span class=\"line\">hexo d == hexo deploy</span><br></pre></td></tr></table></figure></p>"},{"title":"Git 使用说明","date":"2016-07-11T09:09:08.000Z","_content":"git——现在的火爆程度非同一般，它被广泛地用在大型开源项目，团队开发，以及独立开发者，甚至学生之中。 \n<!--more-->\n初学者非常容易被各种命令，参数吓哭。但实际上刚上手你并不需要了解所有命令的用途。你可以从掌握一些简单，强大的命令开始，逐步去学习。（这就是这篇文章要讲的）。好了，上来！\n![30分钟git命令入门到放弃](http://oa59b6bv6.bkt.clouddn.com/git1.webp)\n\n## learn-git\n\n### 基本了解\n\ngit命令是一些命令行工具的集合，它可以用来跟踪，记录文件的变动。比如你可以进行保存，比对，分析，合并等等。这个过程被称之为版本控制。已经有一系列的版本控制系统，比如SVN, Mercurial, Perforce, CVS, Bitkeepe等等。\n\nGit是分布式的，这意味着它并不依赖于中心服务器，任何一台机器都可以有一个本地版本的控制系统，我们称之为仓库。如果是多人协作的话，你需要还需要一个线上仓库，用来同步信息。这就是GitHub, BitBucket的工作。\n\n\n1. 安装Git\n安装git非常直接：\n* Linux - 打开控制台，然后通过包管理安装，在Ubuntu上命令是：\n\n``` javascript\n$ sudo apt-get install git-all\n```\n\n* Windows - 推荐使用git for windows，它包括了图形工具以及命令行模拟器。\n\n* OS X - 最简单的方式是使用homebrew安装，命令行执行\n\n``` javascript\n$ brew install git\n```\n如果你是在是先用图形工具的话，那么推荐你使用Github desktop,Sourcetree。但我还是推荐你使用命令行，下面的内容就都是命令行的。\n\n2. 配置Git\n安装完git,首要任务是配置我们的信息，最重要的是用户名及邮箱，打开终端，执行以下命令。\n\n``` javascript\n$ git config --global user.name \"My Name\"\n$ git config --global user.email myEmail@example.com\n```\n配置好这两项，用户就能知道谁做了什么，并且一切都更有组织性了不是吗？\n\n3. 创建一个新仓库 - git init\ngit 会把所有文件以及历史记录保存在你的项目中，创建一个新的仓库，首先要去到项目路径，执行 git \ninit。然后git会创建一个隐藏的文件夹.git，所有的信息都储存在其中。\n在桌面创建一个联系文件夹 git_exercise, 打开终端：\n\n``` javascript\n$ cd Desktop/git_exercise/\n$ git init\n```\nOK，现在项目还什么都没有，新建一个 hello.txt 文件试试~\n\n4. 检查状态 - git status\ngit status 是另一个非常重要的命令，它会告诉我们创库的当前状态：是否为最新代码，有什么更新等等执行git status:\n\n``` javascript\n$ git status\n\nOn branch master\n\nInitial commit\n\nUntracked files:\n  (use \"git add ...\" to include in what will be committed)\n\n\thello.txt\n```\ngit 告诉我们，hello.txt尚未跟踪，这是因为这个文件是新的，git不知道是应该跟踪它的变动呢，还是直接忽略不管呢。为了跟踪我们的新文件，我们需要暂存它。\n\n5. 暂存 - git add\ngit 有个概念叫暂存区，你可以把它看成一块空白帆布，包裹着所有你可能会提交的变动。它一开始为空，你可以通过 git add 命令添加内容，并使用 git commit \n提交。\n这个例子中只有一个文件：\n\n``` javascript\n$ git add hello.txt\n```\n如果需要提交目录下的所有内容，可以这样：\n\n``` javascript\n$ git add -A\n```\n再次使用git status查看：\n\n``` javascript\n$ git status\n\nOn branch master\n\nInitial commit\n\nChanges to be committed:\n  (use \"git rm --cached ...\" to unstage)\n\n\tnew file:   hello.txt\n```\n我们的文件已经提交了。状态信息还会告诉我们暂存区文件发生了什么变动，不过这里我们提交的是一个全新文件。\n\n6. 提交 - git commit\n一次提交代表着我们的仓库到了一个交付状态，通常是完成了某一块小功能。它就像是一个快照，允许我们像使用时光机一样回到旧时光。\n创建提交，需要我们提交东西到暂存区（git add），然后：\n\n``` javascript\n$ git commit -m \"Initial commit.\"\n```\n这就创建了一次提交，-m \n“Initial commit.”表示对这次提交的描述，建议使用有意义的描述性信息。\n\n## 远端仓库\n到目前为止，我们的操作都是在本地的，它存在于.git文件中。为了能够协同开发，我们需要把代码发布到远端仓库上。\n1. 链接远端仓库 - git remote add\n为了能够上传到远端仓库，我们需要先建立起链接，这篇教程中，远端仓库的地址为：https://github.com/tutorialzine/awesome-project,但你应该自己在Github, \nBitBucket上搭建仓库，自己一步一步尝试。\n添加测试用的远端仓库\n\n``` javascript\n$ git remote add origin https://github.com/tutorialzine/awesome-project.git\n```\n一个项目可以同时拥有好几个远端仓库为了能够区分，通常会起不同的名字。通常主远端仓库被称为origin。\n\n2. 上传到服务器 - git push\n每次我们要提交代码到服务器上时，都会使用到git push。\ngit push命令会有两个参数，远端仓库的名字，以及分支的名字：\n\n``` javascript\n$ git push origin master\n\nCounting objects: 3, done.\nWriting objects: 100% (3/3), 212 bytes | 0 bytes/s, done.\nTotal 3 (delta 0), reused 0 (delta 0)\nTo https://github.com/tutorialzine/awesome-project.git\n * [new branch]      master -> master\n```\n取决于你使用的服务器，push过程你可能需要验证身份。如果没有出差错，现在使用浏览器去你的远端分支上看，hello.txt已经在那里等着你了。\n\n3. 克隆仓库 - git clone\n放在Github上的开源项目，人们可以看到你的代码。可以使用 git clone进行下载到本地。\n\n``` javascript\n$ git clone https://github.com/tutorialzine/awesome-project.git\n```\n本地也会创建一个新的仓库，并自动将github上的分支设为远端分支。\n\n4. 从服务器上拉取代码 - git pull\n如果你更新了代码到仓库上，其他人可以通过git pull命令拉取你的变动：\n\n``` javascript\n$ git pull origin master\nFrom https://github.com/tutorialzine/awesome-project\n * branch            master     -> FETCH_HEAD\nAlready up-to-date.\n```\n因为暂时没有其他人提交，所有没有任何变动分支\n![branchs](http://oa59b6bv6.bkt.clouddn.com/git2.webp)\nbranchs\n\n当你在做一个新功能的时候，最好是在一个独立的区域上开发，通常称之为分支。分支之间相互独立，并且拥有自己的历史记录。这样做的原因是：\n* 稳定版本的代码不会被破坏\n* 不同的功能可以由不同开发者同时开发。\n* 开发者可以专注于自己的分支，不用担心被其他人破坏了环境\n* 在不确定之前，同一个特性可以拥有几个版本，便于比较\n\n1. 创建新分支 - git branch\n每一个仓库的默认分支都叫master, 创建新分支可以这样：\n\n``` javascript\n$ git branch amazing_new_feature\n```\n创建了一个名为amazing_new_feature的新分支，它跟当前分支同一起点\n\n2. 切换分支 - git checkout\n单独使用git branch，可以查看分支状态：\n\n``` javascript\n$ git branch\n  amazing_new_feature\n* master\n```\n* 号表示当前活跃分支为master，使用git checkout切换分支。\n\n\n``` javascript\n$ git checkout amazing_new_feature\n```\n3. 合并分支 - git merge\n我们的amazing_new_feature 分支的任务是增加一个featuer.txt。我们来创建，添加到暂存区，提交。\n\n``` javascript\n$ git add feature.txt\n$ git commit -m \"New feature complete.\"\n```\n新分支任务完成了，回到master分支\n\n``` javascript\n$ git checkout master\n```\n现在去查看文件，你会发现，之前创建的feature.txt文件不见了，因为master分支上并没有feature.txt。使用git merge 把 amazing_new_feature 分支合并到master上。\n\n``` javascript\n$ git merge amazing_new_feature\n```\nok! \n然后再把amazing_new_feature 分支删掉吧。\n\n``` javascript\n$ git branch -d amazing_new_feature\n```\n\n## 高级\n这篇文章的最后一节，我们来说些比较高级并且使用的技巧。\n1. 比对两个不同提交之间的差别\n每次提交都有一个唯一id，查看所有提交和他们的id，可以使用 git \nlog:\n\n``` javascript\n$ git log\n\ncommit ba25c0ff30e1b2f0259157b42b9f8f5d174d80d7\nAuthor: Tutorialzine\nDate:   Mon May 30 17:15:28 2016 +0300\n\n    New feature complete\n\ncommit b10cc1238e355c02a044ef9f9860811ff605c9b4\nAuthor: Tutorialzine\nDate:   Mon May 30 16:30:04 2016 +0300\n\n    Added content to hello.txt\n\ncommit 09bd8cc171d7084e78e4d118a2346b7487dca059\nAuthor: Tutorialzine\nDate:   Sat May 28 17:52:14 2016 +0300\n\n    Initial commit\n```\nid 很长，但是你并不需要复制整个字符串，前一小部分就够了。查看某一次提交更新了什么，使用 git show:\n\n\n``` javascript\n$ git show b10cc123\n\ncommit b10cc1238e355c02a044ef9f9860811ff605c9b4\nAuthor: Tutorialzine\nDate:   Mon May 30 16:30:04 2016 +0300\n\n    Added content to hello.txt\n\ndiff --git a/hello.txt b/hello.txt\nindex e69de29..b546a21 100644\n--- a/hello.txt\n+++ b/hello.txt\n@@ -0,0 +1 @@\n+Nice weather today, isn't it?\n```\n\n查看两次提交的不同，可以使用git diff [commit-from]..[commit-to] 语法：\n\n``` javascript\n$ git diff 09bd8cc..ba25c0ff\n\ndiff --git a/feature.txt b/feature.txt\nnew file mode 100644\nindex 0000000..e69de29\ndiff --git a/hello.txt b/hello.txt\nindex e69de29..b546a21 100644\n--- a/hello.txt\n+++ b/hello.txt\n@@ -0,0 +1 @@\n+Nice weather today, isn't it?\n```\n比较首次提交和最后一次提交，我们可以看到所有的更改。当然使用git difftool命令更加方便。\n\n2. 回滚某个文件到之前的版本\ngit 允许我们将某个特定的文件回滚到特定的提交，使用的也是 git checkout。\n下面的例子，我们将hello.txt回滚到最初的状态，需要指定回滚到哪个提交，以及文件的全路径。\n\n``` javascript\n$ git checkout 09bd8cc1 hello.txt\n```\n\n3. 回滚提交\n如果你发现最新的一次提交完了加某个文件，你可以通过 git commit —amend来修复，它会把最新的提交打回暂存区，并尝试重新提交。\n如果是更复杂的情况，比如不是最新的提交了。那你可以使用git revert。\n最新的一次提交别名也叫HEAD。\n\n``` javascript\n$ git revert HEAD\n```\n\n其他提交可以使用id:\n\n``` javascript\n$ git revert b10cc123\n```\n混滚提交时，发生冲突是非常频繁的。当文件被后面的提交修改了以后，git不能正确回滚。\n\n4. 解决合并冲突\n冲突经常出现在合并分支或者是拉去别人的代码。有些时候git能自动处理冲突，但大部分需要我们手动处理。\n比如John 和 Tim \n分别在各自的分支上写了两部分代码。\nJohn 喜欢 for:\n\n``` javascript\n// Use a for \nloop to console.log contents.\nfor(var i=0; i<arr.length; i++) \n{\nconsole.log(arr[i]);\n}\n```\nTim 喜欢 forEach:\n\n``` javascript\n// Use forEach \nto console.log contents.\narr.forEach(function(item) \n{\nconsole.log(item);\n});\n```\n假设John 现在去拉取 \nTim的代码:\n\n``` javascript\n$ git merge tim_branch\n\nAuto-merging print_array.js\nCONFLICT (content): Merge conflict in print_array.js\nAutomatic merge failed; fix conflicts and then commit the result.\n```\n这时候git并不知道如何解决冲突，因为他不知道John和Tim谁写得更好。\n于是它就在代码中插入标记。\n\n``` javascript\n<<<<<<< HEAD\n// Use a for loop to console.log contents.\nfor(var i=0; i<arr.length; i++) {\n    console.log(arr[i]);\n}\n=======\n// Use forEach to console.log contents.\narr.forEach(function(item) {\n    console.log(item);\n});\n>>>>>>> Tim s commit.\n```\n==== 号上方是当前最新一次提交，下方是冲突的代码。我们需要解决这样的冲突，经过组委会成员讨论，一致认定，在座的各位都是垃圾！两个都不要。改成下面的代码。\n\n\n``` javascript\n// Not using for loop or forEach.\n// Use Array.toString() to console.log contents.\nconsole.log(arr.toString());\n```\n好了，再提交一下：\n\n``` javascript\n$ git add -A\n$ git commit -m \"Array printing conflict resolved.\"\n```\n\n如果在大型项目中，这个过程可能容易出问题。你可以使用GUI 工具来帮助你。使用 git mergetool。\n\n5. 配置 .gitignore\n大部分项目中，会有写文件，文件夹是我们不想提交的。为了防止一不小心提交，我们需要gitignore文件：\n在项目根目录创建.gitignore文件\n在文件中列出不需要提交的文件名，文件夹名，每个一行\n.gitignore文件需要提交，就像普通文件一样\n通常会被ignore的文件有：\nlog文件\ntask runner \nbuilds\nnode_modules等文件夹\nIDEs生成的文件\n个人笔记\n例如：\n\n``` javascript\n*.log\nbuild/\nnode_modules/\n.idea/\nmy_notes.txt\n```\n总结\n教程结束~(撒花)\ngit有点复杂，并且有一大堆特性和技巧等着你去挖掘，这篇文章只是提供冰山一角，希望你不要因为太多繁琐的命令而停下前进的脚步！ \n怀挺！\n更多学习资源：\n* git 官方文档\n* git GUI工具\n* 在线创建.gitignore\n* 廖雪峰 git 教程\n* 图解git\n\n> 本文根据@Danny Markov的文章所译。英文出处：Learn Git in 30 Minutes  [原文链接](http://w3ctrain.com/2016/06/26/learn-git-in-30-minutes/)\n","source":"_posts/30分钟git命令入门到放弃.md","raw":"---\ntitle: Git 使用说明\ndate: 2016-07-11 17:09:08\ntags: Git\ncategory: 前端\n---\ngit——现在的火爆程度非同一般，它被广泛地用在大型开源项目，团队开发，以及独立开发者，甚至学生之中。 \n<!--more-->\n初学者非常容易被各种命令，参数吓哭。但实际上刚上手你并不需要了解所有命令的用途。你可以从掌握一些简单，强大的命令开始，逐步去学习。（这就是这篇文章要讲的）。好了，上来！\n![30分钟git命令入门到放弃](http://oa59b6bv6.bkt.clouddn.com/git1.webp)\n\n## learn-git\n\n### 基本了解\n\ngit命令是一些命令行工具的集合，它可以用来跟踪，记录文件的变动。比如你可以进行保存，比对，分析，合并等等。这个过程被称之为版本控制。已经有一系列的版本控制系统，比如SVN, Mercurial, Perforce, CVS, Bitkeepe等等。\n\nGit是分布式的，这意味着它并不依赖于中心服务器，任何一台机器都可以有一个本地版本的控制系统，我们称之为仓库。如果是多人协作的话，你需要还需要一个线上仓库，用来同步信息。这就是GitHub, BitBucket的工作。\n\n\n1. 安装Git\n安装git非常直接：\n* Linux - 打开控制台，然后通过包管理安装，在Ubuntu上命令是：\n\n``` javascript\n$ sudo apt-get install git-all\n```\n\n* Windows - 推荐使用git for windows，它包括了图形工具以及命令行模拟器。\n\n* OS X - 最简单的方式是使用homebrew安装，命令行执行\n\n``` javascript\n$ brew install git\n```\n如果你是在是先用图形工具的话，那么推荐你使用Github desktop,Sourcetree。但我还是推荐你使用命令行，下面的内容就都是命令行的。\n\n2. 配置Git\n安装完git,首要任务是配置我们的信息，最重要的是用户名及邮箱，打开终端，执行以下命令。\n\n``` javascript\n$ git config --global user.name \"My Name\"\n$ git config --global user.email myEmail@example.com\n```\n配置好这两项，用户就能知道谁做了什么，并且一切都更有组织性了不是吗？\n\n3. 创建一个新仓库 - git init\ngit 会把所有文件以及历史记录保存在你的项目中，创建一个新的仓库，首先要去到项目路径，执行 git \ninit。然后git会创建一个隐藏的文件夹.git，所有的信息都储存在其中。\n在桌面创建一个联系文件夹 git_exercise, 打开终端：\n\n``` javascript\n$ cd Desktop/git_exercise/\n$ git init\n```\nOK，现在项目还什么都没有，新建一个 hello.txt 文件试试~\n\n4. 检查状态 - git status\ngit status 是另一个非常重要的命令，它会告诉我们创库的当前状态：是否为最新代码，有什么更新等等执行git status:\n\n``` javascript\n$ git status\n\nOn branch master\n\nInitial commit\n\nUntracked files:\n  (use \"git add ...\" to include in what will be committed)\n\n\thello.txt\n```\ngit 告诉我们，hello.txt尚未跟踪，这是因为这个文件是新的，git不知道是应该跟踪它的变动呢，还是直接忽略不管呢。为了跟踪我们的新文件，我们需要暂存它。\n\n5. 暂存 - git add\ngit 有个概念叫暂存区，你可以把它看成一块空白帆布，包裹着所有你可能会提交的变动。它一开始为空，你可以通过 git add 命令添加内容，并使用 git commit \n提交。\n这个例子中只有一个文件：\n\n``` javascript\n$ git add hello.txt\n```\n如果需要提交目录下的所有内容，可以这样：\n\n``` javascript\n$ git add -A\n```\n再次使用git status查看：\n\n``` javascript\n$ git status\n\nOn branch master\n\nInitial commit\n\nChanges to be committed:\n  (use \"git rm --cached ...\" to unstage)\n\n\tnew file:   hello.txt\n```\n我们的文件已经提交了。状态信息还会告诉我们暂存区文件发生了什么变动，不过这里我们提交的是一个全新文件。\n\n6. 提交 - git commit\n一次提交代表着我们的仓库到了一个交付状态，通常是完成了某一块小功能。它就像是一个快照，允许我们像使用时光机一样回到旧时光。\n创建提交，需要我们提交东西到暂存区（git add），然后：\n\n``` javascript\n$ git commit -m \"Initial commit.\"\n```\n这就创建了一次提交，-m \n“Initial commit.”表示对这次提交的描述，建议使用有意义的描述性信息。\n\n## 远端仓库\n到目前为止，我们的操作都是在本地的，它存在于.git文件中。为了能够协同开发，我们需要把代码发布到远端仓库上。\n1. 链接远端仓库 - git remote add\n为了能够上传到远端仓库，我们需要先建立起链接，这篇教程中，远端仓库的地址为：https://github.com/tutorialzine/awesome-project,但你应该自己在Github, \nBitBucket上搭建仓库，自己一步一步尝试。\n添加测试用的远端仓库\n\n``` javascript\n$ git remote add origin https://github.com/tutorialzine/awesome-project.git\n```\n一个项目可以同时拥有好几个远端仓库为了能够区分，通常会起不同的名字。通常主远端仓库被称为origin。\n\n2. 上传到服务器 - git push\n每次我们要提交代码到服务器上时，都会使用到git push。\ngit push命令会有两个参数，远端仓库的名字，以及分支的名字：\n\n``` javascript\n$ git push origin master\n\nCounting objects: 3, done.\nWriting objects: 100% (3/3), 212 bytes | 0 bytes/s, done.\nTotal 3 (delta 0), reused 0 (delta 0)\nTo https://github.com/tutorialzine/awesome-project.git\n * [new branch]      master -> master\n```\n取决于你使用的服务器，push过程你可能需要验证身份。如果没有出差错，现在使用浏览器去你的远端分支上看，hello.txt已经在那里等着你了。\n\n3. 克隆仓库 - git clone\n放在Github上的开源项目，人们可以看到你的代码。可以使用 git clone进行下载到本地。\n\n``` javascript\n$ git clone https://github.com/tutorialzine/awesome-project.git\n```\n本地也会创建一个新的仓库，并自动将github上的分支设为远端分支。\n\n4. 从服务器上拉取代码 - git pull\n如果你更新了代码到仓库上，其他人可以通过git pull命令拉取你的变动：\n\n``` javascript\n$ git pull origin master\nFrom https://github.com/tutorialzine/awesome-project\n * branch            master     -> FETCH_HEAD\nAlready up-to-date.\n```\n因为暂时没有其他人提交，所有没有任何变动分支\n![branchs](http://oa59b6bv6.bkt.clouddn.com/git2.webp)\nbranchs\n\n当你在做一个新功能的时候，最好是在一个独立的区域上开发，通常称之为分支。分支之间相互独立，并且拥有自己的历史记录。这样做的原因是：\n* 稳定版本的代码不会被破坏\n* 不同的功能可以由不同开发者同时开发。\n* 开发者可以专注于自己的分支，不用担心被其他人破坏了环境\n* 在不确定之前，同一个特性可以拥有几个版本，便于比较\n\n1. 创建新分支 - git branch\n每一个仓库的默认分支都叫master, 创建新分支可以这样：\n\n``` javascript\n$ git branch amazing_new_feature\n```\n创建了一个名为amazing_new_feature的新分支，它跟当前分支同一起点\n\n2. 切换分支 - git checkout\n单独使用git branch，可以查看分支状态：\n\n``` javascript\n$ git branch\n  amazing_new_feature\n* master\n```\n* 号表示当前活跃分支为master，使用git checkout切换分支。\n\n\n``` javascript\n$ git checkout amazing_new_feature\n```\n3. 合并分支 - git merge\n我们的amazing_new_feature 分支的任务是增加一个featuer.txt。我们来创建，添加到暂存区，提交。\n\n``` javascript\n$ git add feature.txt\n$ git commit -m \"New feature complete.\"\n```\n新分支任务完成了，回到master分支\n\n``` javascript\n$ git checkout master\n```\n现在去查看文件，你会发现，之前创建的feature.txt文件不见了，因为master分支上并没有feature.txt。使用git merge 把 amazing_new_feature 分支合并到master上。\n\n``` javascript\n$ git merge amazing_new_feature\n```\nok! \n然后再把amazing_new_feature 分支删掉吧。\n\n``` javascript\n$ git branch -d amazing_new_feature\n```\n\n## 高级\n这篇文章的最后一节，我们来说些比较高级并且使用的技巧。\n1. 比对两个不同提交之间的差别\n每次提交都有一个唯一id，查看所有提交和他们的id，可以使用 git \nlog:\n\n``` javascript\n$ git log\n\ncommit ba25c0ff30e1b2f0259157b42b9f8f5d174d80d7\nAuthor: Tutorialzine\nDate:   Mon May 30 17:15:28 2016 +0300\n\n    New feature complete\n\ncommit b10cc1238e355c02a044ef9f9860811ff605c9b4\nAuthor: Tutorialzine\nDate:   Mon May 30 16:30:04 2016 +0300\n\n    Added content to hello.txt\n\ncommit 09bd8cc171d7084e78e4d118a2346b7487dca059\nAuthor: Tutorialzine\nDate:   Sat May 28 17:52:14 2016 +0300\n\n    Initial commit\n```\nid 很长，但是你并不需要复制整个字符串，前一小部分就够了。查看某一次提交更新了什么，使用 git show:\n\n\n``` javascript\n$ git show b10cc123\n\ncommit b10cc1238e355c02a044ef9f9860811ff605c9b4\nAuthor: Tutorialzine\nDate:   Mon May 30 16:30:04 2016 +0300\n\n    Added content to hello.txt\n\ndiff --git a/hello.txt b/hello.txt\nindex e69de29..b546a21 100644\n--- a/hello.txt\n+++ b/hello.txt\n@@ -0,0 +1 @@\n+Nice weather today, isn't it?\n```\n\n查看两次提交的不同，可以使用git diff [commit-from]..[commit-to] 语法：\n\n``` javascript\n$ git diff 09bd8cc..ba25c0ff\n\ndiff --git a/feature.txt b/feature.txt\nnew file mode 100644\nindex 0000000..e69de29\ndiff --git a/hello.txt b/hello.txt\nindex e69de29..b546a21 100644\n--- a/hello.txt\n+++ b/hello.txt\n@@ -0,0 +1 @@\n+Nice weather today, isn't it?\n```\n比较首次提交和最后一次提交，我们可以看到所有的更改。当然使用git difftool命令更加方便。\n\n2. 回滚某个文件到之前的版本\ngit 允许我们将某个特定的文件回滚到特定的提交，使用的也是 git checkout。\n下面的例子，我们将hello.txt回滚到最初的状态，需要指定回滚到哪个提交，以及文件的全路径。\n\n``` javascript\n$ git checkout 09bd8cc1 hello.txt\n```\n\n3. 回滚提交\n如果你发现最新的一次提交完了加某个文件，你可以通过 git commit —amend来修复，它会把最新的提交打回暂存区，并尝试重新提交。\n如果是更复杂的情况，比如不是最新的提交了。那你可以使用git revert。\n最新的一次提交别名也叫HEAD。\n\n``` javascript\n$ git revert HEAD\n```\n\n其他提交可以使用id:\n\n``` javascript\n$ git revert b10cc123\n```\n混滚提交时，发生冲突是非常频繁的。当文件被后面的提交修改了以后，git不能正确回滚。\n\n4. 解决合并冲突\n冲突经常出现在合并分支或者是拉去别人的代码。有些时候git能自动处理冲突，但大部分需要我们手动处理。\n比如John 和 Tim \n分别在各自的分支上写了两部分代码。\nJohn 喜欢 for:\n\n``` javascript\n// Use a for \nloop to console.log contents.\nfor(var i=0; i<arr.length; i++) \n{\nconsole.log(arr[i]);\n}\n```\nTim 喜欢 forEach:\n\n``` javascript\n// Use forEach \nto console.log contents.\narr.forEach(function(item) \n{\nconsole.log(item);\n});\n```\n假设John 现在去拉取 \nTim的代码:\n\n``` javascript\n$ git merge tim_branch\n\nAuto-merging print_array.js\nCONFLICT (content): Merge conflict in print_array.js\nAutomatic merge failed; fix conflicts and then commit the result.\n```\n这时候git并不知道如何解决冲突，因为他不知道John和Tim谁写得更好。\n于是它就在代码中插入标记。\n\n``` javascript\n<<<<<<< HEAD\n// Use a for loop to console.log contents.\nfor(var i=0; i<arr.length; i++) {\n    console.log(arr[i]);\n}\n=======\n// Use forEach to console.log contents.\narr.forEach(function(item) {\n    console.log(item);\n});\n>>>>>>> Tim s commit.\n```\n==== 号上方是当前最新一次提交，下方是冲突的代码。我们需要解决这样的冲突，经过组委会成员讨论，一致认定，在座的各位都是垃圾！两个都不要。改成下面的代码。\n\n\n``` javascript\n// Not using for loop or forEach.\n// Use Array.toString() to console.log contents.\nconsole.log(arr.toString());\n```\n好了，再提交一下：\n\n``` javascript\n$ git add -A\n$ git commit -m \"Array printing conflict resolved.\"\n```\n\n如果在大型项目中，这个过程可能容易出问题。你可以使用GUI 工具来帮助你。使用 git mergetool。\n\n5. 配置 .gitignore\n大部分项目中，会有写文件，文件夹是我们不想提交的。为了防止一不小心提交，我们需要gitignore文件：\n在项目根目录创建.gitignore文件\n在文件中列出不需要提交的文件名，文件夹名，每个一行\n.gitignore文件需要提交，就像普通文件一样\n通常会被ignore的文件有：\nlog文件\ntask runner \nbuilds\nnode_modules等文件夹\nIDEs生成的文件\n个人笔记\n例如：\n\n``` javascript\n*.log\nbuild/\nnode_modules/\n.idea/\nmy_notes.txt\n```\n总结\n教程结束~(撒花)\ngit有点复杂，并且有一大堆特性和技巧等着你去挖掘，这篇文章只是提供冰山一角，希望你不要因为太多繁琐的命令而停下前进的脚步！ \n怀挺！\n更多学习资源：\n* git 官方文档\n* git GUI工具\n* 在线创建.gitignore\n* 廖雪峰 git 教程\n* 图解git\n\n> 本文根据@Danny Markov的文章所译。英文出处：Learn Git in 30 Minutes  [原文链接](http://w3ctrain.com/2016/06/26/learn-git-in-30-minutes/)\n","slug":"30分钟git命令入门到放弃","published":1,"updated":"2019-03-21T03:42:03.282Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtifjptm000zlohi3mnvx0z7","content":"<p>git——现在的火爆程度非同一般，它被广泛地用在大型开源项目，团队开发，以及独立开发者，甚至学生之中。<br><a id=\"more\"></a><br>初学者非常容易被各种命令，参数吓哭。但实际上刚上手你并不需要了解所有命令的用途。你可以从掌握一些简单，强大的命令开始，逐步去学习。（这就是这篇文章要讲的）。好了，上来！<br><img src=\"http://oa59b6bv6.bkt.clouddn.com/git1.webp\" alt=\"30分钟git命令入门到放弃\"></p>\n<h2 id=\"learn-git\"><a href=\"#learn-git\" class=\"headerlink\" title=\"learn-git\"></a>learn-git</h2><h3 id=\"基本了解\"><a href=\"#基本了解\" class=\"headerlink\" title=\"基本了解\"></a>基本了解</h3><p>git命令是一些命令行工具的集合，它可以用来跟踪，记录文件的变动。比如你可以进行保存，比对，分析，合并等等。这个过程被称之为版本控制。已经有一系列的版本控制系统，比如SVN, Mercurial, Perforce, CVS, Bitkeepe等等。</p>\n<p>Git是分布式的，这意味着它并不依赖于中心服务器，任何一台机器都可以有一个本地版本的控制系统，我们称之为仓库。如果是多人协作的话，你需要还需要一个线上仓库，用来同步信息。这就是GitHub, BitBucket的工作。</p>\n<ol>\n<li>安装Git<br>安装git非常直接：</li>\n</ol>\n<ul>\n<li>Linux - 打开控制台，然后通过包管理安装，在Ubuntu上命令是：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-<span class=\"keyword\">get</span> install git-all</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>Windows - 推荐使用git for windows，它包括了图形工具以及命令行模拟器。</p>\n</li>\n<li><p>OS X - 最简单的方式是使用homebrew安装，命令行执行</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ brew install git</span><br></pre></td></tr></table></figure>\n<p>如果你是在是先用图形工具的话，那么推荐你使用Github desktop,Sourcetree。但我还是推荐你使用命令行，下面的内容就都是命令行的。</p>\n<ol start=\"2\">\n<li>配置Git<br>安装完git,首要任务是配置我们的信息，最重要的是用户名及邮箱，打开终端，执行以下命令。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --global user.name <span class=\"string\">\"My Name\"</span></span><br><span class=\"line\">$ git config --global user.email myEmail@example.com</span><br></pre></td></tr></table></figure>\n<p>配置好这两项，用户就能知道谁做了什么，并且一切都更有组织性了不是吗？</p>\n<ol start=\"3\">\n<li>创建一个新仓库 - git init<br>git 会把所有文件以及历史记录保存在你的项目中，创建一个新的仓库，首先要去到项目路径，执行 git<br>init。然后git会创建一个隐藏的文件夹.git，所有的信息都储存在其中。<br>在桌面创建一个联系文件夹 git_exercise, 打开终端：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd Desktop/git_exercise/</span><br><span class=\"line\">$ git init</span><br></pre></td></tr></table></figure>\n<p>OK，现在项目还什么都没有，新建一个 hello.txt 文件试试~</p>\n<ol start=\"4\">\n<li>检查状态 - git status<br>git status 是另一个非常重要的命令，它会告诉我们创库的当前状态：是否为最新代码，有什么更新等等执行git status:</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\"></span><br><span class=\"line\">On branch master</span><br><span class=\"line\"></span><br><span class=\"line\">Initial commit</span><br><span class=\"line\"></span><br><span class=\"line\">Untracked files:</span><br><span class=\"line\">  (use <span class=\"string\">\"git add ...\"</span> to include <span class=\"keyword\">in</span> what will be committed)</span><br><span class=\"line\"></span><br><span class=\"line\">\thello.txt</span><br></pre></td></tr></table></figure>\n<p>git 告诉我们，hello.txt尚未跟踪，这是因为这个文件是新的，git不知道是应该跟踪它的变动呢，还是直接忽略不管呢。为了跟踪我们的新文件，我们需要暂存它。</p>\n<ol start=\"5\">\n<li>暂存 - git add<br>git 有个概念叫暂存区，你可以把它看成一块空白帆布，包裹着所有你可能会提交的变动。它一开始为空，你可以通过 git add 命令添加内容，并使用 git commit<br>提交。<br>这个例子中只有一个文件：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add hello.txt</span><br></pre></td></tr></table></figure>\n<p>如果需要提交目录下的所有内容，可以这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add -A</span><br></pre></td></tr></table></figure>\n<p>再次使用git status查看：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\"></span><br><span class=\"line\">On branch master</span><br><span class=\"line\"></span><br><span class=\"line\">Initial commit</span><br><span class=\"line\"></span><br><span class=\"line\">Changes to be committed:</span><br><span class=\"line\">  (use <span class=\"string\">\"git rm --cached ...\"</span> to unstage)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">new</span> file:   hello.txt</span><br></pre></td></tr></table></figure>\n<p>我们的文件已经提交了。状态信息还会告诉我们暂存区文件发生了什么变动，不过这里我们提交的是一个全新文件。</p>\n<ol start=\"6\">\n<li>提交 - git commit<br>一次提交代表着我们的仓库到了一个交付状态，通常是完成了某一块小功能。它就像是一个快照，允许我们像使用时光机一样回到旧时光。<br>创建提交，需要我们提交东西到暂存区（git add），然后：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit -m <span class=\"string\">\"Initial commit.\"</span></span><br></pre></td></tr></table></figure>\n<p>这就创建了一次提交，-m<br>“Initial commit.”表示对这次提交的描述，建议使用有意义的描述性信息。</p>\n<h2 id=\"远端仓库\"><a href=\"#远端仓库\" class=\"headerlink\" title=\"远端仓库\"></a>远端仓库</h2><p>到目前为止，我们的操作都是在本地的，它存在于.git文件中。为了能够协同开发，我们需要把代码发布到远端仓库上。</p>\n<ol>\n<li>链接远端仓库 - git remote add<br>为了能够上传到远端仓库，我们需要先建立起链接，这篇教程中，远端仓库的地址为：<a href=\"https://github.com/tutorialzine/awesome-project,但你应该自己在Github\" target=\"_blank\" rel=\"noopener\">https://github.com/tutorialzine/awesome-project,但你应该自己在Github</a>,<br>BitBucket上搭建仓库，自己一步一步尝试。<br>添加测试用的远端仓库</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote add origin https:<span class=\"comment\">//github.com/tutorialzine/awesome-project.git</span></span><br></pre></td></tr></table></figure>\n<p>一个项目可以同时拥有好几个远端仓库为了能够区分，通常会起不同的名字。通常主远端仓库被称为origin。</p>\n<ol start=\"2\">\n<li>上传到服务器 - git push<br>每次我们要提交代码到服务器上时，都会使用到git push。<br>git push命令会有两个参数，远端仓库的名字，以及分支的名字：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin master</span><br><span class=\"line\"></span><br><span class=\"line\">Counting objects: <span class=\"number\">3</span>, done.</span><br><span class=\"line\">Writing objects: <span class=\"number\">100</span>% (<span class=\"number\">3</span>/<span class=\"number\">3</span>), <span class=\"number\">212</span> bytes | <span class=\"number\">0</span> bytes/s, done.</span><br><span class=\"line\">Total <span class=\"number\">3</span> (delta <span class=\"number\">0</span>), reused <span class=\"number\">0</span> (delta <span class=\"number\">0</span>)</span><br><span class=\"line\">To https:<span class=\"comment\">//github.com/tutorialzine/awesome-project.git</span></span><br><span class=\"line\"> * [<span class=\"keyword\">new</span> branch]      master -&gt; master</span><br></pre></td></tr></table></figure>\n<p>取决于你使用的服务器，push过程你可能需要验证身份。如果没有出差错，现在使用浏览器去你的远端分支上看，hello.txt已经在那里等着你了。</p>\n<ol start=\"3\">\n<li>克隆仓库 - git clone<br>放在Github上的开源项目，人们可以看到你的代码。可以使用 git clone进行下载到本地。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone https:<span class=\"comment\">//github.com/tutorialzine/awesome-project.git</span></span><br></pre></td></tr></table></figure>\n<p>本地也会创建一个新的仓库，并自动将github上的分支设为远端分支。</p>\n<ol start=\"4\">\n<li>从服务器上拉取代码 - git pull<br>如果你更新了代码到仓库上，其他人可以通过git pull命令拉取你的变动：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git pull origin master</span><br><span class=\"line\">From https:<span class=\"comment\">//github.com/tutorialzine/awesome-project</span></span><br><span class=\"line\"> * branch            master     -&gt; FETCH_HEAD</span><br><span class=\"line\">Already up-to-date.</span><br></pre></td></tr></table></figure>\n<p>因为暂时没有其他人提交，所有没有任何变动分支<br><img src=\"http://oa59b6bv6.bkt.clouddn.com/git2.webp\" alt=\"branchs\"><br>branchs</p>\n<p>当你在做一个新功能的时候，最好是在一个独立的区域上开发，通常称之为分支。分支之间相互独立，并且拥有自己的历史记录。这样做的原因是：</p>\n<ul>\n<li>稳定版本的代码不会被破坏</li>\n<li>不同的功能可以由不同开发者同时开发。</li>\n<li>开发者可以专注于自己的分支，不用担心被其他人破坏了环境</li>\n<li>在不确定之前，同一个特性可以拥有几个版本，便于比较</li>\n</ul>\n<ol>\n<li>创建新分支 - git branch<br>每一个仓库的默认分支都叫master, 创建新分支可以这样：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch amazing_new_feature</span><br></pre></td></tr></table></figure>\n<p>创建了一个名为amazing_new_feature的新分支，它跟当前分支同一起点</p>\n<ol start=\"2\">\n<li>切换分支 - git checkout<br>单独使用git branch，可以查看分支状态：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch</span><br><span class=\"line\">  amazing_new_feature</span><br><span class=\"line\">* master</span><br></pre></td></tr></table></figure>\n<ul>\n<li>号表示当前活跃分支为master，使用git checkout切换分支。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout amazing_new_feature</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>合并分支 - git merge<br>我们的amazing_new_feature 分支的任务是增加一个featuer.txt。我们来创建，添加到暂存区，提交。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add feature.txt</span><br><span class=\"line\">$ git commit -m <span class=\"string\">\"New feature complete.\"</span></span><br></pre></td></tr></table></figure>\n<p>新分支任务完成了，回到master分支</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout master</span><br></pre></td></tr></table></figure>\n<p>现在去查看文件，你会发现，之前创建的feature.txt文件不见了，因为master分支上并没有feature.txt。使用git merge 把 amazing_new_feature 分支合并到master上。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git merge amazing_new_feature</span><br></pre></td></tr></table></figure>\n<p>ok!<br>然后再把amazing_new_feature 分支删掉吧。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch -d amazing_new_feature</span><br></pre></td></tr></table></figure>\n<h2 id=\"高级\"><a href=\"#高级\" class=\"headerlink\" title=\"高级\"></a>高级</h2><p>这篇文章的最后一节，我们来说些比较高级并且使用的技巧。</p>\n<ol>\n<li>比对两个不同提交之间的差别<br>每次提交都有一个唯一id，查看所有提交和他们的id，可以使用 git<br>log:</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log</span><br><span class=\"line\"></span><br><span class=\"line\">commit ba25c0ff30e1b2f0259157b42b9f8f5d174d80d7</span><br><span class=\"line\">Author: Tutorialzine</span><br><span class=\"line\"><span class=\"built_in\">Date</span>:   Mon May <span class=\"number\">30</span> <span class=\"number\">17</span>:<span class=\"number\">15</span>:<span class=\"number\">28</span> <span class=\"number\">2016</span> +<span class=\"number\">0300</span></span><br><span class=\"line\"></span><br><span class=\"line\">    New feature complete</span><br><span class=\"line\"></span><br><span class=\"line\">commit b10cc1238e355c02a044ef9f9860811ff605c9b4</span><br><span class=\"line\">Author: Tutorialzine</span><br><span class=\"line\"><span class=\"built_in\">Date</span>:   Mon May <span class=\"number\">30</span> <span class=\"number\">16</span>:<span class=\"number\">30</span>:<span class=\"number\">04</span> <span class=\"number\">2016</span> +<span class=\"number\">0300</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Added content to hello.txt</span><br><span class=\"line\"></span><br><span class=\"line\">commit <span class=\"number\">09</span>bd8cc171d7084e78e4d118a2346b7487dca059</span><br><span class=\"line\">Author: Tutorialzine</span><br><span class=\"line\"><span class=\"built_in\">Date</span>:   Sat May <span class=\"number\">28</span> <span class=\"number\">17</span>:<span class=\"number\">52</span>:<span class=\"number\">14</span> <span class=\"number\">2016</span> +<span class=\"number\">0300</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Initial commit</span><br></pre></td></tr></table></figure>\n<p>id 很长，但是你并不需要复制整个字符串，前一小部分就够了。查看某一次提交更新了什么，使用 git show:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git show b10cc123</span><br><span class=\"line\"></span><br><span class=\"line\">commit b10cc1238e355c02a044ef9f9860811ff605c9b4</span><br><span class=\"line\">Author: Tutorialzine</span><br><span class=\"line\"><span class=\"built_in\">Date</span>:   Mon May <span class=\"number\">30</span> <span class=\"number\">16</span>:<span class=\"number\">30</span>:<span class=\"number\">04</span> <span class=\"number\">2016</span> +<span class=\"number\">0300</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Added content to hello.txt</span><br><span class=\"line\"></span><br><span class=\"line\">diff --git a/hello.txt b/hello.txt</span><br><span class=\"line\">index e69de29..b546a21 <span class=\"number\">100644</span></span><br><span class=\"line\">--- a/hello.txt</span><br><span class=\"line\">+++ b/hello.txt</span><br><span class=\"line\">@@ <span class=\"number\">-0</span>,<span class=\"number\">0</span> +<span class=\"number\">1</span> @@</span><br><span class=\"line\">+Nice weather today, isn<span class=\"string\">'t it?</span></span><br></pre></td></tr></table></figure>\n<p>查看两次提交的不同，可以使用git diff [commit-from]..[commit-to] 语法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git diff <span class=\"number\">09</span>bd8cc..ba25c0ff</span><br><span class=\"line\"></span><br><span class=\"line\">diff --git a/feature.txt b/feature.txt</span><br><span class=\"line\"><span class=\"keyword\">new</span> file mode <span class=\"number\">100644</span></span><br><span class=\"line\">index <span class=\"number\">0000000.</span>.e69de29</span><br><span class=\"line\">diff --git a/hello.txt b/hello.txt</span><br><span class=\"line\">index e69de29..b546a21 <span class=\"number\">100644</span></span><br><span class=\"line\">--- a/hello.txt</span><br><span class=\"line\">+++ b/hello.txt</span><br><span class=\"line\">@@ <span class=\"number\">-0</span>,<span class=\"number\">0</span> +<span class=\"number\">1</span> @@</span><br><span class=\"line\">+Nice weather today, isn<span class=\"string\">'t it?</span></span><br></pre></td></tr></table></figure>\n<p>比较首次提交和最后一次提交，我们可以看到所有的更改。当然使用git difftool命令更加方便。</p>\n<ol start=\"2\">\n<li>回滚某个文件到之前的版本<br>git 允许我们将某个特定的文件回滚到特定的提交，使用的也是 git checkout。<br>下面的例子，我们将hello.txt回滚到最初的状态，需要指定回滚到哪个提交，以及文件的全路径。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout <span class=\"number\">09</span>bd8cc1 hello.txt</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>回滚提交<br>如果你发现最新的一次提交完了加某个文件，你可以通过 git commit —amend来修复，它会把最新的提交打回暂存区，并尝试重新提交。<br>如果是更复杂的情况，比如不是最新的提交了。那你可以使用git revert。<br>最新的一次提交别名也叫HEAD。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git revert HEAD</span><br></pre></td></tr></table></figure>\n<p>其他提交可以使用id:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git revert b10cc123</span><br></pre></td></tr></table></figure>\n<p>混滚提交时，发生冲突是非常频繁的。当文件被后面的提交修改了以后，git不能正确回滚。</p>\n<ol start=\"4\">\n<li>解决合并冲突<br>冲突经常出现在合并分支或者是拉去别人的代码。有些时候git能自动处理冲突，但大部分需要我们手动处理。<br>比如John 和 Tim<br>分别在各自的分支上写了两部分代码。<br>John 喜欢 for:</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Use a for </span></span><br><span class=\"line\">loop to <span class=\"built_in\">console</span>.log contents.</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;arr.length; i++) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Tim 喜欢 forEach:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Use forEach </span></span><br><span class=\"line\">to <span class=\"built_in\">console</span>.log contents.</span><br><span class=\"line\">arr.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>) </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(item);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>假设John 现在去拉取<br>Tim的代码:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git merge tim_branch</span><br><span class=\"line\"></span><br><span class=\"line\">Auto-merging print_array.js</span><br><span class=\"line\">CONFLICT (content): Merge conflict <span class=\"keyword\">in</span> print_array.js</span><br><span class=\"line\">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>\n<p>这时候git并不知道如何解决冲突，因为他不知道John和Tim谁写得更好。<br>于是它就在代码中插入标记。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class=\"line\">// Use a for loop to console.log contents.</span><br><span class=\"line\">for(var i=0; i&lt;arr.length; i++) &#123;</span><br><span class=\"line\">    console.log(arr[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">=======</span><br><span class=\"line\">// Use forEach to console.log contents.</span><br><span class=\"line\">arr.forEach(function(item) &#123;</span><br><span class=\"line\">    console.log(item);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;&gt; Tim s commit.</span><br></pre></td></tr></table></figure>\n<p>==== 号上方是当前最新一次提交，下方是冲突的代码。我们需要解决这样的冲突，经过组委会成员讨论，一致认定，在座的各位都是垃圾！两个都不要。改成下面的代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Not using for loop or forEach.</span></span><br><span class=\"line\"><span class=\"comment\">// Use Array.toString() to console.log contents.</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.toString());</span><br></pre></td></tr></table></figure>\n<p>好了，再提交一下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add -A</span><br><span class=\"line\">$ git commit -m <span class=\"string\">\"Array printing conflict resolved.\"</span></span><br></pre></td></tr></table></figure>\n<p>如果在大型项目中，这个过程可能容易出问题。你可以使用GUI 工具来帮助你。使用 git mergetool。</p>\n<ol start=\"5\">\n<li>配置 .gitignore<br>大部分项目中，会有写文件，文件夹是我们不想提交的。为了防止一不小心提交，我们需要gitignore文件：<br>在项目根目录创建.gitignore文件<br>在文件中列出不需要提交的文件名，文件夹名，每个一行<br>.gitignore文件需要提交，就像普通文件一样<br>通常会被ignore的文件有：<br>log文件<br>task runner<br>builds<br>node_modules等文件夹<br>IDEs生成的文件<br>个人笔记<br>例如：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*.log</span><br><span class=\"line\">build/</span><br><span class=\"line\">node_modules/</span><br><span class=\"line\">.idea/</span><br><span class=\"line\">my_notes.txt</span><br></pre></td></tr></table></figure>\n<p>总结<br>教程结束~(撒花)<br>git有点复杂，并且有一大堆特性和技巧等着你去挖掘，这篇文章只是提供冰山一角，希望你不要因为太多繁琐的命令而停下前进的脚步！<br>怀挺！<br>更多学习资源：</p>\n<ul>\n<li>git 官方文档</li>\n<li>git GUI工具</li>\n<li>在线创建.gitignore</li>\n<li>廖雪峰 git 教程</li>\n<li>图解git</li>\n</ul>\n<blockquote>\n<p>本文根据@Danny Markov的文章所译。英文出处：Learn Git in 30 Minutes  <a href=\"http://w3ctrain.com/2016/06/26/learn-git-in-30-minutes/\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>git——现在的火爆程度非同一般，它被广泛地用在大型开源项目，团队开发，以及独立开发者，甚至学生之中。<br>","more":"<br>初学者非常容易被各种命令，参数吓哭。但实际上刚上手你并不需要了解所有命令的用途。你可以从掌握一些简单，强大的命令开始，逐步去学习。（这就是这篇文章要讲的）。好了，上来！<br><img src=\"http://oa59b6bv6.bkt.clouddn.com/git1.webp\" alt=\"30分钟git命令入门到放弃\"></p>\n<h2 id=\"learn-git\"><a href=\"#learn-git\" class=\"headerlink\" title=\"learn-git\"></a>learn-git</h2><h3 id=\"基本了解\"><a href=\"#基本了解\" class=\"headerlink\" title=\"基本了解\"></a>基本了解</h3><p>git命令是一些命令行工具的集合，它可以用来跟踪，记录文件的变动。比如你可以进行保存，比对，分析，合并等等。这个过程被称之为版本控制。已经有一系列的版本控制系统，比如SVN, Mercurial, Perforce, CVS, Bitkeepe等等。</p>\n<p>Git是分布式的，这意味着它并不依赖于中心服务器，任何一台机器都可以有一个本地版本的控制系统，我们称之为仓库。如果是多人协作的话，你需要还需要一个线上仓库，用来同步信息。这就是GitHub, BitBucket的工作。</p>\n<ol>\n<li>安装Git<br>安装git非常直接：</li>\n</ol>\n<ul>\n<li>Linux - 打开控制台，然后通过包管理安装，在Ubuntu上命令是：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-<span class=\"keyword\">get</span> install git-all</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>Windows - 推荐使用git for windows，它包括了图形工具以及命令行模拟器。</p>\n</li>\n<li><p>OS X - 最简单的方式是使用homebrew安装，命令行执行</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ brew install git</span><br></pre></td></tr></table></figure>\n<p>如果你是在是先用图形工具的话，那么推荐你使用Github desktop,Sourcetree。但我还是推荐你使用命令行，下面的内容就都是命令行的。</p>\n<ol start=\"2\">\n<li>配置Git<br>安装完git,首要任务是配置我们的信息，最重要的是用户名及邮箱，打开终端，执行以下命令。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --global user.name <span class=\"string\">\"My Name\"</span></span><br><span class=\"line\">$ git config --global user.email myEmail@example.com</span><br></pre></td></tr></table></figure>\n<p>配置好这两项，用户就能知道谁做了什么，并且一切都更有组织性了不是吗？</p>\n<ol start=\"3\">\n<li>创建一个新仓库 - git init<br>git 会把所有文件以及历史记录保存在你的项目中，创建一个新的仓库，首先要去到项目路径，执行 git<br>init。然后git会创建一个隐藏的文件夹.git，所有的信息都储存在其中。<br>在桌面创建一个联系文件夹 git_exercise, 打开终端：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd Desktop/git_exercise/</span><br><span class=\"line\">$ git init</span><br></pre></td></tr></table></figure>\n<p>OK，现在项目还什么都没有，新建一个 hello.txt 文件试试~</p>\n<ol start=\"4\">\n<li>检查状态 - git status<br>git status 是另一个非常重要的命令，它会告诉我们创库的当前状态：是否为最新代码，有什么更新等等执行git status:</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\"></span><br><span class=\"line\">On branch master</span><br><span class=\"line\"></span><br><span class=\"line\">Initial commit</span><br><span class=\"line\"></span><br><span class=\"line\">Untracked files:</span><br><span class=\"line\">  (use <span class=\"string\">\"git add ...\"</span> to include <span class=\"keyword\">in</span> what will be committed)</span><br><span class=\"line\"></span><br><span class=\"line\">\thello.txt</span><br></pre></td></tr></table></figure>\n<p>git 告诉我们，hello.txt尚未跟踪，这是因为这个文件是新的，git不知道是应该跟踪它的变动呢，还是直接忽略不管呢。为了跟踪我们的新文件，我们需要暂存它。</p>\n<ol start=\"5\">\n<li>暂存 - git add<br>git 有个概念叫暂存区，你可以把它看成一块空白帆布，包裹着所有你可能会提交的变动。它一开始为空，你可以通过 git add 命令添加内容，并使用 git commit<br>提交。<br>这个例子中只有一个文件：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add hello.txt</span><br></pre></td></tr></table></figure>\n<p>如果需要提交目录下的所有内容，可以这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add -A</span><br></pre></td></tr></table></figure>\n<p>再次使用git status查看：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\"></span><br><span class=\"line\">On branch master</span><br><span class=\"line\"></span><br><span class=\"line\">Initial commit</span><br><span class=\"line\"></span><br><span class=\"line\">Changes to be committed:</span><br><span class=\"line\">  (use <span class=\"string\">\"git rm --cached ...\"</span> to unstage)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">new</span> file:   hello.txt</span><br></pre></td></tr></table></figure>\n<p>我们的文件已经提交了。状态信息还会告诉我们暂存区文件发生了什么变动，不过这里我们提交的是一个全新文件。</p>\n<ol start=\"6\">\n<li>提交 - git commit<br>一次提交代表着我们的仓库到了一个交付状态，通常是完成了某一块小功能。它就像是一个快照，允许我们像使用时光机一样回到旧时光。<br>创建提交，需要我们提交东西到暂存区（git add），然后：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit -m <span class=\"string\">\"Initial commit.\"</span></span><br></pre></td></tr></table></figure>\n<p>这就创建了一次提交，-m<br>“Initial commit.”表示对这次提交的描述，建议使用有意义的描述性信息。</p>\n<h2 id=\"远端仓库\"><a href=\"#远端仓库\" class=\"headerlink\" title=\"远端仓库\"></a>远端仓库</h2><p>到目前为止，我们的操作都是在本地的，它存在于.git文件中。为了能够协同开发，我们需要把代码发布到远端仓库上。</p>\n<ol>\n<li>链接远端仓库 - git remote add<br>为了能够上传到远端仓库，我们需要先建立起链接，这篇教程中，远端仓库的地址为：<a href=\"https://github.com/tutorialzine/awesome-project,但你应该自己在Github\" target=\"_blank\" rel=\"noopener\">https://github.com/tutorialzine/awesome-project,但你应该自己在Github</a>,<br>BitBucket上搭建仓库，自己一步一步尝试。<br>添加测试用的远端仓库</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote add origin https:<span class=\"comment\">//github.com/tutorialzine/awesome-project.git</span></span><br></pre></td></tr></table></figure>\n<p>一个项目可以同时拥有好几个远端仓库为了能够区分，通常会起不同的名字。通常主远端仓库被称为origin。</p>\n<ol start=\"2\">\n<li>上传到服务器 - git push<br>每次我们要提交代码到服务器上时，都会使用到git push。<br>git push命令会有两个参数，远端仓库的名字，以及分支的名字：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin master</span><br><span class=\"line\"></span><br><span class=\"line\">Counting objects: <span class=\"number\">3</span>, done.</span><br><span class=\"line\">Writing objects: <span class=\"number\">100</span>% (<span class=\"number\">3</span>/<span class=\"number\">3</span>), <span class=\"number\">212</span> bytes | <span class=\"number\">0</span> bytes/s, done.</span><br><span class=\"line\">Total <span class=\"number\">3</span> (delta <span class=\"number\">0</span>), reused <span class=\"number\">0</span> (delta <span class=\"number\">0</span>)</span><br><span class=\"line\">To https:<span class=\"comment\">//github.com/tutorialzine/awesome-project.git</span></span><br><span class=\"line\"> * [<span class=\"keyword\">new</span> branch]      master -&gt; master</span><br></pre></td></tr></table></figure>\n<p>取决于你使用的服务器，push过程你可能需要验证身份。如果没有出差错，现在使用浏览器去你的远端分支上看，hello.txt已经在那里等着你了。</p>\n<ol start=\"3\">\n<li>克隆仓库 - git clone<br>放在Github上的开源项目，人们可以看到你的代码。可以使用 git clone进行下载到本地。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone https:<span class=\"comment\">//github.com/tutorialzine/awesome-project.git</span></span><br></pre></td></tr></table></figure>\n<p>本地也会创建一个新的仓库，并自动将github上的分支设为远端分支。</p>\n<ol start=\"4\">\n<li>从服务器上拉取代码 - git pull<br>如果你更新了代码到仓库上，其他人可以通过git pull命令拉取你的变动：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git pull origin master</span><br><span class=\"line\">From https:<span class=\"comment\">//github.com/tutorialzine/awesome-project</span></span><br><span class=\"line\"> * branch            master     -&gt; FETCH_HEAD</span><br><span class=\"line\">Already up-to-date.</span><br></pre></td></tr></table></figure>\n<p>因为暂时没有其他人提交，所有没有任何变动分支<br><img src=\"http://oa59b6bv6.bkt.clouddn.com/git2.webp\" alt=\"branchs\"><br>branchs</p>\n<p>当你在做一个新功能的时候，最好是在一个独立的区域上开发，通常称之为分支。分支之间相互独立，并且拥有自己的历史记录。这样做的原因是：</p>\n<ul>\n<li>稳定版本的代码不会被破坏</li>\n<li>不同的功能可以由不同开发者同时开发。</li>\n<li>开发者可以专注于自己的分支，不用担心被其他人破坏了环境</li>\n<li>在不确定之前，同一个特性可以拥有几个版本，便于比较</li>\n</ul>\n<ol>\n<li>创建新分支 - git branch<br>每一个仓库的默认分支都叫master, 创建新分支可以这样：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch amazing_new_feature</span><br></pre></td></tr></table></figure>\n<p>创建了一个名为amazing_new_feature的新分支，它跟当前分支同一起点</p>\n<ol start=\"2\">\n<li>切换分支 - git checkout<br>单独使用git branch，可以查看分支状态：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch</span><br><span class=\"line\">  amazing_new_feature</span><br><span class=\"line\">* master</span><br></pre></td></tr></table></figure>\n<ul>\n<li>号表示当前活跃分支为master，使用git checkout切换分支。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout amazing_new_feature</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>合并分支 - git merge<br>我们的amazing_new_feature 分支的任务是增加一个featuer.txt。我们来创建，添加到暂存区，提交。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add feature.txt</span><br><span class=\"line\">$ git commit -m <span class=\"string\">\"New feature complete.\"</span></span><br></pre></td></tr></table></figure>\n<p>新分支任务完成了，回到master分支</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout master</span><br></pre></td></tr></table></figure>\n<p>现在去查看文件，你会发现，之前创建的feature.txt文件不见了，因为master分支上并没有feature.txt。使用git merge 把 amazing_new_feature 分支合并到master上。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git merge amazing_new_feature</span><br></pre></td></tr></table></figure>\n<p>ok!<br>然后再把amazing_new_feature 分支删掉吧。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch -d amazing_new_feature</span><br></pre></td></tr></table></figure>\n<h2 id=\"高级\"><a href=\"#高级\" class=\"headerlink\" title=\"高级\"></a>高级</h2><p>这篇文章的最后一节，我们来说些比较高级并且使用的技巧。</p>\n<ol>\n<li>比对两个不同提交之间的差别<br>每次提交都有一个唯一id，查看所有提交和他们的id，可以使用 git<br>log:</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log</span><br><span class=\"line\"></span><br><span class=\"line\">commit ba25c0ff30e1b2f0259157b42b9f8f5d174d80d7</span><br><span class=\"line\">Author: Tutorialzine</span><br><span class=\"line\"><span class=\"built_in\">Date</span>:   Mon May <span class=\"number\">30</span> <span class=\"number\">17</span>:<span class=\"number\">15</span>:<span class=\"number\">28</span> <span class=\"number\">2016</span> +<span class=\"number\">0300</span></span><br><span class=\"line\"></span><br><span class=\"line\">    New feature complete</span><br><span class=\"line\"></span><br><span class=\"line\">commit b10cc1238e355c02a044ef9f9860811ff605c9b4</span><br><span class=\"line\">Author: Tutorialzine</span><br><span class=\"line\"><span class=\"built_in\">Date</span>:   Mon May <span class=\"number\">30</span> <span class=\"number\">16</span>:<span class=\"number\">30</span>:<span class=\"number\">04</span> <span class=\"number\">2016</span> +<span class=\"number\">0300</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Added content to hello.txt</span><br><span class=\"line\"></span><br><span class=\"line\">commit <span class=\"number\">09</span>bd8cc171d7084e78e4d118a2346b7487dca059</span><br><span class=\"line\">Author: Tutorialzine</span><br><span class=\"line\"><span class=\"built_in\">Date</span>:   Sat May <span class=\"number\">28</span> <span class=\"number\">17</span>:<span class=\"number\">52</span>:<span class=\"number\">14</span> <span class=\"number\">2016</span> +<span class=\"number\">0300</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Initial commit</span><br></pre></td></tr></table></figure>\n<p>id 很长，但是你并不需要复制整个字符串，前一小部分就够了。查看某一次提交更新了什么，使用 git show:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git show b10cc123</span><br><span class=\"line\"></span><br><span class=\"line\">commit b10cc1238e355c02a044ef9f9860811ff605c9b4</span><br><span class=\"line\">Author: Tutorialzine</span><br><span class=\"line\"><span class=\"built_in\">Date</span>:   Mon May <span class=\"number\">30</span> <span class=\"number\">16</span>:<span class=\"number\">30</span>:<span class=\"number\">04</span> <span class=\"number\">2016</span> +<span class=\"number\">0300</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Added content to hello.txt</span><br><span class=\"line\"></span><br><span class=\"line\">diff --git a/hello.txt b/hello.txt</span><br><span class=\"line\">index e69de29..b546a21 <span class=\"number\">100644</span></span><br><span class=\"line\">--- a/hello.txt</span><br><span class=\"line\">+++ b/hello.txt</span><br><span class=\"line\">@@ <span class=\"number\">-0</span>,<span class=\"number\">0</span> +<span class=\"number\">1</span> @@</span><br><span class=\"line\">+Nice weather today, isn<span class=\"string\">'t it?</span></span><br></pre></td></tr></table></figure>\n<p>查看两次提交的不同，可以使用git diff [commit-from]..[commit-to] 语法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git diff <span class=\"number\">09</span>bd8cc..ba25c0ff</span><br><span class=\"line\"></span><br><span class=\"line\">diff --git a/feature.txt b/feature.txt</span><br><span class=\"line\"><span class=\"keyword\">new</span> file mode <span class=\"number\">100644</span></span><br><span class=\"line\">index <span class=\"number\">0000000.</span>.e69de29</span><br><span class=\"line\">diff --git a/hello.txt b/hello.txt</span><br><span class=\"line\">index e69de29..b546a21 <span class=\"number\">100644</span></span><br><span class=\"line\">--- a/hello.txt</span><br><span class=\"line\">+++ b/hello.txt</span><br><span class=\"line\">@@ <span class=\"number\">-0</span>,<span class=\"number\">0</span> +<span class=\"number\">1</span> @@</span><br><span class=\"line\">+Nice weather today, isn<span class=\"string\">'t it?</span></span><br></pre></td></tr></table></figure>\n<p>比较首次提交和最后一次提交，我们可以看到所有的更改。当然使用git difftool命令更加方便。</p>\n<ol start=\"2\">\n<li>回滚某个文件到之前的版本<br>git 允许我们将某个特定的文件回滚到特定的提交，使用的也是 git checkout。<br>下面的例子，我们将hello.txt回滚到最初的状态，需要指定回滚到哪个提交，以及文件的全路径。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout <span class=\"number\">09</span>bd8cc1 hello.txt</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>回滚提交<br>如果你发现最新的一次提交完了加某个文件，你可以通过 git commit —amend来修复，它会把最新的提交打回暂存区，并尝试重新提交。<br>如果是更复杂的情况，比如不是最新的提交了。那你可以使用git revert。<br>最新的一次提交别名也叫HEAD。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git revert HEAD</span><br></pre></td></tr></table></figure>\n<p>其他提交可以使用id:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git revert b10cc123</span><br></pre></td></tr></table></figure>\n<p>混滚提交时，发生冲突是非常频繁的。当文件被后面的提交修改了以后，git不能正确回滚。</p>\n<ol start=\"4\">\n<li>解决合并冲突<br>冲突经常出现在合并分支或者是拉去别人的代码。有些时候git能自动处理冲突，但大部分需要我们手动处理。<br>比如John 和 Tim<br>分别在各自的分支上写了两部分代码。<br>John 喜欢 for:</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Use a for </span></span><br><span class=\"line\">loop to <span class=\"built_in\">console</span>.log contents.</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;arr.length; i++) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Tim 喜欢 forEach:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Use forEach </span></span><br><span class=\"line\">to <span class=\"built_in\">console</span>.log contents.</span><br><span class=\"line\">arr.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>) </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(item);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>假设John 现在去拉取<br>Tim的代码:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git merge tim_branch</span><br><span class=\"line\"></span><br><span class=\"line\">Auto-merging print_array.js</span><br><span class=\"line\">CONFLICT (content): Merge conflict <span class=\"keyword\">in</span> print_array.js</span><br><span class=\"line\">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>\n<p>这时候git并不知道如何解决冲突，因为他不知道John和Tim谁写得更好。<br>于是它就在代码中插入标记。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class=\"line\">// Use a for loop to console.log contents.</span><br><span class=\"line\">for(var i=0; i&lt;arr.length; i++) &#123;</span><br><span class=\"line\">    console.log(arr[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">=======</span><br><span class=\"line\">// Use forEach to console.log contents.</span><br><span class=\"line\">arr.forEach(function(item) &#123;</span><br><span class=\"line\">    console.log(item);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;&gt; Tim s commit.</span><br></pre></td></tr></table></figure>\n<p>==== 号上方是当前最新一次提交，下方是冲突的代码。我们需要解决这样的冲突，经过组委会成员讨论，一致认定，在座的各位都是垃圾！两个都不要。改成下面的代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Not using for loop or forEach.</span></span><br><span class=\"line\"><span class=\"comment\">// Use Array.toString() to console.log contents.</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.toString());</span><br></pre></td></tr></table></figure>\n<p>好了，再提交一下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add -A</span><br><span class=\"line\">$ git commit -m <span class=\"string\">\"Array printing conflict resolved.\"</span></span><br></pre></td></tr></table></figure>\n<p>如果在大型项目中，这个过程可能容易出问题。你可以使用GUI 工具来帮助你。使用 git mergetool。</p>\n<ol start=\"5\">\n<li>配置 .gitignore<br>大部分项目中，会有写文件，文件夹是我们不想提交的。为了防止一不小心提交，我们需要gitignore文件：<br>在项目根目录创建.gitignore文件<br>在文件中列出不需要提交的文件名，文件夹名，每个一行<br>.gitignore文件需要提交，就像普通文件一样<br>通常会被ignore的文件有：<br>log文件<br>task runner<br>builds<br>node_modules等文件夹<br>IDEs生成的文件<br>个人笔记<br>例如：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*.log</span><br><span class=\"line\">build/</span><br><span class=\"line\">node_modules/</span><br><span class=\"line\">.idea/</span><br><span class=\"line\">my_notes.txt</span><br></pre></td></tr></table></figure>\n<p>总结<br>教程结束~(撒花)<br>git有点复杂，并且有一大堆特性和技巧等着你去挖掘，这篇文章只是提供冰山一角，希望你不要因为太多繁琐的命令而停下前进的脚步！<br>怀挺！<br>更多学习资源：</p>\n<ul>\n<li>git 官方文档</li>\n<li>git GUI工具</li>\n<li>在线创建.gitignore</li>\n<li>廖雪峰 git 教程</li>\n<li>图解git</li>\n</ul>\n<blockquote>\n<p>本文根据@Danny Markov的文章所译。英文出处：Learn Git in 30 Minutes  <a href=\"http://w3ctrain.com/2016/06/26/learn-git-in-30-minutes/\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n</blockquote>"},{"title":"第五届iWeb峰会议程概述","date":"2016-08-28T13:56:28.000Z","_content":"作为HTML5行业最具影响力的盛会之一，由HTML5梦工场举办的“2016 iWeb峰会·北京站”已成功举办，作为本届峰会规模最大、参会人数最多的主站——北京站，峰会当天行业各领域权威人士现场坐而论道，共同探讨HTML5最新技术与行业趋势，干货连连。\n<!--more-->\n## 准备 \n2016年8月27日8点半国际会议中心开始签到入场。\n9点一如既往的由h5女神娜姐开场。\n\n## 主题峰会\n\n### 《HTML5发行的力量》凌海（ 蝴蝶互动  CEO）\n印象最深的是凌海说的如何规避风险，如何做时间管理，举例说明了有投资方要求360出3年规划，3年对互联网来说时间太长了，3年可能发生很多事，风险是无法预知的；列举自己针对一个需要90天的项目，他们公司往往是比较慎重的，他们会把时间细化到30分钟，相比90天或者3年30分钟的风险是基本可以完全把控的。\n\n### 《2016：完善生态闭环，向全行业致敬》 陈书艺（白鹭时代 CEO）\n一个领先的html5移动技术与服务提供商，erget开放平台，出款多个游戏，什么暗黑之王，乱弹三国，稀有神传，小小战争，三国魂等，支持多种动画解决方案，平滑动画，可视化代码，专业游戏引擎。\nh5游戏行业有机遇也有挑战，性能的大幅提升和微信带来的流量都是h5游戏行业的机遇（流量变现等）\n### 《天下武功，唯快不破》 王哲（触控科技副总裁） \n他从h5游戏的性能方面做了分析，对于h5的未来，他报以谨慎乐观的态度。\n分析了h5游戏的性能方面：\n*  webGL性能提高 5~10倍 \n* Canvas 脏矩形算法 性能提高2倍\n*  内存占用降低5%\n* 包体减小30%\n\n### 《社交生态下的HTML5游戏辛新契机》李明 （很快CEO）\n“很快”鼓励开发者将技术转化为流量，并现场宣布，和9g合作，启动了亿元流量计划，为开发者提供流量。\n\n### 《HTML5和Docker容器如何重构和颠覆应用产业》 马科（WeX5 CEO ）\n首先这位被娜姐介绍说是“90后”CEO，引起现场一片轰动，90后出道的~ 哈哈\n从互联网的扩大入口：h5会导致病毒式传播，形成闭环，不像传统app的场景分割。还有云计算即未来和对新技术的思考：要从应用场景切入，而不是重复造轮子。\n对比了优秀app和传统app的区别， devops区别，这位干货很多。\n\n### 《web技术：一个挑战极限的创新平台》 江小丹（英特尔 web技术研发总监）\n提到了web前沿技术：web assembly nodejs 还有Intel在虚拟现实的技术尝试和酷炫的体验。\n\n### 《web 前端的是实时化》 肖光宇 （野狗实时 联合创始人）\n野狗是国内领先的实时后端云；野狗api--最实时通信api来了，应用于各大场景，可实时同步数据，网页通信，实时游戏，运用于汽车，实现实时同步汽车数据等。\n使用野狗API,可以获得实时后端云的两大功能\n*  实时通信 ，包括消息订阅，推送，双向通信等功能。网络延迟小，服务响应速度快，API简单易用。\n* 数据存储，提供了一个Key-Value的云端数据存储，直接通过API就可以对数据进行存取操作。操作简单，按需扩展。\n\n### 《移动互联网下半场-不用好HTML5，大部分公司都会死》王安（Dcloud CEO）\n互联网下半场，原生应用成本高，留存率低等问题已经显现。如何用HTML5解决这个问题呢？他提供的答案就是流应用。\n\n### 《H5游戏进入精品时代》谢成鸿 （LayaBox CEO ）\n这个比较接地气，说什么目的都是能挣钱，第一桶金开发一款小游戏赚到一点小钱650万。\nLayaBox阐述了未来游戏市场将呈现页游、手游、HTML5多端融合的趋势，强调了HTML5技术跨端、多屏、免下载等特点给游戏行业带来的革新性变化。在LayaBox看来，HTML5游戏是游戏市场上一课冉冉升起的新星，即将迎来爆发。同时，LayaBox也详细介绍了旗下第二代HTML5游戏引擎LayaAir，其支持Flash页游、APP手游、HTML5游戏 三端同发的特点和超越Unity3D的性能赢得了现场阵阵掌声。目前，LayaBox业务涵盖了引擎提供、游戏发行、游戏渠道、IP合作、项目投资、教育培训6大板块，是一家综合性的游戏服务企业。\n\n## 工具应用专场1\n### 《高性能HTML5 APP 开发云实践——基于完全开源的WeX5开发框架》 王洁  （WeX5  首席技术运营）\n主要对原生APP和hybrid app的比较，简述为解决白页多webview 实现转场动画等， 复杂效果native 实现，简单效果h5实现“重混” - wex5 “轻混”，只需前端调用，提供打包平台\nWeX5的可视化操作\nwex5，一个纯h5app开放平台，组件风格分离，基于css3，引入bootstrp资源，可快速开发。一次开发，全面拥有安卓app，苹果app，微信服务号。真正的html5 app开发云。\nHybrid App走向“轻混”，剖析WeX5开源高性能HTML5 App开发框架\n\n>  一. Hybrid App从“重混”到“轻混”的技术发展历程\n基本上从早期的多元化走向了只有Android和iOS两个系统的环境。对于开发者来说，就意味着一个App需要制定两套实现方案，这对开发成本和维护成本都是非常大的挑战。基于这样一个现实，其解决方案就是想办法实现套代码跨端运行，所以Hybrid APP混合应用模式应运而生\n在Hybrid APP发展早期，Web运行性能是当时的主要的瓶颈。Web在性能方面有缺陷，Web不够就用Native来凑，就是选择了用原生技术来弥补Web上的性能不足，其实就是多WebView。混合的单WebView最大的障碍就是页面切换，闪白很明显。手机里面又讲究用户交互体验，从一个页到另一个页想做个平滑的动画，用纯Web技术在当时的条件下是非常难以实现的，其实目前大多数框架也是这么做的，就是采用多WebView，这样可以平滑的转场。\n因为早期硬件比较差，浏览器性能也一般般，所以有一些比较复杂的组件在实现一些功能的时候，速度比较慢。当时框架里是用NativeUI组件来弥补的，配合Web来实现这些功能。这种模式被定义为“重混”，用原生的能力去弥补UI，或者技术更偏Native的框架就被定义为重混的Hybrid App框架。\n重混框架优缺点很明显，优点是提升了运行性能、增强了交互。缺点是Web和Native技术交叉混杂，增加了开发人员的工作难度。但是，当下的手机硬件配置已经有了很大的改善，包括浏览器技术的发展也很重要，在GS引擎方面都有长足的进步。实现功能的时候用Web的技术的前提下已经不再需要Native技术来弥补了，随着技术的发展，性能已经不再是瓶颈。\n\n> 另一个改变了移动应用这一领域的进程事件是，自从微信推出以后，相当于重新定义了移动应用的概念，通过它的服务号、公众号、企业号，微信本身变成了一种应用平台。包括微信最新的版本更新，它浏览器内核的升级，包括对游戏的支持，都和大量的移动App开发有着莫大的关联。而这个时候重混的框架就显得多余了，因为在重混框架里面很多性能的解决是依赖Native的原生部分。而到了微信里面，多WebView和NativeUI都没有了。原来在重混框架里面很强的一些能力完全就消失了，这时候在微信里面就有很多能力就不能用了。\n于是轻混就成了目前真正要跨端Hybrid App的必然选择，这时候轻混的UI部分必须用纯Web技术，在底层的设备接口上，GS无法完成的原生部分需要Native技术来弥补。需要强调的是，Native的技术是不应该去侵入UI的，这样的一个框架就是我们所说的轻混Hybrid App框架，这才是真正的HTML5 App框架。\n\n> 二.构建高性能HTML5 App跨端框架\n伴随着以上的观点，接下来谈谈如何构建轻混模式下的HTML5 App框架。这种混合框架很简单，首先要有一个内置了浏览器的外壳，在浏览器里提供网页运行环境，同时在这个外壳上提供很多插件，可以让网络通过GS进行操作。\n基于这样的认识，王洁说，在选择HTML5框架设计的时候，要解决两个框架的问题，一个是HTML5的框架，一个是Native的框架。首先看Native框架的选择，选择PhoneGap框架，受到了业内主流厂商支持，微软也是用Cordova，它的插件框架是开放的，很容易自定义。\n另外就是要解决HTML5的一些性能问题，如果不采用重混架构的话，在页面切换还是会有一些障碍，王洁说到，WeX5采用SPA单页应用模式，它是基于传统的页面加载模式MPA，页面之间互相独立。但是SPA的不同之处在于，其框架里整个页面是由外壳页面框架组成的，是用AJAX技术完成的，AJAX在桌面时代就存在，通过局部刷新来提升用户体验。但是把AJAX技术最大化来使用，整个页面框架都用AJAX来实现，每个页面的加载都是这样的方式。\n对设备的局部渲染，可以在加载的时候在后面预加载再做转场动画，而且还不需要依赖多Web应用，不需要依赖Native就可以完成。而且在加载多页框架时每个页面的共用功能要重复加载。所以从各方面来说SPA相对于MPA是有极大的性能提升的。\nSPA确实很好用，但是在设计产品的时候需要考虑到多人协作过程中，支持复杂应用的开发过程中，会不会出现多个ID会冲突，样式冲突，JS冲突等等致命问题？所以下面就谈到了页面隔离的问题。\n解决这样棘手的问题，王洁说，首先要考虑到HTML元素ID冲突的问题，因为是可视化工具，所以ID属性的设计是拖到一个属性栏里去定义ID，这时候刚好可以用一个替换原则，用了XID来替换，不会直接设定ID属性。这样到内存里，会动态的生成真实的ID，会在XID后面加一个页面标志，这样可以保证多人写的页面在加载内存里ID是不相同的，也就不存在冲突。当然提供一些API的时候是能拿到真实ID，对应相应的元素，不影响访问。在整个组件体系里，开发者利用很简单的方法就可以拿到组件，可以很平滑的解决掉ID冲突的问题。\nCSS样式冲突问题分为两类，一类样式是共用样式，多页面引用同一个页面；另一类样式被定义为私有样式，只使用页面，但不希望这个页面干扰到其他页面。这时候给每个页面都配了一个CSS文件，定义私有样式，限定在当前页面。实现起来也很简单，通过对工具的编译，把私有CSS文件里的所有样式加一个页面标志，在页面节点的属性上加一个标志，这样就使得class只能作用于当前页面的HTML元素，这就成为了一个私有样式。\n然后是JavaScript问题，现在JavaScript模块化技术很流行，借用JavaScript模块化技术，解决JavaScript隔离问题。王洁在这里顺便把RequireJS简单的提了一下，通过define可以定义模块，在RequireJS定义里，这个大括号里的才是模块里的代码。不管是方法还是变量，都封装在闭包里，每个代码都是写在define的模块里，这样就把代码自然隔离了。\n王洁说他们在外围还做了一些工作，首先是实现完整的外壳管理，Shell类提供外壳管理。为了防止信息泄露，在配置的时候确实会把页面完整卸载掉。当加载页面片断时，会从当前外壳数把JS删掉，页面加载的时候创建的JS对象都会完整的释放掉，这是由框架来保证的。另外是路由的问题，在SPA单页面框架里路由是很重要的，因为是单页面应用，加载的页面都是片断，其实UI地址一直是外壳的地址。\n下图是整体框架的架构。黄色部分用的是Cordova，解决安卓和苹果的原生调用问题。同时要兼容微信，所以上面把Cordova和微信又做了封装，抽象成统一的HTML5 API。如果通过统一的Native API去拍照，会自动根据页面环境，通过Cordova接口调用，这样可以更方便的实现一次开发，多端运行，代码不需要改，既可以运行在原生App里，也可以运行在微信里。包括拍照、GPS地图，一系列的API都可以进统一分装。\nBootstrap在这里提供了几个能力。一个是样式美化，扁平化风格，另外响应式布局。基于Bootstrap设计的页面，运行在不同的设备上不需要考虑分辨率，会自动处理设备分辨率。再上面实现了WeX5的组件框架和数据框架，页面上不仅有交互的UI组件，页面里面还有数据。接下来是业务框架层，即SPA单元页面框架。在服务端WeX5还提供了XBaaS服务，负责后端数据存取、逻辑，还有第三方地图、支付等功能实现。WeX5提供多语言实现，提供了不同语言的版本，开发者可以针对自己的版本来集成到自己的框架里。\n> 三、WeX5可视化快速开发实践\n在分享的最后，王洁给大家展示了基于WeX5这样的框架所开发出来的一些功能。首先是可视化的快速开发程度，帮助开发者通过可视化开发定义页面，框架可以保证运行体验，必须能快速加载，而且各种首试、硬件能力的是一体化集成的。把组件拖到表单上定义布局，设置属性，即可得到最终页面，设计室和运行室相邻，完全所见即所得。\n丰富多样的组件，足以适应各种复杂表单的组合。通过把常见功能组件封装，可以极大减轻开发者的开发工作量。最关键的是整个组件框架完全开源，除了WeX5提供的上百个组件以外开发者还可以自己定义这个可视化组件，甚至可以继承第三方组件，通过规范的方式封装成HTML5的可视化组件。\n编程问题也是重点，WeX5的定位是可视化程度更高的前端编程工具。不仅可以可视化设计，编程也是便捷。它能实现代码的智能提示、代码模板，还内致了Emmet框架。随后考虑的是调试问题，WeX5是一体化的环境，不仅要解决开发、编程，还要解决调试的过程，既可以在Web浏览器上调试，也可以连到手机上调试，所有代码都是开源的，底层内库也是开放的。最后就是打包的问题，打包要考虑很多插件的配置，参数，资源在命令行的配合。WeX5提供了一个打包的向导，完全本地打包，不需要依赖云打包服务，只需要把打包过程中要设置的东西完全工具化，可以设置应用版本、证书、LOGO、图片、插件里的参数，最后就可以应用到App上。\n\n### 《web技术推进多样化人机交互方式》吴栋夏 （英特尔  软件工程师）\n讲述了Intel的各种“黑科技”，还介绍了关于深度增强摄像，场景感知与模型，crosswalk，nw.js\ncrosswalk\nnwjs\nnwjs是在英特尔开源技术中心创建的，它是基于谷歌浏览器核心引擎和nodejs运行，你可以通过nwjs技术使用html和js语言编写本地应用程序，它也可以让你直接从DOM调用nodejs模块，使用一种新的方式与所有的Web技术编写本地应用。它主要有以下6个特点：\n* 以网络最流行的技术编写原生应用程序的新方法\n* 基于HTML5, CSS3, JS and WebGL而编写\n* 完全支持nodejs所有api及第三方模块\n* 可以使用DOM直接调用nodejs模块\n* 容易打包和分发\n* 支持运行环境包括32位和64位的Window、Linux和Mac OS\n### 《Yo-去哪儿移动UI框架》 杜瑶（去哪儿网  前端开发总监）\n瑶姐机智自不必说，网红魅力；\nYO 一款基于Sass开发的css框架，用于快速构建移动UI项目\nmobile First\nwhy mobile First (以mobile作为基准的设计为出发点)\n公司战略转移\n新战场需要有力的框架抹平平台切换所带来的适应过程\npc端已有成熟的解决方案，无需推倒重来\n专注于某一具体的领域更能变得专业\nmobile First 的好处\n可以减少对历史问题的考虑，不如不用考虑IE\n保证交互方式的单一性，不用考虑PC上的交互行为\n更及时的应用上新技术\n代码更轻量\n\nios 默认风格\nwhy ios\n巨量的ios用户（超过50%）\n安卓碎片化过重，不易挑选标示\nios的交互及展现更具备普适性\n\nPure CSS 纯粹的css 框架\nwhy pure css\n职能更分明\n能被使用在任何项目中\n不紧密捆绑UI组件\n\n分层设计\nYo将不同的功能拆解成结构清晰的类别分散到不同的层去进行处理\n\nyo|---usage\n|---lib\n\n分层设计的意义\n清晰的依赖\n高度解耦\n高度复用\n高可移植性\n结束混乱的文件引用\n\nrem+px\n\n边框厚度使用px单位\n字体，大小等除边框厚度外的定义使用rem\n解决实现retina屏真正的1px 边框问题\n\n封装了丰富的常规问题解决方案\n\n独立配置层设计 config\n\n厂商前缀\niconfont\n响应式\n\n元件\n\n扩展 超扩展\n\n动画库\n\n### 《手机QQ react web极致优化》李成熙（Alloyteam工程师）\n讲述了手机QQ在react框架下的全家桶开发套件，以及踩过得各种坑和性能的极致优化\n资料参考http://dev.qq.com/topic/579083d1c9da73584b02587d\nreact 全家桶\n在手Q家校群重构之前，其实我们已经做了一版PC家校群。当时将native的页面全部web化，直接就采用了React比较常用的全家桶套装：\n* 构建工具 => gulp + webpack\n* 开发效率提升 => redux-dev-tools + hot-reload\n* 统一数据管理=> redux\n* 性能提升 => immutable + purerender\n* 路由控制器 => react-router(手Q暂时没采用)\n\n构建工具目录结构\n\nReact 优化三大方向\n\n状态/数据管理优化\n\n针对React的这个数据比较的深比较deepCompare，要点有2个：\n* 尽量使传入的数据扁平化一点\n* 比较的时候做一些限制，避免溢出栈\n\n渲染性能优化\n\n首屏性能优化\n\n针对有cgi请求，需要吐大量数据的页面--同构直出\n有几点值得说明：\n比改造以前的项目，做直出更容易\n减少的是首屏显示实践，而非首屏可交互时间\n页面吐出html字符串之后，还需要在客户端，加载react包，进行事件绑定\n做bigPipe之类的优化较难\n\nreact同构直出文章\n《React同构直出优化总结》http://www.alloyteam.com/2016/06/react-isomorphic/?utm_source=tuicool&utm_medium=referral\n《腾讯新闻React同构直出优化实践》 http://www.alloyteam.com/2016/06/tencent-news-react-isomorphic-straight-out-optimization/?utm_source=tuicool&utm_medium=referral\n拆包\n不用react-router，如何拆包？\n\n非基础功能，如运营活动 ---轻量化类react方案\nPreact---压缩后只有10kb，gzip后3kb\n开源社区有较多的star（认可）\n较好的性能和兼容性\napi跟React接近\n足够的框架周边，配置redux，router等使用，还有同构直出的插件\n团队成员有能力维护的\n作者参考文章《Preact-React的轻量解决方案》https://github.com/lcxfs1991/blog/issues/13?utm_source=tuicool&utm_medium=referral\n简单回购\n\nStarter-Kit\nsteamer-react\nhttps://github.com/SteamerTeam/steamer-react/tree/react-preact\nweb分支，同构分支，preact兼容分支\n腾讯发起的交流会 将于2016-10-23 日举行\n\n### 《手机淘宝营销互动页面的最佳实践》黄华健（阿里巴巴  前端工程师）\n> 呆萌的前端工程师 讲的很棒很棒\n\n他鼓励前端开发者们沉淀出自己的最佳实践，同时大家可以去看一下他们开源的解决方案：站在巨人的肩膀上才能看得更远\n对比以前需求来了-干活的工作模式，工程化-自动化工作流能提高效率即新一代构建工具 rollup （参考文章 http://jixianqianduan.com/frontend-build/2016/01/20/next-generation-js-module-bunlder.html?utm_source=tuicool&utm_medium=referral）\n\n解析ES2015Module\nTree-shaking\n\n再来总结下rollup： - 支持ES6模块规范打包成其它任一格式规范 - 支持tree-shaking方式打包 - 方便接入构建，如gulp - 需要书写配置任务\n索性github上有demo，我还没有来的及实践，抛链接\n[手机淘宝营销互动脚手架](https://github.com/amfe/activity-template)\n\n### 《从MI Cloud的架构变迁看大型spa的复杂工程如何化简》陈恺睿 （小米 高级前端工程师）\nMi Cloud的主站就是这样的一个大型的SPA，它主要定位于PC端，PC端包括Web版和桌面应用，同时也兼顾一下移动端。Mi Cloud也正在基于electron开发一个桌面应用\n第一次重构\n用CommonJS和browserify实现模块化方案，基于grunt实现自动化构建流程 替代之前满屏jquery 操作dom\n第二次重构\n又对工程基础做了进一步的升级，采用标准的ES6的模块规范，加上更强大的webpack实现模块化方案，基于gulp实现自动化构建流程，完全是流式处理，减少硬盘IO，开发环境下进行一次实时编译从原来的20s左右压缩到1s内。最近几年，前端领域新技术层出不穷，其中不乏实实在在能提高生产力的方案，从browserify+grunt到webpack+gulp就是这样一个典型的例子，从backbone到angular再到react+redux也是一个典型的例子。\n然后开始拿业务层开刀。当时恰好有一个业务要做比较大的改版，于是我开始基于Backbone实现MVC架构。\n得到的是一个基于Backbone的MVC架构\n\n完整的流程：\n首先用户操作了界面，比如一个点击，view层抛出事件告诉controller，controller调用model层某个实例的方法，让model层向服务器操作，完了之后，model层抛出事件告诉controller，controller调用view层某个实例的方法，更新界面。\n其实，我在实践这套MVC架构的时候，也一直觉得controller部分太复杂，仔细分析一下，controller内主要分为两套流程：步骤2，3是一套流程；步骤5，6是另一套流程。这两套流程其实是互相独立的、互不干涉的，但都流经同一个节点，这无疑加剧了这个节点的复杂度。\nmodel层和view层不知道彼此的存在，甚至不知道controller的存在，它们只是通过抛出事件通知外界自己处于什么状态，比如view中的哪个按钮被点击了，model中的哪个字段有更新了。它们不关心谁监听这些事件。\n好处：\n* model层和view层完全分离，可以由不同的人并行开发\n* 可以不依赖走通整个流程来测试，model层和controller完全没有DOM操作，可以实现自动化的单元测试\n* 要增加或删除功能，只需要开始或停止监听事件即可，层与层之间解耦之后很容易实现对某一部分的替换、增减\n\n\n于是我将controller的两套流程分离一下，各司其职。\n这样，不管是从model层到view层的数据流，还是从view层到model层的数据流，虽然这两个数据流的起点和终点是对调过来的，但它们流经的节点不一样，这样就清晰了很多。\n熟悉react和redux的朋友，可能看这幅图会比较眼熟。是的，这个时候已经形成了一个单向数据流的闭环。其实，当时我也不知道这会形成所谓的单向数据流，只是在探索怎么化简复杂度罢了。\n架构演变到这一步，其实已经开始了第二轮重构，当时还是2015年夏天，我开始热火朝天的写一些demo尝试这个架构模式。\n另一方面，我已经开始尝试将view层组件化，也就是将一个个视图类实现成可组合可嵌套的，在通用的视图类上实现了一套添加子组件/移除子组件等等的API，将整个界面实现成一个个视图实例组成的树状结构。\n但其中一直有一些痛点，其中以view层的痛点最加剧业务的复杂度。\n\n\n\n于是在view层我改成使用react来实现。业务层只需要写全量渲染的代码，再也不用写局部更新的代码了，框架自己会帮业务层对DOM做局部更新。手动点个赞。\n网上也有很多使用backbone的model配合react的文章，其实就类似于我们的架构演变到这一步时的方案。\n于是我继续实践，很快又挖出了一个痛点。。\n更新组件树中的深层节点时很麻烦。\n一开始的做法是，从组件树的根节点一层层的往下传数据，这显然很麻烦。\n再次带着问题寻找解决方案。此时redux框架经过多次迭代之后，开始成熟、稳定下来，我发现redux提供的connect函数正好能让我直接把数据传递给组件树中的深层节点。\n于是我引入了redux，最终项目的架构就变成了这样\n\n\n除了为业务降低复杂度的框架，大型SPA的未来还有很多挑战。比如：\n\n* 强类型，静态类型检查\n* 异常处理的最佳实践\n* 自动化测试的健全：因为基于react这种视图层框架几乎不需要操作DOM，基于redux这种函数式编程思想的框架管理整个应用的状态，副作用和状态都得到很好的控制\n控制复杂度的心得。\n\n* 分治：不管多么庞大的问题，咋一看很复杂，但把它切割成一个个小问题之后，局面就变得清晰了很多。模块化、组件化都是这个思路，我觉得前端的路由也体现了分治的思想，把路由看作一个有限状态机，它就将应用的生命周期划分成了几个大的状态。\n* 善于利用巨人的肩膀：其实，复杂度并不会减少，它只会从一个地方转移到另一个地方，复用组件如此，框架为业务层封装复杂性也是如此，所以，善于利于巨人的肩膀，因为它已经帮你转移了复杂度。\n* 先确认瓶颈再做性能优化：虽然是老生常谈，但还是要强调一下，因为真的很有用但又很容易忘记。\n* 二八原则：考虑项目的生命周期、影响力来衡量投入的资源，好钢用在刀刃上，我个人感觉小米挺强调成本控制的，毕竟我们是创业公司，跟大公司可以适当冗余不太一样。\n\n### 《UC前端业务套件体系》三桥（阿里巴巴UC移动事业群  高级前端工程师）\n三桥大神主要讲的偏架构方向，也接近了尾声，实在太累没做过多记录。这里就不在提供摘要，近期会提供相关PPT。\n> 很可惜，只参与了工具1的分会场\n更多内容以及PPT会近期发布。","source":"_posts/第五届iWeb峰会议程概述.md","raw":"---\ntitle: 第五届iWeb峰会议程概述\ndate: 2016-08-28 21:56:28\ntags:\n---\n作为HTML5行业最具影响力的盛会之一，由HTML5梦工场举办的“2016 iWeb峰会·北京站”已成功举办，作为本届峰会规模最大、参会人数最多的主站——北京站，峰会当天行业各领域权威人士现场坐而论道，共同探讨HTML5最新技术与行业趋势，干货连连。\n<!--more-->\n## 准备 \n2016年8月27日8点半国际会议中心开始签到入场。\n9点一如既往的由h5女神娜姐开场。\n\n## 主题峰会\n\n### 《HTML5发行的力量》凌海（ 蝴蝶互动  CEO）\n印象最深的是凌海说的如何规避风险，如何做时间管理，举例说明了有投资方要求360出3年规划，3年对互联网来说时间太长了，3年可能发生很多事，风险是无法预知的；列举自己针对一个需要90天的项目，他们公司往往是比较慎重的，他们会把时间细化到30分钟，相比90天或者3年30分钟的风险是基本可以完全把控的。\n\n### 《2016：完善生态闭环，向全行业致敬》 陈书艺（白鹭时代 CEO）\n一个领先的html5移动技术与服务提供商，erget开放平台，出款多个游戏，什么暗黑之王，乱弹三国，稀有神传，小小战争，三国魂等，支持多种动画解决方案，平滑动画，可视化代码，专业游戏引擎。\nh5游戏行业有机遇也有挑战，性能的大幅提升和微信带来的流量都是h5游戏行业的机遇（流量变现等）\n### 《天下武功，唯快不破》 王哲（触控科技副总裁） \n他从h5游戏的性能方面做了分析，对于h5的未来，他报以谨慎乐观的态度。\n分析了h5游戏的性能方面：\n*  webGL性能提高 5~10倍 \n* Canvas 脏矩形算法 性能提高2倍\n*  内存占用降低5%\n* 包体减小30%\n\n### 《社交生态下的HTML5游戏辛新契机》李明 （很快CEO）\n“很快”鼓励开发者将技术转化为流量，并现场宣布，和9g合作，启动了亿元流量计划，为开发者提供流量。\n\n### 《HTML5和Docker容器如何重构和颠覆应用产业》 马科（WeX5 CEO ）\n首先这位被娜姐介绍说是“90后”CEO，引起现场一片轰动，90后出道的~ 哈哈\n从互联网的扩大入口：h5会导致病毒式传播，形成闭环，不像传统app的场景分割。还有云计算即未来和对新技术的思考：要从应用场景切入，而不是重复造轮子。\n对比了优秀app和传统app的区别， devops区别，这位干货很多。\n\n### 《web技术：一个挑战极限的创新平台》 江小丹（英特尔 web技术研发总监）\n提到了web前沿技术：web assembly nodejs 还有Intel在虚拟现实的技术尝试和酷炫的体验。\n\n### 《web 前端的是实时化》 肖光宇 （野狗实时 联合创始人）\n野狗是国内领先的实时后端云；野狗api--最实时通信api来了，应用于各大场景，可实时同步数据，网页通信，实时游戏，运用于汽车，实现实时同步汽车数据等。\n使用野狗API,可以获得实时后端云的两大功能\n*  实时通信 ，包括消息订阅，推送，双向通信等功能。网络延迟小，服务响应速度快，API简单易用。\n* 数据存储，提供了一个Key-Value的云端数据存储，直接通过API就可以对数据进行存取操作。操作简单，按需扩展。\n\n### 《移动互联网下半场-不用好HTML5，大部分公司都会死》王安（Dcloud CEO）\n互联网下半场，原生应用成本高，留存率低等问题已经显现。如何用HTML5解决这个问题呢？他提供的答案就是流应用。\n\n### 《H5游戏进入精品时代》谢成鸿 （LayaBox CEO ）\n这个比较接地气，说什么目的都是能挣钱，第一桶金开发一款小游戏赚到一点小钱650万。\nLayaBox阐述了未来游戏市场将呈现页游、手游、HTML5多端融合的趋势，强调了HTML5技术跨端、多屏、免下载等特点给游戏行业带来的革新性变化。在LayaBox看来，HTML5游戏是游戏市场上一课冉冉升起的新星，即将迎来爆发。同时，LayaBox也详细介绍了旗下第二代HTML5游戏引擎LayaAir，其支持Flash页游、APP手游、HTML5游戏 三端同发的特点和超越Unity3D的性能赢得了现场阵阵掌声。目前，LayaBox业务涵盖了引擎提供、游戏发行、游戏渠道、IP合作、项目投资、教育培训6大板块，是一家综合性的游戏服务企业。\n\n## 工具应用专场1\n### 《高性能HTML5 APP 开发云实践——基于完全开源的WeX5开发框架》 王洁  （WeX5  首席技术运营）\n主要对原生APP和hybrid app的比较，简述为解决白页多webview 实现转场动画等， 复杂效果native 实现，简单效果h5实现“重混” - wex5 “轻混”，只需前端调用，提供打包平台\nWeX5的可视化操作\nwex5，一个纯h5app开放平台，组件风格分离，基于css3，引入bootstrp资源，可快速开发。一次开发，全面拥有安卓app，苹果app，微信服务号。真正的html5 app开发云。\nHybrid App走向“轻混”，剖析WeX5开源高性能HTML5 App开发框架\n\n>  一. Hybrid App从“重混”到“轻混”的技术发展历程\n基本上从早期的多元化走向了只有Android和iOS两个系统的环境。对于开发者来说，就意味着一个App需要制定两套实现方案，这对开发成本和维护成本都是非常大的挑战。基于这样一个现实，其解决方案就是想办法实现套代码跨端运行，所以Hybrid APP混合应用模式应运而生\n在Hybrid APP发展早期，Web运行性能是当时的主要的瓶颈。Web在性能方面有缺陷，Web不够就用Native来凑，就是选择了用原生技术来弥补Web上的性能不足，其实就是多WebView。混合的单WebView最大的障碍就是页面切换，闪白很明显。手机里面又讲究用户交互体验，从一个页到另一个页想做个平滑的动画，用纯Web技术在当时的条件下是非常难以实现的，其实目前大多数框架也是这么做的，就是采用多WebView，这样可以平滑的转场。\n因为早期硬件比较差，浏览器性能也一般般，所以有一些比较复杂的组件在实现一些功能的时候，速度比较慢。当时框架里是用NativeUI组件来弥补的，配合Web来实现这些功能。这种模式被定义为“重混”，用原生的能力去弥补UI，或者技术更偏Native的框架就被定义为重混的Hybrid App框架。\n重混框架优缺点很明显，优点是提升了运行性能、增强了交互。缺点是Web和Native技术交叉混杂，增加了开发人员的工作难度。但是，当下的手机硬件配置已经有了很大的改善，包括浏览器技术的发展也很重要，在GS引擎方面都有长足的进步。实现功能的时候用Web的技术的前提下已经不再需要Native技术来弥补了，随着技术的发展，性能已经不再是瓶颈。\n\n> 另一个改变了移动应用这一领域的进程事件是，自从微信推出以后，相当于重新定义了移动应用的概念，通过它的服务号、公众号、企业号，微信本身变成了一种应用平台。包括微信最新的版本更新，它浏览器内核的升级，包括对游戏的支持，都和大量的移动App开发有着莫大的关联。而这个时候重混的框架就显得多余了，因为在重混框架里面很多性能的解决是依赖Native的原生部分。而到了微信里面，多WebView和NativeUI都没有了。原来在重混框架里面很强的一些能力完全就消失了，这时候在微信里面就有很多能力就不能用了。\n于是轻混就成了目前真正要跨端Hybrid App的必然选择，这时候轻混的UI部分必须用纯Web技术，在底层的设备接口上，GS无法完成的原生部分需要Native技术来弥补。需要强调的是，Native的技术是不应该去侵入UI的，这样的一个框架就是我们所说的轻混Hybrid App框架，这才是真正的HTML5 App框架。\n\n> 二.构建高性能HTML5 App跨端框架\n伴随着以上的观点，接下来谈谈如何构建轻混模式下的HTML5 App框架。这种混合框架很简单，首先要有一个内置了浏览器的外壳，在浏览器里提供网页运行环境，同时在这个外壳上提供很多插件，可以让网络通过GS进行操作。\n基于这样的认识，王洁说，在选择HTML5框架设计的时候，要解决两个框架的问题，一个是HTML5的框架，一个是Native的框架。首先看Native框架的选择，选择PhoneGap框架，受到了业内主流厂商支持，微软也是用Cordova，它的插件框架是开放的，很容易自定义。\n另外就是要解决HTML5的一些性能问题，如果不采用重混架构的话，在页面切换还是会有一些障碍，王洁说到，WeX5采用SPA单页应用模式，它是基于传统的页面加载模式MPA，页面之间互相独立。但是SPA的不同之处在于，其框架里整个页面是由外壳页面框架组成的，是用AJAX技术完成的，AJAX在桌面时代就存在，通过局部刷新来提升用户体验。但是把AJAX技术最大化来使用，整个页面框架都用AJAX来实现，每个页面的加载都是这样的方式。\n对设备的局部渲染，可以在加载的时候在后面预加载再做转场动画，而且还不需要依赖多Web应用，不需要依赖Native就可以完成。而且在加载多页框架时每个页面的共用功能要重复加载。所以从各方面来说SPA相对于MPA是有极大的性能提升的。\nSPA确实很好用，但是在设计产品的时候需要考虑到多人协作过程中，支持复杂应用的开发过程中，会不会出现多个ID会冲突，样式冲突，JS冲突等等致命问题？所以下面就谈到了页面隔离的问题。\n解决这样棘手的问题，王洁说，首先要考虑到HTML元素ID冲突的问题，因为是可视化工具，所以ID属性的设计是拖到一个属性栏里去定义ID，这时候刚好可以用一个替换原则，用了XID来替换，不会直接设定ID属性。这样到内存里，会动态的生成真实的ID，会在XID后面加一个页面标志，这样可以保证多人写的页面在加载内存里ID是不相同的，也就不存在冲突。当然提供一些API的时候是能拿到真实ID，对应相应的元素，不影响访问。在整个组件体系里，开发者利用很简单的方法就可以拿到组件，可以很平滑的解决掉ID冲突的问题。\nCSS样式冲突问题分为两类，一类样式是共用样式，多页面引用同一个页面；另一类样式被定义为私有样式，只使用页面，但不希望这个页面干扰到其他页面。这时候给每个页面都配了一个CSS文件，定义私有样式，限定在当前页面。实现起来也很简单，通过对工具的编译，把私有CSS文件里的所有样式加一个页面标志，在页面节点的属性上加一个标志，这样就使得class只能作用于当前页面的HTML元素，这就成为了一个私有样式。\n然后是JavaScript问题，现在JavaScript模块化技术很流行，借用JavaScript模块化技术，解决JavaScript隔离问题。王洁在这里顺便把RequireJS简单的提了一下，通过define可以定义模块，在RequireJS定义里，这个大括号里的才是模块里的代码。不管是方法还是变量，都封装在闭包里，每个代码都是写在define的模块里，这样就把代码自然隔离了。\n王洁说他们在外围还做了一些工作，首先是实现完整的外壳管理，Shell类提供外壳管理。为了防止信息泄露，在配置的时候确实会把页面完整卸载掉。当加载页面片断时，会从当前外壳数把JS删掉，页面加载的时候创建的JS对象都会完整的释放掉，这是由框架来保证的。另外是路由的问题，在SPA单页面框架里路由是很重要的，因为是单页面应用，加载的页面都是片断，其实UI地址一直是外壳的地址。\n下图是整体框架的架构。黄色部分用的是Cordova，解决安卓和苹果的原生调用问题。同时要兼容微信，所以上面把Cordova和微信又做了封装，抽象成统一的HTML5 API。如果通过统一的Native API去拍照，会自动根据页面环境，通过Cordova接口调用，这样可以更方便的实现一次开发，多端运行，代码不需要改，既可以运行在原生App里，也可以运行在微信里。包括拍照、GPS地图，一系列的API都可以进统一分装。\nBootstrap在这里提供了几个能力。一个是样式美化，扁平化风格，另外响应式布局。基于Bootstrap设计的页面，运行在不同的设备上不需要考虑分辨率，会自动处理设备分辨率。再上面实现了WeX5的组件框架和数据框架，页面上不仅有交互的UI组件，页面里面还有数据。接下来是业务框架层，即SPA单元页面框架。在服务端WeX5还提供了XBaaS服务，负责后端数据存取、逻辑，还有第三方地图、支付等功能实现。WeX5提供多语言实现，提供了不同语言的版本，开发者可以针对自己的版本来集成到自己的框架里。\n> 三、WeX5可视化快速开发实践\n在分享的最后，王洁给大家展示了基于WeX5这样的框架所开发出来的一些功能。首先是可视化的快速开发程度，帮助开发者通过可视化开发定义页面，框架可以保证运行体验，必须能快速加载，而且各种首试、硬件能力的是一体化集成的。把组件拖到表单上定义布局，设置属性，即可得到最终页面，设计室和运行室相邻，完全所见即所得。\n丰富多样的组件，足以适应各种复杂表单的组合。通过把常见功能组件封装，可以极大减轻开发者的开发工作量。最关键的是整个组件框架完全开源，除了WeX5提供的上百个组件以外开发者还可以自己定义这个可视化组件，甚至可以继承第三方组件，通过规范的方式封装成HTML5的可视化组件。\n编程问题也是重点，WeX5的定位是可视化程度更高的前端编程工具。不仅可以可视化设计，编程也是便捷。它能实现代码的智能提示、代码模板，还内致了Emmet框架。随后考虑的是调试问题，WeX5是一体化的环境，不仅要解决开发、编程，还要解决调试的过程，既可以在Web浏览器上调试，也可以连到手机上调试，所有代码都是开源的，底层内库也是开放的。最后就是打包的问题，打包要考虑很多插件的配置，参数，资源在命令行的配合。WeX5提供了一个打包的向导，完全本地打包，不需要依赖云打包服务，只需要把打包过程中要设置的东西完全工具化，可以设置应用版本、证书、LOGO、图片、插件里的参数，最后就可以应用到App上。\n\n### 《web技术推进多样化人机交互方式》吴栋夏 （英特尔  软件工程师）\n讲述了Intel的各种“黑科技”，还介绍了关于深度增强摄像，场景感知与模型，crosswalk，nw.js\ncrosswalk\nnwjs\nnwjs是在英特尔开源技术中心创建的，它是基于谷歌浏览器核心引擎和nodejs运行，你可以通过nwjs技术使用html和js语言编写本地应用程序，它也可以让你直接从DOM调用nodejs模块，使用一种新的方式与所有的Web技术编写本地应用。它主要有以下6个特点：\n* 以网络最流行的技术编写原生应用程序的新方法\n* 基于HTML5, CSS3, JS and WebGL而编写\n* 完全支持nodejs所有api及第三方模块\n* 可以使用DOM直接调用nodejs模块\n* 容易打包和分发\n* 支持运行环境包括32位和64位的Window、Linux和Mac OS\n### 《Yo-去哪儿移动UI框架》 杜瑶（去哪儿网  前端开发总监）\n瑶姐机智自不必说，网红魅力；\nYO 一款基于Sass开发的css框架，用于快速构建移动UI项目\nmobile First\nwhy mobile First (以mobile作为基准的设计为出发点)\n公司战略转移\n新战场需要有力的框架抹平平台切换所带来的适应过程\npc端已有成熟的解决方案，无需推倒重来\n专注于某一具体的领域更能变得专业\nmobile First 的好处\n可以减少对历史问题的考虑，不如不用考虑IE\n保证交互方式的单一性，不用考虑PC上的交互行为\n更及时的应用上新技术\n代码更轻量\n\nios 默认风格\nwhy ios\n巨量的ios用户（超过50%）\n安卓碎片化过重，不易挑选标示\nios的交互及展现更具备普适性\n\nPure CSS 纯粹的css 框架\nwhy pure css\n职能更分明\n能被使用在任何项目中\n不紧密捆绑UI组件\n\n分层设计\nYo将不同的功能拆解成结构清晰的类别分散到不同的层去进行处理\n\nyo|---usage\n|---lib\n\n分层设计的意义\n清晰的依赖\n高度解耦\n高度复用\n高可移植性\n结束混乱的文件引用\n\nrem+px\n\n边框厚度使用px单位\n字体，大小等除边框厚度外的定义使用rem\n解决实现retina屏真正的1px 边框问题\n\n封装了丰富的常规问题解决方案\n\n独立配置层设计 config\n\n厂商前缀\niconfont\n响应式\n\n元件\n\n扩展 超扩展\n\n动画库\n\n### 《手机QQ react web极致优化》李成熙（Alloyteam工程师）\n讲述了手机QQ在react框架下的全家桶开发套件，以及踩过得各种坑和性能的极致优化\n资料参考http://dev.qq.com/topic/579083d1c9da73584b02587d\nreact 全家桶\n在手Q家校群重构之前，其实我们已经做了一版PC家校群。当时将native的页面全部web化，直接就采用了React比较常用的全家桶套装：\n* 构建工具 => gulp + webpack\n* 开发效率提升 => redux-dev-tools + hot-reload\n* 统一数据管理=> redux\n* 性能提升 => immutable + purerender\n* 路由控制器 => react-router(手Q暂时没采用)\n\n构建工具目录结构\n\nReact 优化三大方向\n\n状态/数据管理优化\n\n针对React的这个数据比较的深比较deepCompare，要点有2个：\n* 尽量使传入的数据扁平化一点\n* 比较的时候做一些限制，避免溢出栈\n\n渲染性能优化\n\n首屏性能优化\n\n针对有cgi请求，需要吐大量数据的页面--同构直出\n有几点值得说明：\n比改造以前的项目，做直出更容易\n减少的是首屏显示实践，而非首屏可交互时间\n页面吐出html字符串之后，还需要在客户端，加载react包，进行事件绑定\n做bigPipe之类的优化较难\n\nreact同构直出文章\n《React同构直出优化总结》http://www.alloyteam.com/2016/06/react-isomorphic/?utm_source=tuicool&utm_medium=referral\n《腾讯新闻React同构直出优化实践》 http://www.alloyteam.com/2016/06/tencent-news-react-isomorphic-straight-out-optimization/?utm_source=tuicool&utm_medium=referral\n拆包\n不用react-router，如何拆包？\n\n非基础功能，如运营活动 ---轻量化类react方案\nPreact---压缩后只有10kb，gzip后3kb\n开源社区有较多的star（认可）\n较好的性能和兼容性\napi跟React接近\n足够的框架周边，配置redux，router等使用，还有同构直出的插件\n团队成员有能力维护的\n作者参考文章《Preact-React的轻量解决方案》https://github.com/lcxfs1991/blog/issues/13?utm_source=tuicool&utm_medium=referral\n简单回购\n\nStarter-Kit\nsteamer-react\nhttps://github.com/SteamerTeam/steamer-react/tree/react-preact\nweb分支，同构分支，preact兼容分支\n腾讯发起的交流会 将于2016-10-23 日举行\n\n### 《手机淘宝营销互动页面的最佳实践》黄华健（阿里巴巴  前端工程师）\n> 呆萌的前端工程师 讲的很棒很棒\n\n他鼓励前端开发者们沉淀出自己的最佳实践，同时大家可以去看一下他们开源的解决方案：站在巨人的肩膀上才能看得更远\n对比以前需求来了-干活的工作模式，工程化-自动化工作流能提高效率即新一代构建工具 rollup （参考文章 http://jixianqianduan.com/frontend-build/2016/01/20/next-generation-js-module-bunlder.html?utm_source=tuicool&utm_medium=referral）\n\n解析ES2015Module\nTree-shaking\n\n再来总结下rollup： - 支持ES6模块规范打包成其它任一格式规范 - 支持tree-shaking方式打包 - 方便接入构建，如gulp - 需要书写配置任务\n索性github上有demo，我还没有来的及实践，抛链接\n[手机淘宝营销互动脚手架](https://github.com/amfe/activity-template)\n\n### 《从MI Cloud的架构变迁看大型spa的复杂工程如何化简》陈恺睿 （小米 高级前端工程师）\nMi Cloud的主站就是这样的一个大型的SPA，它主要定位于PC端，PC端包括Web版和桌面应用，同时也兼顾一下移动端。Mi Cloud也正在基于electron开发一个桌面应用\n第一次重构\n用CommonJS和browserify实现模块化方案，基于grunt实现自动化构建流程 替代之前满屏jquery 操作dom\n第二次重构\n又对工程基础做了进一步的升级，采用标准的ES6的模块规范，加上更强大的webpack实现模块化方案，基于gulp实现自动化构建流程，完全是流式处理，减少硬盘IO，开发环境下进行一次实时编译从原来的20s左右压缩到1s内。最近几年，前端领域新技术层出不穷，其中不乏实实在在能提高生产力的方案，从browserify+grunt到webpack+gulp就是这样一个典型的例子，从backbone到angular再到react+redux也是一个典型的例子。\n然后开始拿业务层开刀。当时恰好有一个业务要做比较大的改版，于是我开始基于Backbone实现MVC架构。\n得到的是一个基于Backbone的MVC架构\n\n完整的流程：\n首先用户操作了界面，比如一个点击，view层抛出事件告诉controller，controller调用model层某个实例的方法，让model层向服务器操作，完了之后，model层抛出事件告诉controller，controller调用view层某个实例的方法，更新界面。\n其实，我在实践这套MVC架构的时候，也一直觉得controller部分太复杂，仔细分析一下，controller内主要分为两套流程：步骤2，3是一套流程；步骤5，6是另一套流程。这两套流程其实是互相独立的、互不干涉的，但都流经同一个节点，这无疑加剧了这个节点的复杂度。\nmodel层和view层不知道彼此的存在，甚至不知道controller的存在，它们只是通过抛出事件通知外界自己处于什么状态，比如view中的哪个按钮被点击了，model中的哪个字段有更新了。它们不关心谁监听这些事件。\n好处：\n* model层和view层完全分离，可以由不同的人并行开发\n* 可以不依赖走通整个流程来测试，model层和controller完全没有DOM操作，可以实现自动化的单元测试\n* 要增加或删除功能，只需要开始或停止监听事件即可，层与层之间解耦之后很容易实现对某一部分的替换、增减\n\n\n于是我将controller的两套流程分离一下，各司其职。\n这样，不管是从model层到view层的数据流，还是从view层到model层的数据流，虽然这两个数据流的起点和终点是对调过来的，但它们流经的节点不一样，这样就清晰了很多。\n熟悉react和redux的朋友，可能看这幅图会比较眼熟。是的，这个时候已经形成了一个单向数据流的闭环。其实，当时我也不知道这会形成所谓的单向数据流，只是在探索怎么化简复杂度罢了。\n架构演变到这一步，其实已经开始了第二轮重构，当时还是2015年夏天，我开始热火朝天的写一些demo尝试这个架构模式。\n另一方面，我已经开始尝试将view层组件化，也就是将一个个视图类实现成可组合可嵌套的，在通用的视图类上实现了一套添加子组件/移除子组件等等的API，将整个界面实现成一个个视图实例组成的树状结构。\n但其中一直有一些痛点，其中以view层的痛点最加剧业务的复杂度。\n\n\n\n于是在view层我改成使用react来实现。业务层只需要写全量渲染的代码，再也不用写局部更新的代码了，框架自己会帮业务层对DOM做局部更新。手动点个赞。\n网上也有很多使用backbone的model配合react的文章，其实就类似于我们的架构演变到这一步时的方案。\n于是我继续实践，很快又挖出了一个痛点。。\n更新组件树中的深层节点时很麻烦。\n一开始的做法是，从组件树的根节点一层层的往下传数据，这显然很麻烦。\n再次带着问题寻找解决方案。此时redux框架经过多次迭代之后，开始成熟、稳定下来，我发现redux提供的connect函数正好能让我直接把数据传递给组件树中的深层节点。\n于是我引入了redux，最终项目的架构就变成了这样\n\n\n除了为业务降低复杂度的框架，大型SPA的未来还有很多挑战。比如：\n\n* 强类型，静态类型检查\n* 异常处理的最佳实践\n* 自动化测试的健全：因为基于react这种视图层框架几乎不需要操作DOM，基于redux这种函数式编程思想的框架管理整个应用的状态，副作用和状态都得到很好的控制\n控制复杂度的心得。\n\n* 分治：不管多么庞大的问题，咋一看很复杂，但把它切割成一个个小问题之后，局面就变得清晰了很多。模块化、组件化都是这个思路，我觉得前端的路由也体现了分治的思想，把路由看作一个有限状态机，它就将应用的生命周期划分成了几个大的状态。\n* 善于利用巨人的肩膀：其实，复杂度并不会减少，它只会从一个地方转移到另一个地方，复用组件如此，框架为业务层封装复杂性也是如此，所以，善于利于巨人的肩膀，因为它已经帮你转移了复杂度。\n* 先确认瓶颈再做性能优化：虽然是老生常谈，但还是要强调一下，因为真的很有用但又很容易忘记。\n* 二八原则：考虑项目的生命周期、影响力来衡量投入的资源，好钢用在刀刃上，我个人感觉小米挺强调成本控制的，毕竟我们是创业公司，跟大公司可以适当冗余不太一样。\n\n### 《UC前端业务套件体系》三桥（阿里巴巴UC移动事业群  高级前端工程师）\n三桥大神主要讲的偏架构方向，也接近了尾声，实在太累没做过多记录。这里就不在提供摘要，近期会提供相关PPT。\n> 很可惜，只参与了工具1的分会场\n更多内容以及PPT会近期发布。","slug":"第五届iWeb峰会议程概述","published":1,"updated":"2019-03-21T03:42:03.285Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtifjptz0012lohiewbt5t4i","content":"<p>作为HTML5行业最具影响力的盛会之一，由HTML5梦工场举办的“2016 iWeb峰会·北京站”已成功举办，作为本届峰会规模最大、参会人数最多的主站——北京站，峰会当天行业各领域权威人士现场坐而论道，共同探讨HTML5最新技术与行业趋势，干货连连。<br><a id=\"more\"></a></p>\n<h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><p>2016年8月27日8点半国际会议中心开始签到入场。<br>9点一如既往的由h5女神娜姐开场。</p>\n<h2 id=\"主题峰会\"><a href=\"#主题峰会\" class=\"headerlink\" title=\"主题峰会\"></a>主题峰会</h2><h3 id=\"《HTML5发行的力量》凌海（-蝴蝶互动-CEO）\"><a href=\"#《HTML5发行的力量》凌海（-蝴蝶互动-CEO）\" class=\"headerlink\" title=\"《HTML5发行的力量》凌海（ 蝴蝶互动  CEO）\"></a>《HTML5发行的力量》凌海（ 蝴蝶互动  CEO）</h3><p>印象最深的是凌海说的如何规避风险，如何做时间管理，举例说明了有投资方要求360出3年规划，3年对互联网来说时间太长了，3年可能发生很多事，风险是无法预知的；列举自己针对一个需要90天的项目，他们公司往往是比较慎重的，他们会把时间细化到30分钟，相比90天或者3年30分钟的风险是基本可以完全把控的。</p>\n<h3 id=\"《2016：完善生态闭环，向全行业致敬》-陈书艺（白鹭时代-CEO）\"><a href=\"#《2016：完善生态闭环，向全行业致敬》-陈书艺（白鹭时代-CEO）\" class=\"headerlink\" title=\"《2016：完善生态闭环，向全行业致敬》 陈书艺（白鹭时代 CEO）\"></a>《2016：完善生态闭环，向全行业致敬》 陈书艺（白鹭时代 CEO）</h3><p>一个领先的html5移动技术与服务提供商，erget开放平台，出款多个游戏，什么暗黑之王，乱弹三国，稀有神传，小小战争，三国魂等，支持多种动画解决方案，平滑动画，可视化代码，专业游戏引擎。<br>h5游戏行业有机遇也有挑战，性能的大幅提升和微信带来的流量都是h5游戏行业的机遇（流量变现等）</p>\n<h3 id=\"《天下武功，唯快不破》-王哲（触控科技副总裁）\"><a href=\"#《天下武功，唯快不破》-王哲（触控科技副总裁）\" class=\"headerlink\" title=\"《天下武功，唯快不破》 王哲（触控科技副总裁）\"></a>《天下武功，唯快不破》 王哲（触控科技副总裁）</h3><p>他从h5游戏的性能方面做了分析，对于h5的未来，他报以谨慎乐观的态度。<br>分析了h5游戏的性能方面：</p>\n<ul>\n<li>webGL性能提高 5~10倍 </li>\n<li>Canvas 脏矩形算法 性能提高2倍</li>\n<li>内存占用降低5%</li>\n<li>包体减小30%</li>\n</ul>\n<h3 id=\"《社交生态下的HTML5游戏辛新契机》李明-（很快CEO）\"><a href=\"#《社交生态下的HTML5游戏辛新契机》李明-（很快CEO）\" class=\"headerlink\" title=\"《社交生态下的HTML5游戏辛新契机》李明 （很快CEO）\"></a>《社交生态下的HTML5游戏辛新契机》李明 （很快CEO）</h3><p>“很快”鼓励开发者将技术转化为流量，并现场宣布，和9g合作，启动了亿元流量计划，为开发者提供流量。</p>\n<h3 id=\"《HTML5和Docker容器如何重构和颠覆应用产业》-马科（WeX5-CEO-）\"><a href=\"#《HTML5和Docker容器如何重构和颠覆应用产业》-马科（WeX5-CEO-）\" class=\"headerlink\" title=\"《HTML5和Docker容器如何重构和颠覆应用产业》 马科（WeX5 CEO ）\"></a>《HTML5和Docker容器如何重构和颠覆应用产业》 马科（WeX5 CEO ）</h3><p>首先这位被娜姐介绍说是“90后”CEO，引起现场一片轰动，90后出道的~ 哈哈<br>从互联网的扩大入口：h5会导致病毒式传播，形成闭环，不像传统app的场景分割。还有云计算即未来和对新技术的思考：要从应用场景切入，而不是重复造轮子。<br>对比了优秀app和传统app的区别， devops区别，这位干货很多。</p>\n<h3 id=\"《web技术：一个挑战极限的创新平台》-江小丹（英特尔-web技术研发总监）\"><a href=\"#《web技术：一个挑战极限的创新平台》-江小丹（英特尔-web技术研发总监）\" class=\"headerlink\" title=\"《web技术：一个挑战极限的创新平台》 江小丹（英特尔 web技术研发总监）\"></a>《web技术：一个挑战极限的创新平台》 江小丹（英特尔 web技术研发总监）</h3><p>提到了web前沿技术：web assembly nodejs 还有Intel在虚拟现实的技术尝试和酷炫的体验。</p>\n<h3 id=\"《web-前端的是实时化》-肖光宇-（野狗实时-联合创始人）\"><a href=\"#《web-前端的是实时化》-肖光宇-（野狗实时-联合创始人）\" class=\"headerlink\" title=\"《web 前端的是实时化》 肖光宇 （野狗实时 联合创始人）\"></a>《web 前端的是实时化》 肖光宇 （野狗实时 联合创始人）</h3><p>野狗是国内领先的实时后端云；野狗api–最实时通信api来了，应用于各大场景，可实时同步数据，网页通信，实时游戏，运用于汽车，实现实时同步汽车数据等。<br>使用野狗API,可以获得实时后端云的两大功能</p>\n<ul>\n<li>实时通信 ，包括消息订阅，推送，双向通信等功能。网络延迟小，服务响应速度快，API简单易用。</li>\n<li>数据存储，提供了一个Key-Value的云端数据存储，直接通过API就可以对数据进行存取操作。操作简单，按需扩展。</li>\n</ul>\n<h3 id=\"《移动互联网下半场-不用好HTML5，大部分公司都会死》王安（Dcloud-CEO）\"><a href=\"#《移动互联网下半场-不用好HTML5，大部分公司都会死》王安（Dcloud-CEO）\" class=\"headerlink\" title=\"《移动互联网下半场-不用好HTML5，大部分公司都会死》王安（Dcloud CEO）\"></a>《移动互联网下半场-不用好HTML5，大部分公司都会死》王安（Dcloud CEO）</h3><p>互联网下半场，原生应用成本高，留存率低等问题已经显现。如何用HTML5解决这个问题呢？他提供的答案就是流应用。</p>\n<h3 id=\"《H5游戏进入精品时代》谢成鸿-（LayaBox-CEO-）\"><a href=\"#《H5游戏进入精品时代》谢成鸿-（LayaBox-CEO-）\" class=\"headerlink\" title=\"《H5游戏进入精品时代》谢成鸿 （LayaBox CEO ）\"></a>《H5游戏进入精品时代》谢成鸿 （LayaBox CEO ）</h3><p>这个比较接地气，说什么目的都是能挣钱，第一桶金开发一款小游戏赚到一点小钱650万。<br>LayaBox阐述了未来游戏市场将呈现页游、手游、HTML5多端融合的趋势，强调了HTML5技术跨端、多屏、免下载等特点给游戏行业带来的革新性变化。在LayaBox看来，HTML5游戏是游戏市场上一课冉冉升起的新星，即将迎来爆发。同时，LayaBox也详细介绍了旗下第二代HTML5游戏引擎LayaAir，其支持Flash页游、APP手游、HTML5游戏 三端同发的特点和超越Unity3D的性能赢得了现场阵阵掌声。目前，LayaBox业务涵盖了引擎提供、游戏发行、游戏渠道、IP合作、项目投资、教育培训6大板块，是一家综合性的游戏服务企业。</p>\n<h2 id=\"工具应用专场1\"><a href=\"#工具应用专场1\" class=\"headerlink\" title=\"工具应用专场1\"></a>工具应用专场1</h2><h3 id=\"《高性能HTML5-APP-开发云实践——基于完全开源的WeX5开发框架》-王洁-（WeX5-首席技术运营）\"><a href=\"#《高性能HTML5-APP-开发云实践——基于完全开源的WeX5开发框架》-王洁-（WeX5-首席技术运营）\" class=\"headerlink\" title=\"《高性能HTML5 APP 开发云实践——基于完全开源的WeX5开发框架》 王洁  （WeX5  首席技术运营）\"></a>《高性能HTML5 APP 开发云实践——基于完全开源的WeX5开发框架》 王洁  （WeX5  首席技术运营）</h3><p>主要对原生APP和hybrid app的比较，简述为解决白页多webview 实现转场动画等， 复杂效果native 实现，简单效果h5实现“重混” - wex5 “轻混”，只需前端调用，提供打包平台<br>WeX5的可视化操作<br>wex5，一个纯h5app开放平台，组件风格分离，基于css3，引入bootstrp资源，可快速开发。一次开发，全面拥有安卓app，苹果app，微信服务号。真正的html5 app开发云。<br>Hybrid App走向“轻混”，剖析WeX5开源高性能HTML5 App开发框架</p>\n<blockquote>\n<p> 一. Hybrid App从“重混”到“轻混”的技术发展历程<br>基本上从早期的多元化走向了只有Android和iOS两个系统的环境。对于开发者来说，就意味着一个App需要制定两套实现方案，这对开发成本和维护成本都是非常大的挑战。基于这样一个现实，其解决方案就是想办法实现套代码跨端运行，所以Hybrid APP混合应用模式应运而生<br>在Hybrid APP发展早期，Web运行性能是当时的主要的瓶颈。Web在性能方面有缺陷，Web不够就用Native来凑，就是选择了用原生技术来弥补Web上的性能不足，其实就是多WebView。混合的单WebView最大的障碍就是页面切换，闪白很明显。手机里面又讲究用户交互体验，从一个页到另一个页想做个平滑的动画，用纯Web技术在当时的条件下是非常难以实现的，其实目前大多数框架也是这么做的，就是采用多WebView，这样可以平滑的转场。<br>因为早期硬件比较差，浏览器性能也一般般，所以有一些比较复杂的组件在实现一些功能的时候，速度比较慢。当时框架里是用NativeUI组件来弥补的，配合Web来实现这些功能。这种模式被定义为“重混”，用原生的能力去弥补UI，或者技术更偏Native的框架就被定义为重混的Hybrid App框架。<br>重混框架优缺点很明显，优点是提升了运行性能、增强了交互。缺点是Web和Native技术交叉混杂，增加了开发人员的工作难度。但是，当下的手机硬件配置已经有了很大的改善，包括浏览器技术的发展也很重要，在GS引擎方面都有长足的进步。实现功能的时候用Web的技术的前提下已经不再需要Native技术来弥补了，随着技术的发展，性能已经不再是瓶颈。</p>\n</blockquote>\n<blockquote>\n<p>另一个改变了移动应用这一领域的进程事件是，自从微信推出以后，相当于重新定义了移动应用的概念，通过它的服务号、公众号、企业号，微信本身变成了一种应用平台。包括微信最新的版本更新，它浏览器内核的升级，包括对游戏的支持，都和大量的移动App开发有着莫大的关联。而这个时候重混的框架就显得多余了，因为在重混框架里面很多性能的解决是依赖Native的原生部分。而到了微信里面，多WebView和NativeUI都没有了。原来在重混框架里面很强的一些能力完全就消失了，这时候在微信里面就有很多能力就不能用了。<br>于是轻混就成了目前真正要跨端Hybrid App的必然选择，这时候轻混的UI部分必须用纯Web技术，在底层的设备接口上，GS无法完成的原生部分需要Native技术来弥补。需要强调的是，Native的技术是不应该去侵入UI的，这样的一个框架就是我们所说的轻混Hybrid App框架，这才是真正的HTML5 App框架。</p>\n</blockquote>\n<blockquote>\n<p>二.构建高性能HTML5 App跨端框架<br>伴随着以上的观点，接下来谈谈如何构建轻混模式下的HTML5 App框架。这种混合框架很简单，首先要有一个内置了浏览器的外壳，在浏览器里提供网页运行环境，同时在这个外壳上提供很多插件，可以让网络通过GS进行操作。<br>基于这样的认识，王洁说，在选择HTML5框架设计的时候，要解决两个框架的问题，一个是HTML5的框架，一个是Native的框架。首先看Native框架的选择，选择PhoneGap框架，受到了业内主流厂商支持，微软也是用Cordova，它的插件框架是开放的，很容易自定义。<br>另外就是要解决HTML5的一些性能问题，如果不采用重混架构的话，在页面切换还是会有一些障碍，王洁说到，WeX5采用SPA单页应用模式，它是基于传统的页面加载模式MPA，页面之间互相独立。但是SPA的不同之处在于，其框架里整个页面是由外壳页面框架组成的，是用AJAX技术完成的，AJAX在桌面时代就存在，通过局部刷新来提升用户体验。但是把AJAX技术最大化来使用，整个页面框架都用AJAX来实现，每个页面的加载都是这样的方式。<br>对设备的局部渲染，可以在加载的时候在后面预加载再做转场动画，而且还不需要依赖多Web应用，不需要依赖Native就可以完成。而且在加载多页框架时每个页面的共用功能要重复加载。所以从各方面来说SPA相对于MPA是有极大的性能提升的。<br>SPA确实很好用，但是在设计产品的时候需要考虑到多人协作过程中，支持复杂应用的开发过程中，会不会出现多个ID会冲突，样式冲突，JS冲突等等致命问题？所以下面就谈到了页面隔离的问题。<br>解决这样棘手的问题，王洁说，首先要考虑到HTML元素ID冲突的问题，因为是可视化工具，所以ID属性的设计是拖到一个属性栏里去定义ID，这时候刚好可以用一个替换原则，用了XID来替换，不会直接设定ID属性。这样到内存里，会动态的生成真实的ID，会在XID后面加一个页面标志，这样可以保证多人写的页面在加载内存里ID是不相同的，也就不存在冲突。当然提供一些API的时候是能拿到真实ID，对应相应的元素，不影响访问。在整个组件体系里，开发者利用很简单的方法就可以拿到组件，可以很平滑的解决掉ID冲突的问题。<br>CSS样式冲突问题分为两类，一类样式是共用样式，多页面引用同一个页面；另一类样式被定义为私有样式，只使用页面，但不希望这个页面干扰到其他页面。这时候给每个页面都配了一个CSS文件，定义私有样式，限定在当前页面。实现起来也很简单，通过对工具的编译，把私有CSS文件里的所有样式加一个页面标志，在页面节点的属性上加一个标志，这样就使得class只能作用于当前页面的HTML元素，这就成为了一个私有样式。<br>然后是JavaScript问题，现在JavaScript模块化技术很流行，借用JavaScript模块化技术，解决JavaScript隔离问题。王洁在这里顺便把RequireJS简单的提了一下，通过define可以定义模块，在RequireJS定义里，这个大括号里的才是模块里的代码。不管是方法还是变量，都封装在闭包里，每个代码都是写在define的模块里，这样就把代码自然隔离了。<br>王洁说他们在外围还做了一些工作，首先是实现完整的外壳管理，Shell类提供外壳管理。为了防止信息泄露，在配置的时候确实会把页面完整卸载掉。当加载页面片断时，会从当前外壳数把JS删掉，页面加载的时候创建的JS对象都会完整的释放掉，这是由框架来保证的。另外是路由的问题，在SPA单页面框架里路由是很重要的，因为是单页面应用，加载的页面都是片断，其实UI地址一直是外壳的地址。<br>下图是整体框架的架构。黄色部分用的是Cordova，解决安卓和苹果的原生调用问题。同时要兼容微信，所以上面把Cordova和微信又做了封装，抽象成统一的HTML5 API。如果通过统一的Native API去拍照，会自动根据页面环境，通过Cordova接口调用，这样可以更方便的实现一次开发，多端运行，代码不需要改，既可以运行在原生App里，也可以运行在微信里。包括拍照、GPS地图，一系列的API都可以进统一分装。<br>Bootstrap在这里提供了几个能力。一个是样式美化，扁平化风格，另外响应式布局。基于Bootstrap设计的页面，运行在不同的设备上不需要考虑分辨率，会自动处理设备分辨率。再上面实现了WeX5的组件框架和数据框架，页面上不仅有交互的UI组件，页面里面还有数据。接下来是业务框架层，即SPA单元页面框架。在服务端WeX5还提供了XBaaS服务，负责后端数据存取、逻辑，还有第三方地图、支付等功能实现。WeX5提供多语言实现，提供了不同语言的版本，开发者可以针对自己的版本来集成到自己的框架里。<br>三、WeX5可视化快速开发实践<br>在分享的最后，王洁给大家展示了基于WeX5这样的框架所开发出来的一些功能。首先是可视化的快速开发程度，帮助开发者通过可视化开发定义页面，框架可以保证运行体验，必须能快速加载，而且各种首试、硬件能力的是一体化集成的。把组件拖到表单上定义布局，设置属性，即可得到最终页面，设计室和运行室相邻，完全所见即所得。<br>丰富多样的组件，足以适应各种复杂表单的组合。通过把常见功能组件封装，可以极大减轻开发者的开发工作量。最关键的是整个组件框架完全开源，除了WeX5提供的上百个组件以外开发者还可以自己定义这个可视化组件，甚至可以继承第三方组件，通过规范的方式封装成HTML5的可视化组件。<br>编程问题也是重点，WeX5的定位是可视化程度更高的前端编程工具。不仅可以可视化设计，编程也是便捷。它能实现代码的智能提示、代码模板，还内致了Emmet框架。随后考虑的是调试问题，WeX5是一体化的环境，不仅要解决开发、编程，还要解决调试的过程，既可以在Web浏览器上调试，也可以连到手机上调试，所有代码都是开源的，底层内库也是开放的。最后就是打包的问题，打包要考虑很多插件的配置，参数，资源在命令行的配合。WeX5提供了一个打包的向导，完全本地打包，不需要依赖云打包服务，只需要把打包过程中要设置的东西完全工具化，可以设置应用版本、证书、LOGO、图片、插件里的参数，最后就可以应用到App上。</p>\n</blockquote>\n<h3 id=\"《web技术推进多样化人机交互方式》吴栋夏-（英特尔-软件工程师）\"><a href=\"#《web技术推进多样化人机交互方式》吴栋夏-（英特尔-软件工程师）\" class=\"headerlink\" title=\"《web技术推进多样化人机交互方式》吴栋夏 （英特尔  软件工程师）\"></a>《web技术推进多样化人机交互方式》吴栋夏 （英特尔  软件工程师）</h3><p>讲述了Intel的各种“黑科技”，还介绍了关于深度增强摄像，场景感知与模型，crosswalk，nw.js<br>crosswalk<br>nwjs<br>nwjs是在英特尔开源技术中心创建的，它是基于谷歌浏览器核心引擎和nodejs运行，你可以通过nwjs技术使用html和js语言编写本地应用程序，它也可以让你直接从DOM调用nodejs模块，使用一种新的方式与所有的Web技术编写本地应用。它主要有以下6个特点：</p>\n<ul>\n<li>以网络最流行的技术编写原生应用程序的新方法</li>\n<li>基于HTML5, CSS3, JS and WebGL而编写</li>\n<li>完全支持nodejs所有api及第三方模块</li>\n<li>可以使用DOM直接调用nodejs模块</li>\n<li>容易打包和分发</li>\n<li>支持运行环境包括32位和64位的Window、Linux和Mac OS<h3 id=\"《Yo-去哪儿移动UI框架》-杜瑶（去哪儿网-前端开发总监）\"><a href=\"#《Yo-去哪儿移动UI框架》-杜瑶（去哪儿网-前端开发总监）\" class=\"headerlink\" title=\"《Yo-去哪儿移动UI框架》 杜瑶（去哪儿网  前端开发总监）\"></a>《Yo-去哪儿移动UI框架》 杜瑶（去哪儿网  前端开发总监）</h3>瑶姐机智自不必说，网红魅力；<br>YO 一款基于Sass开发的css框架，用于快速构建移动UI项目<br>mobile First<br>why mobile First (以mobile作为基准的设计为出发点)<br>公司战略转移<br>新战场需要有力的框架抹平平台切换所带来的适应过程<br>pc端已有成熟的解决方案，无需推倒重来<br>专注于某一具体的领域更能变得专业<br>mobile First 的好处<br>可以减少对历史问题的考虑，不如不用考虑IE<br>保证交互方式的单一性，不用考虑PC上的交互行为<br>更及时的应用上新技术<br>代码更轻量</li>\n</ul>\n<p>ios 默认风格<br>why ios<br>巨量的ios用户（超过50%）<br>安卓碎片化过重，不易挑选标示<br>ios的交互及展现更具备普适性</p>\n<p>Pure CSS 纯粹的css 框架<br>why pure css<br>职能更分明<br>能被使用在任何项目中<br>不紧密捆绑UI组件</p>\n<p>分层设计<br>Yo将不同的功能拆解成结构清晰的类别分散到不同的层去进行处理</p>\n<p>yo|—usage<br>|—lib</p>\n<p>分层设计的意义<br>清晰的依赖<br>高度解耦<br>高度复用<br>高可移植性<br>结束混乱的文件引用</p>\n<p>rem+px</p>\n<p>边框厚度使用px单位<br>字体，大小等除边框厚度外的定义使用rem<br>解决实现retina屏真正的1px 边框问题</p>\n<p>封装了丰富的常规问题解决方案</p>\n<p>独立配置层设计 config</p>\n<p>厂商前缀<br>iconfont<br>响应式</p>\n<p>元件</p>\n<p>扩展 超扩展</p>\n<p>动画库</p>\n<h3 id=\"《手机QQ-react-web极致优化》李成熙（Alloyteam工程师）\"><a href=\"#《手机QQ-react-web极致优化》李成熙（Alloyteam工程师）\" class=\"headerlink\" title=\"《手机QQ react web极致优化》李成熙（Alloyteam工程师）\"></a>《手机QQ react web极致优化》李成熙（Alloyteam工程师）</h3><p>讲述了手机QQ在react框架下的全家桶开发套件，以及踩过得各种坑和性能的极致优化<br>资料参考<a href=\"http://dev.qq.com/topic/579083d1c9da73584b02587d\" target=\"_blank\" rel=\"noopener\">http://dev.qq.com/topic/579083d1c9da73584b02587d</a><br>react 全家桶<br>在手Q家校群重构之前，其实我们已经做了一版PC家校群。当时将native的页面全部web化，直接就采用了React比较常用的全家桶套装：</p>\n<ul>\n<li>构建工具 =&gt; gulp + webpack</li>\n<li>开发效率提升 =&gt; redux-dev-tools + hot-reload</li>\n<li>统一数据管理=&gt; redux</li>\n<li>性能提升 =&gt; immutable + purerender</li>\n<li>路由控制器 =&gt; react-router(手Q暂时没采用)</li>\n</ul>\n<p>构建工具目录结构</p>\n<p>React 优化三大方向</p>\n<p>状态/数据管理优化</p>\n<p>针对React的这个数据比较的深比较deepCompare，要点有2个：</p>\n<ul>\n<li>尽量使传入的数据扁平化一点</li>\n<li>比较的时候做一些限制，避免溢出栈</li>\n</ul>\n<p>渲染性能优化</p>\n<p>首屏性能优化</p>\n<p>针对有cgi请求，需要吐大量数据的页面–同构直出<br>有几点值得说明：<br>比改造以前的项目，做直出更容易<br>减少的是首屏显示实践，而非首屏可交互时间<br>页面吐出html字符串之后，还需要在客户端，加载react包，进行事件绑定<br>做bigPipe之类的优化较难</p>\n<p>react同构直出文章<br>《React同构直出优化总结》<a href=\"http://www.alloyteam.com/2016/06/react-isomorphic/?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\" rel=\"noopener\">http://www.alloyteam.com/2016/06/react-isomorphic/?utm_source=tuicool&amp;utm_medium=referral</a><br>《腾讯新闻React同构直出优化实践》 <a href=\"http://www.alloyteam.com/2016/06/tencent-news-react-isomorphic-straight-out-optimization/?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\" rel=\"noopener\">http://www.alloyteam.com/2016/06/tencent-news-react-isomorphic-straight-out-optimization/?utm_source=tuicool&amp;utm_medium=referral</a><br>拆包<br>不用react-router，如何拆包？</p>\n<p>非基础功能，如运营活动 —轻量化类react方案<br>Preact—压缩后只有10kb，gzip后3kb<br>开源社区有较多的star（认可）<br>较好的性能和兼容性<br>api跟React接近<br>足够的框架周边，配置redux，router等使用，还有同构直出的插件<br>团队成员有能力维护的<br>作者参考文章《Preact-React的轻量解决方案》<a href=\"https://github.com/lcxfs1991/blog/issues/13?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\" rel=\"noopener\">https://github.com/lcxfs1991/blog/issues/13?utm_source=tuicool&amp;utm_medium=referral</a><br>简单回购</p>\n<p>Starter-Kit<br>steamer-react<br><a href=\"https://github.com/SteamerTeam/steamer-react/tree/react-preact\" target=\"_blank\" rel=\"noopener\">https://github.com/SteamerTeam/steamer-react/tree/react-preact</a><br>web分支，同构分支，preact兼容分支<br>腾讯发起的交流会 将于2016-10-23 日举行</p>\n<h3 id=\"《手机淘宝营销互动页面的最佳实践》黄华健（阿里巴巴-前端工程师）\"><a href=\"#《手机淘宝营销互动页面的最佳实践》黄华健（阿里巴巴-前端工程师）\" class=\"headerlink\" title=\"《手机淘宝营销互动页面的最佳实践》黄华健（阿里巴巴  前端工程师）\"></a>《手机淘宝营销互动页面的最佳实践》黄华健（阿里巴巴  前端工程师）</h3><blockquote>\n<p>呆萌的前端工程师 讲的很棒很棒</p>\n</blockquote>\n<p>他鼓励前端开发者们沉淀出自己的最佳实践，同时大家可以去看一下他们开源的解决方案：站在巨人的肩膀上才能看得更远<br>对比以前需求来了-干活的工作模式，工程化-自动化工作流能提高效率即新一代构建工具 rollup （参考文章 <a href=\"http://jixianqianduan.com/frontend-build/2016/01/20/next-generation-js-module-bunlder.html?utm_source=tuicool&amp;utm_medium=referral）\" target=\"_blank\" rel=\"noopener\">http://jixianqianduan.com/frontend-build/2016/01/20/next-generation-js-module-bunlder.html?utm_source=tuicool&amp;utm_medium=referral）</a></p>\n<p>解析ES2015Module<br>Tree-shaking</p>\n<p>再来总结下rollup： - 支持ES6模块规范打包成其它任一格式规范 - 支持tree-shaking方式打包 - 方便接入构建，如gulp - 需要书写配置任务<br>索性github上有demo，我还没有来的及实践，抛链接<br><a href=\"https://github.com/amfe/activity-template\" target=\"_blank\" rel=\"noopener\">手机淘宝营销互动脚手架</a></p>\n<h3 id=\"《从MI-Cloud的架构变迁看大型spa的复杂工程如何化简》陈恺睿-（小米-高级前端工程师）\"><a href=\"#《从MI-Cloud的架构变迁看大型spa的复杂工程如何化简》陈恺睿-（小米-高级前端工程师）\" class=\"headerlink\" title=\"《从MI Cloud的架构变迁看大型spa的复杂工程如何化简》陈恺睿 （小米 高级前端工程师）\"></a>《从MI Cloud的架构变迁看大型spa的复杂工程如何化简》陈恺睿 （小米 高级前端工程师）</h3><p>Mi Cloud的主站就是这样的一个大型的SPA，它主要定位于PC端，PC端包括Web版和桌面应用，同时也兼顾一下移动端。Mi Cloud也正在基于electron开发一个桌面应用<br>第一次重构<br>用CommonJS和browserify实现模块化方案，基于grunt实现自动化构建流程 替代之前满屏jquery 操作dom<br>第二次重构<br>又对工程基础做了进一步的升级，采用标准的ES6的模块规范，加上更强大的webpack实现模块化方案，基于gulp实现自动化构建流程，完全是流式处理，减少硬盘IO，开发环境下进行一次实时编译从原来的20s左右压缩到1s内。最近几年，前端领域新技术层出不穷，其中不乏实实在在能提高生产力的方案，从browserify+grunt到webpack+gulp就是这样一个典型的例子，从backbone到angular再到react+redux也是一个典型的例子。<br>然后开始拿业务层开刀。当时恰好有一个业务要做比较大的改版，于是我开始基于Backbone实现MVC架构。<br>得到的是一个基于Backbone的MVC架构</p>\n<p>完整的流程：<br>首先用户操作了界面，比如一个点击，view层抛出事件告诉controller，controller调用model层某个实例的方法，让model层向服务器操作，完了之后，model层抛出事件告诉controller，controller调用view层某个实例的方法，更新界面。<br>其实，我在实践这套MVC架构的时候，也一直觉得controller部分太复杂，仔细分析一下，controller内主要分为两套流程：步骤2，3是一套流程；步骤5，6是另一套流程。这两套流程其实是互相独立的、互不干涉的，但都流经同一个节点，这无疑加剧了这个节点的复杂度。<br>model层和view层不知道彼此的存在，甚至不知道controller的存在，它们只是通过抛出事件通知外界自己处于什么状态，比如view中的哪个按钮被点击了，model中的哪个字段有更新了。它们不关心谁监听这些事件。<br>好处：</p>\n<ul>\n<li>model层和view层完全分离，可以由不同的人并行开发</li>\n<li>可以不依赖走通整个流程来测试，model层和controller完全没有DOM操作，可以实现自动化的单元测试</li>\n<li>要增加或删除功能，只需要开始或停止监听事件即可，层与层之间解耦之后很容易实现对某一部分的替换、增减</li>\n</ul>\n<p>于是我将controller的两套流程分离一下，各司其职。<br>这样，不管是从model层到view层的数据流，还是从view层到model层的数据流，虽然这两个数据流的起点和终点是对调过来的，但它们流经的节点不一样，这样就清晰了很多。<br>熟悉react和redux的朋友，可能看这幅图会比较眼熟。是的，这个时候已经形成了一个单向数据流的闭环。其实，当时我也不知道这会形成所谓的单向数据流，只是在探索怎么化简复杂度罢了。<br>架构演变到这一步，其实已经开始了第二轮重构，当时还是2015年夏天，我开始热火朝天的写一些demo尝试这个架构模式。<br>另一方面，我已经开始尝试将view层组件化，也就是将一个个视图类实现成可组合可嵌套的，在通用的视图类上实现了一套添加子组件/移除子组件等等的API，将整个界面实现成一个个视图实例组成的树状结构。<br>但其中一直有一些痛点，其中以view层的痛点最加剧业务的复杂度。</p>\n<p>于是在view层我改成使用react来实现。业务层只需要写全量渲染的代码，再也不用写局部更新的代码了，框架自己会帮业务层对DOM做局部更新。手动点个赞。<br>网上也有很多使用backbone的model配合react的文章，其实就类似于我们的架构演变到这一步时的方案。<br>于是我继续实践，很快又挖出了一个痛点。。<br>更新组件树中的深层节点时很麻烦。<br>一开始的做法是，从组件树的根节点一层层的往下传数据，这显然很麻烦。<br>再次带着问题寻找解决方案。此时redux框架经过多次迭代之后，开始成熟、稳定下来，我发现redux提供的connect函数正好能让我直接把数据传递给组件树中的深层节点。<br>于是我引入了redux，最终项目的架构就变成了这样</p>\n<p>除了为业务降低复杂度的框架，大型SPA的未来还有很多挑战。比如：</p>\n<ul>\n<li>强类型，静态类型检查</li>\n<li>异常处理的最佳实践</li>\n<li><p>自动化测试的健全：因为基于react这种视图层框架几乎不需要操作DOM，基于redux这种函数式编程思想的框架管理整个应用的状态，副作用和状态都得到很好的控制<br>控制复杂度的心得。</p>\n</li>\n<li><p>分治：不管多么庞大的问题，咋一看很复杂，但把它切割成一个个小问题之后，局面就变得清晰了很多。模块化、组件化都是这个思路，我觉得前端的路由也体现了分治的思想，把路由看作一个有限状态机，它就将应用的生命周期划分成了几个大的状态。</p>\n</li>\n<li>善于利用巨人的肩膀：其实，复杂度并不会减少，它只会从一个地方转移到另一个地方，复用组件如此，框架为业务层封装复杂性也是如此，所以，善于利于巨人的肩膀，因为它已经帮你转移了复杂度。</li>\n<li>先确认瓶颈再做性能优化：虽然是老生常谈，但还是要强调一下，因为真的很有用但又很容易忘记。</li>\n<li>二八原则：考虑项目的生命周期、影响力来衡量投入的资源，好钢用在刀刃上，我个人感觉小米挺强调成本控制的，毕竟我们是创业公司，跟大公司可以适当冗余不太一样。</li>\n</ul>\n<h3 id=\"《UC前端业务套件体系》三桥（阿里巴巴UC移动事业群-高级前端工程师）\"><a href=\"#《UC前端业务套件体系》三桥（阿里巴巴UC移动事业群-高级前端工程师）\" class=\"headerlink\" title=\"《UC前端业务套件体系》三桥（阿里巴巴UC移动事业群  高级前端工程师）\"></a>《UC前端业务套件体系》三桥（阿里巴巴UC移动事业群  高级前端工程师）</h3><p>三桥大神主要讲的偏架构方向，也接近了尾声，实在太累没做过多记录。这里就不在提供摘要，近期会提供相关PPT。</p>\n<blockquote>\n<p>很可惜，只参与了工具1的分会场<br>更多内容以及PPT会近期发布。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>作为HTML5行业最具影响力的盛会之一，由HTML5梦工场举办的“2016 iWeb峰会·北京站”已成功举办，作为本届峰会规模最大、参会人数最多的主站——北京站，峰会当天行业各领域权威人士现场坐而论道，共同探讨HTML5最新技术与行业趋势，干货连连。<br>","more":"</p>\n<h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><p>2016年8月27日8点半国际会议中心开始签到入场。<br>9点一如既往的由h5女神娜姐开场。</p>\n<h2 id=\"主题峰会\"><a href=\"#主题峰会\" class=\"headerlink\" title=\"主题峰会\"></a>主题峰会</h2><h3 id=\"《HTML5发行的力量》凌海（-蝴蝶互动-CEO）\"><a href=\"#《HTML5发行的力量》凌海（-蝴蝶互动-CEO）\" class=\"headerlink\" title=\"《HTML5发行的力量》凌海（ 蝴蝶互动  CEO）\"></a>《HTML5发行的力量》凌海（ 蝴蝶互动  CEO）</h3><p>印象最深的是凌海说的如何规避风险，如何做时间管理，举例说明了有投资方要求360出3年规划，3年对互联网来说时间太长了，3年可能发生很多事，风险是无法预知的；列举自己针对一个需要90天的项目，他们公司往往是比较慎重的，他们会把时间细化到30分钟，相比90天或者3年30分钟的风险是基本可以完全把控的。</p>\n<h3 id=\"《2016：完善生态闭环，向全行业致敬》-陈书艺（白鹭时代-CEO）\"><a href=\"#《2016：完善生态闭环，向全行业致敬》-陈书艺（白鹭时代-CEO）\" class=\"headerlink\" title=\"《2016：完善生态闭环，向全行业致敬》 陈书艺（白鹭时代 CEO）\"></a>《2016：完善生态闭环，向全行业致敬》 陈书艺（白鹭时代 CEO）</h3><p>一个领先的html5移动技术与服务提供商，erget开放平台，出款多个游戏，什么暗黑之王，乱弹三国，稀有神传，小小战争，三国魂等，支持多种动画解决方案，平滑动画，可视化代码，专业游戏引擎。<br>h5游戏行业有机遇也有挑战，性能的大幅提升和微信带来的流量都是h5游戏行业的机遇（流量变现等）</p>\n<h3 id=\"《天下武功，唯快不破》-王哲（触控科技副总裁）\"><a href=\"#《天下武功，唯快不破》-王哲（触控科技副总裁）\" class=\"headerlink\" title=\"《天下武功，唯快不破》 王哲（触控科技副总裁）\"></a>《天下武功，唯快不破》 王哲（触控科技副总裁）</h3><p>他从h5游戏的性能方面做了分析，对于h5的未来，他报以谨慎乐观的态度。<br>分析了h5游戏的性能方面：</p>\n<ul>\n<li>webGL性能提高 5~10倍 </li>\n<li>Canvas 脏矩形算法 性能提高2倍</li>\n<li>内存占用降低5%</li>\n<li>包体减小30%</li>\n</ul>\n<h3 id=\"《社交生态下的HTML5游戏辛新契机》李明-（很快CEO）\"><a href=\"#《社交生态下的HTML5游戏辛新契机》李明-（很快CEO）\" class=\"headerlink\" title=\"《社交生态下的HTML5游戏辛新契机》李明 （很快CEO）\"></a>《社交生态下的HTML5游戏辛新契机》李明 （很快CEO）</h3><p>“很快”鼓励开发者将技术转化为流量，并现场宣布，和9g合作，启动了亿元流量计划，为开发者提供流量。</p>\n<h3 id=\"《HTML5和Docker容器如何重构和颠覆应用产业》-马科（WeX5-CEO-）\"><a href=\"#《HTML5和Docker容器如何重构和颠覆应用产业》-马科（WeX5-CEO-）\" class=\"headerlink\" title=\"《HTML5和Docker容器如何重构和颠覆应用产业》 马科（WeX5 CEO ）\"></a>《HTML5和Docker容器如何重构和颠覆应用产业》 马科（WeX5 CEO ）</h3><p>首先这位被娜姐介绍说是“90后”CEO，引起现场一片轰动，90后出道的~ 哈哈<br>从互联网的扩大入口：h5会导致病毒式传播，形成闭环，不像传统app的场景分割。还有云计算即未来和对新技术的思考：要从应用场景切入，而不是重复造轮子。<br>对比了优秀app和传统app的区别， devops区别，这位干货很多。</p>\n<h3 id=\"《web技术：一个挑战极限的创新平台》-江小丹（英特尔-web技术研发总监）\"><a href=\"#《web技术：一个挑战极限的创新平台》-江小丹（英特尔-web技术研发总监）\" class=\"headerlink\" title=\"《web技术：一个挑战极限的创新平台》 江小丹（英特尔 web技术研发总监）\"></a>《web技术：一个挑战极限的创新平台》 江小丹（英特尔 web技术研发总监）</h3><p>提到了web前沿技术：web assembly nodejs 还有Intel在虚拟现实的技术尝试和酷炫的体验。</p>\n<h3 id=\"《web-前端的是实时化》-肖光宇-（野狗实时-联合创始人）\"><a href=\"#《web-前端的是实时化》-肖光宇-（野狗实时-联合创始人）\" class=\"headerlink\" title=\"《web 前端的是实时化》 肖光宇 （野狗实时 联合创始人）\"></a>《web 前端的是实时化》 肖光宇 （野狗实时 联合创始人）</h3><p>野狗是国内领先的实时后端云；野狗api–最实时通信api来了，应用于各大场景，可实时同步数据，网页通信，实时游戏，运用于汽车，实现实时同步汽车数据等。<br>使用野狗API,可以获得实时后端云的两大功能</p>\n<ul>\n<li>实时通信 ，包括消息订阅，推送，双向通信等功能。网络延迟小，服务响应速度快，API简单易用。</li>\n<li>数据存储，提供了一个Key-Value的云端数据存储，直接通过API就可以对数据进行存取操作。操作简单，按需扩展。</li>\n</ul>\n<h3 id=\"《移动互联网下半场-不用好HTML5，大部分公司都会死》王安（Dcloud-CEO）\"><a href=\"#《移动互联网下半场-不用好HTML5，大部分公司都会死》王安（Dcloud-CEO）\" class=\"headerlink\" title=\"《移动互联网下半场-不用好HTML5，大部分公司都会死》王安（Dcloud CEO）\"></a>《移动互联网下半场-不用好HTML5，大部分公司都会死》王安（Dcloud CEO）</h3><p>互联网下半场，原生应用成本高，留存率低等问题已经显现。如何用HTML5解决这个问题呢？他提供的答案就是流应用。</p>\n<h3 id=\"《H5游戏进入精品时代》谢成鸿-（LayaBox-CEO-）\"><a href=\"#《H5游戏进入精品时代》谢成鸿-（LayaBox-CEO-）\" class=\"headerlink\" title=\"《H5游戏进入精品时代》谢成鸿 （LayaBox CEO ）\"></a>《H5游戏进入精品时代》谢成鸿 （LayaBox CEO ）</h3><p>这个比较接地气，说什么目的都是能挣钱，第一桶金开发一款小游戏赚到一点小钱650万。<br>LayaBox阐述了未来游戏市场将呈现页游、手游、HTML5多端融合的趋势，强调了HTML5技术跨端、多屏、免下载等特点给游戏行业带来的革新性变化。在LayaBox看来，HTML5游戏是游戏市场上一课冉冉升起的新星，即将迎来爆发。同时，LayaBox也详细介绍了旗下第二代HTML5游戏引擎LayaAir，其支持Flash页游、APP手游、HTML5游戏 三端同发的特点和超越Unity3D的性能赢得了现场阵阵掌声。目前，LayaBox业务涵盖了引擎提供、游戏发行、游戏渠道、IP合作、项目投资、教育培训6大板块，是一家综合性的游戏服务企业。</p>\n<h2 id=\"工具应用专场1\"><a href=\"#工具应用专场1\" class=\"headerlink\" title=\"工具应用专场1\"></a>工具应用专场1</h2><h3 id=\"《高性能HTML5-APP-开发云实践——基于完全开源的WeX5开发框架》-王洁-（WeX5-首席技术运营）\"><a href=\"#《高性能HTML5-APP-开发云实践——基于完全开源的WeX5开发框架》-王洁-（WeX5-首席技术运营）\" class=\"headerlink\" title=\"《高性能HTML5 APP 开发云实践——基于完全开源的WeX5开发框架》 王洁  （WeX5  首席技术运营）\"></a>《高性能HTML5 APP 开发云实践——基于完全开源的WeX5开发框架》 王洁  （WeX5  首席技术运营）</h3><p>主要对原生APP和hybrid app的比较，简述为解决白页多webview 实现转场动画等， 复杂效果native 实现，简单效果h5实现“重混” - wex5 “轻混”，只需前端调用，提供打包平台<br>WeX5的可视化操作<br>wex5，一个纯h5app开放平台，组件风格分离，基于css3，引入bootstrp资源，可快速开发。一次开发，全面拥有安卓app，苹果app，微信服务号。真正的html5 app开发云。<br>Hybrid App走向“轻混”，剖析WeX5开源高性能HTML5 App开发框架</p>\n<blockquote>\n<p> 一. Hybrid App从“重混”到“轻混”的技术发展历程<br>基本上从早期的多元化走向了只有Android和iOS两个系统的环境。对于开发者来说，就意味着一个App需要制定两套实现方案，这对开发成本和维护成本都是非常大的挑战。基于这样一个现实，其解决方案就是想办法实现套代码跨端运行，所以Hybrid APP混合应用模式应运而生<br>在Hybrid APP发展早期，Web运行性能是当时的主要的瓶颈。Web在性能方面有缺陷，Web不够就用Native来凑，就是选择了用原生技术来弥补Web上的性能不足，其实就是多WebView。混合的单WebView最大的障碍就是页面切换，闪白很明显。手机里面又讲究用户交互体验，从一个页到另一个页想做个平滑的动画，用纯Web技术在当时的条件下是非常难以实现的，其实目前大多数框架也是这么做的，就是采用多WebView，这样可以平滑的转场。<br>因为早期硬件比较差，浏览器性能也一般般，所以有一些比较复杂的组件在实现一些功能的时候，速度比较慢。当时框架里是用NativeUI组件来弥补的，配合Web来实现这些功能。这种模式被定义为“重混”，用原生的能力去弥补UI，或者技术更偏Native的框架就被定义为重混的Hybrid App框架。<br>重混框架优缺点很明显，优点是提升了运行性能、增强了交互。缺点是Web和Native技术交叉混杂，增加了开发人员的工作难度。但是，当下的手机硬件配置已经有了很大的改善，包括浏览器技术的发展也很重要，在GS引擎方面都有长足的进步。实现功能的时候用Web的技术的前提下已经不再需要Native技术来弥补了，随着技术的发展，性能已经不再是瓶颈。</p>\n</blockquote>\n<blockquote>\n<p>另一个改变了移动应用这一领域的进程事件是，自从微信推出以后，相当于重新定义了移动应用的概念，通过它的服务号、公众号、企业号，微信本身变成了一种应用平台。包括微信最新的版本更新，它浏览器内核的升级，包括对游戏的支持，都和大量的移动App开发有着莫大的关联。而这个时候重混的框架就显得多余了，因为在重混框架里面很多性能的解决是依赖Native的原生部分。而到了微信里面，多WebView和NativeUI都没有了。原来在重混框架里面很强的一些能力完全就消失了，这时候在微信里面就有很多能力就不能用了。<br>于是轻混就成了目前真正要跨端Hybrid App的必然选择，这时候轻混的UI部分必须用纯Web技术，在底层的设备接口上，GS无法完成的原生部分需要Native技术来弥补。需要强调的是，Native的技术是不应该去侵入UI的，这样的一个框架就是我们所说的轻混Hybrid App框架，这才是真正的HTML5 App框架。</p>\n</blockquote>\n<blockquote>\n<p>二.构建高性能HTML5 App跨端框架<br>伴随着以上的观点，接下来谈谈如何构建轻混模式下的HTML5 App框架。这种混合框架很简单，首先要有一个内置了浏览器的外壳，在浏览器里提供网页运行环境，同时在这个外壳上提供很多插件，可以让网络通过GS进行操作。<br>基于这样的认识，王洁说，在选择HTML5框架设计的时候，要解决两个框架的问题，一个是HTML5的框架，一个是Native的框架。首先看Native框架的选择，选择PhoneGap框架，受到了业内主流厂商支持，微软也是用Cordova，它的插件框架是开放的，很容易自定义。<br>另外就是要解决HTML5的一些性能问题，如果不采用重混架构的话，在页面切换还是会有一些障碍，王洁说到，WeX5采用SPA单页应用模式，它是基于传统的页面加载模式MPA，页面之间互相独立。但是SPA的不同之处在于，其框架里整个页面是由外壳页面框架组成的，是用AJAX技术完成的，AJAX在桌面时代就存在，通过局部刷新来提升用户体验。但是把AJAX技术最大化来使用，整个页面框架都用AJAX来实现，每个页面的加载都是这样的方式。<br>对设备的局部渲染，可以在加载的时候在后面预加载再做转场动画，而且还不需要依赖多Web应用，不需要依赖Native就可以完成。而且在加载多页框架时每个页面的共用功能要重复加载。所以从各方面来说SPA相对于MPA是有极大的性能提升的。<br>SPA确实很好用，但是在设计产品的时候需要考虑到多人协作过程中，支持复杂应用的开发过程中，会不会出现多个ID会冲突，样式冲突，JS冲突等等致命问题？所以下面就谈到了页面隔离的问题。<br>解决这样棘手的问题，王洁说，首先要考虑到HTML元素ID冲突的问题，因为是可视化工具，所以ID属性的设计是拖到一个属性栏里去定义ID，这时候刚好可以用一个替换原则，用了XID来替换，不会直接设定ID属性。这样到内存里，会动态的生成真实的ID，会在XID后面加一个页面标志，这样可以保证多人写的页面在加载内存里ID是不相同的，也就不存在冲突。当然提供一些API的时候是能拿到真实ID，对应相应的元素，不影响访问。在整个组件体系里，开发者利用很简单的方法就可以拿到组件，可以很平滑的解决掉ID冲突的问题。<br>CSS样式冲突问题分为两类，一类样式是共用样式，多页面引用同一个页面；另一类样式被定义为私有样式，只使用页面，但不希望这个页面干扰到其他页面。这时候给每个页面都配了一个CSS文件，定义私有样式，限定在当前页面。实现起来也很简单，通过对工具的编译，把私有CSS文件里的所有样式加一个页面标志，在页面节点的属性上加一个标志，这样就使得class只能作用于当前页面的HTML元素，这就成为了一个私有样式。<br>然后是JavaScript问题，现在JavaScript模块化技术很流行，借用JavaScript模块化技术，解决JavaScript隔离问题。王洁在这里顺便把RequireJS简单的提了一下，通过define可以定义模块，在RequireJS定义里，这个大括号里的才是模块里的代码。不管是方法还是变量，都封装在闭包里，每个代码都是写在define的模块里，这样就把代码自然隔离了。<br>王洁说他们在外围还做了一些工作，首先是实现完整的外壳管理，Shell类提供外壳管理。为了防止信息泄露，在配置的时候确实会把页面完整卸载掉。当加载页面片断时，会从当前外壳数把JS删掉，页面加载的时候创建的JS对象都会完整的释放掉，这是由框架来保证的。另外是路由的问题，在SPA单页面框架里路由是很重要的，因为是单页面应用，加载的页面都是片断，其实UI地址一直是外壳的地址。<br>下图是整体框架的架构。黄色部分用的是Cordova，解决安卓和苹果的原生调用问题。同时要兼容微信，所以上面把Cordova和微信又做了封装，抽象成统一的HTML5 API。如果通过统一的Native API去拍照，会自动根据页面环境，通过Cordova接口调用，这样可以更方便的实现一次开发，多端运行，代码不需要改，既可以运行在原生App里，也可以运行在微信里。包括拍照、GPS地图，一系列的API都可以进统一分装。<br>Bootstrap在这里提供了几个能力。一个是样式美化，扁平化风格，另外响应式布局。基于Bootstrap设计的页面，运行在不同的设备上不需要考虑分辨率，会自动处理设备分辨率。再上面实现了WeX5的组件框架和数据框架，页面上不仅有交互的UI组件，页面里面还有数据。接下来是业务框架层，即SPA单元页面框架。在服务端WeX5还提供了XBaaS服务，负责后端数据存取、逻辑，还有第三方地图、支付等功能实现。WeX5提供多语言实现，提供了不同语言的版本，开发者可以针对自己的版本来集成到自己的框架里。<br>三、WeX5可视化快速开发实践<br>在分享的最后，王洁给大家展示了基于WeX5这样的框架所开发出来的一些功能。首先是可视化的快速开发程度，帮助开发者通过可视化开发定义页面，框架可以保证运行体验，必须能快速加载，而且各种首试、硬件能力的是一体化集成的。把组件拖到表单上定义布局，设置属性，即可得到最终页面，设计室和运行室相邻，完全所见即所得。<br>丰富多样的组件，足以适应各种复杂表单的组合。通过把常见功能组件封装，可以极大减轻开发者的开发工作量。最关键的是整个组件框架完全开源，除了WeX5提供的上百个组件以外开发者还可以自己定义这个可视化组件，甚至可以继承第三方组件，通过规范的方式封装成HTML5的可视化组件。<br>编程问题也是重点，WeX5的定位是可视化程度更高的前端编程工具。不仅可以可视化设计，编程也是便捷。它能实现代码的智能提示、代码模板，还内致了Emmet框架。随后考虑的是调试问题，WeX5是一体化的环境，不仅要解决开发、编程，还要解决调试的过程，既可以在Web浏览器上调试，也可以连到手机上调试，所有代码都是开源的，底层内库也是开放的。最后就是打包的问题，打包要考虑很多插件的配置，参数，资源在命令行的配合。WeX5提供了一个打包的向导，完全本地打包，不需要依赖云打包服务，只需要把打包过程中要设置的东西完全工具化，可以设置应用版本、证书、LOGO、图片、插件里的参数，最后就可以应用到App上。</p>\n</blockquote>\n<h3 id=\"《web技术推进多样化人机交互方式》吴栋夏-（英特尔-软件工程师）\"><a href=\"#《web技术推进多样化人机交互方式》吴栋夏-（英特尔-软件工程师）\" class=\"headerlink\" title=\"《web技术推进多样化人机交互方式》吴栋夏 （英特尔  软件工程师）\"></a>《web技术推进多样化人机交互方式》吴栋夏 （英特尔  软件工程师）</h3><p>讲述了Intel的各种“黑科技”，还介绍了关于深度增强摄像，场景感知与模型，crosswalk，nw.js<br>crosswalk<br>nwjs<br>nwjs是在英特尔开源技术中心创建的，它是基于谷歌浏览器核心引擎和nodejs运行，你可以通过nwjs技术使用html和js语言编写本地应用程序，它也可以让你直接从DOM调用nodejs模块，使用一种新的方式与所有的Web技术编写本地应用。它主要有以下6个特点：</p>\n<ul>\n<li>以网络最流行的技术编写原生应用程序的新方法</li>\n<li>基于HTML5, CSS3, JS and WebGL而编写</li>\n<li>完全支持nodejs所有api及第三方模块</li>\n<li>可以使用DOM直接调用nodejs模块</li>\n<li>容易打包和分发</li>\n<li>支持运行环境包括32位和64位的Window、Linux和Mac OS<h3 id=\"《Yo-去哪儿移动UI框架》-杜瑶（去哪儿网-前端开发总监）\"><a href=\"#《Yo-去哪儿移动UI框架》-杜瑶（去哪儿网-前端开发总监）\" class=\"headerlink\" title=\"《Yo-去哪儿移动UI框架》 杜瑶（去哪儿网  前端开发总监）\"></a>《Yo-去哪儿移动UI框架》 杜瑶（去哪儿网  前端开发总监）</h3>瑶姐机智自不必说，网红魅力；<br>YO 一款基于Sass开发的css框架，用于快速构建移动UI项目<br>mobile First<br>why mobile First (以mobile作为基准的设计为出发点)<br>公司战略转移<br>新战场需要有力的框架抹平平台切换所带来的适应过程<br>pc端已有成熟的解决方案，无需推倒重来<br>专注于某一具体的领域更能变得专业<br>mobile First 的好处<br>可以减少对历史问题的考虑，不如不用考虑IE<br>保证交互方式的单一性，不用考虑PC上的交互行为<br>更及时的应用上新技术<br>代码更轻量</li>\n</ul>\n<p>ios 默认风格<br>why ios<br>巨量的ios用户（超过50%）<br>安卓碎片化过重，不易挑选标示<br>ios的交互及展现更具备普适性</p>\n<p>Pure CSS 纯粹的css 框架<br>why pure css<br>职能更分明<br>能被使用在任何项目中<br>不紧密捆绑UI组件</p>\n<p>分层设计<br>Yo将不同的功能拆解成结构清晰的类别分散到不同的层去进行处理</p>\n<p>yo|—usage<br>|—lib</p>\n<p>分层设计的意义<br>清晰的依赖<br>高度解耦<br>高度复用<br>高可移植性<br>结束混乱的文件引用</p>\n<p>rem+px</p>\n<p>边框厚度使用px单位<br>字体，大小等除边框厚度外的定义使用rem<br>解决实现retina屏真正的1px 边框问题</p>\n<p>封装了丰富的常规问题解决方案</p>\n<p>独立配置层设计 config</p>\n<p>厂商前缀<br>iconfont<br>响应式</p>\n<p>元件</p>\n<p>扩展 超扩展</p>\n<p>动画库</p>\n<h3 id=\"《手机QQ-react-web极致优化》李成熙（Alloyteam工程师）\"><a href=\"#《手机QQ-react-web极致优化》李成熙（Alloyteam工程师）\" class=\"headerlink\" title=\"《手机QQ react web极致优化》李成熙（Alloyteam工程师）\"></a>《手机QQ react web极致优化》李成熙（Alloyteam工程师）</h3><p>讲述了手机QQ在react框架下的全家桶开发套件，以及踩过得各种坑和性能的极致优化<br>资料参考<a href=\"http://dev.qq.com/topic/579083d1c9da73584b02587d\" target=\"_blank\" rel=\"noopener\">http://dev.qq.com/topic/579083d1c9da73584b02587d</a><br>react 全家桶<br>在手Q家校群重构之前，其实我们已经做了一版PC家校群。当时将native的页面全部web化，直接就采用了React比较常用的全家桶套装：</p>\n<ul>\n<li>构建工具 =&gt; gulp + webpack</li>\n<li>开发效率提升 =&gt; redux-dev-tools + hot-reload</li>\n<li>统一数据管理=&gt; redux</li>\n<li>性能提升 =&gt; immutable + purerender</li>\n<li>路由控制器 =&gt; react-router(手Q暂时没采用)</li>\n</ul>\n<p>构建工具目录结构</p>\n<p>React 优化三大方向</p>\n<p>状态/数据管理优化</p>\n<p>针对React的这个数据比较的深比较deepCompare，要点有2个：</p>\n<ul>\n<li>尽量使传入的数据扁平化一点</li>\n<li>比较的时候做一些限制，避免溢出栈</li>\n</ul>\n<p>渲染性能优化</p>\n<p>首屏性能优化</p>\n<p>针对有cgi请求，需要吐大量数据的页面–同构直出<br>有几点值得说明：<br>比改造以前的项目，做直出更容易<br>减少的是首屏显示实践，而非首屏可交互时间<br>页面吐出html字符串之后，还需要在客户端，加载react包，进行事件绑定<br>做bigPipe之类的优化较难</p>\n<p>react同构直出文章<br>《React同构直出优化总结》<a href=\"http://www.alloyteam.com/2016/06/react-isomorphic/?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\" rel=\"noopener\">http://www.alloyteam.com/2016/06/react-isomorphic/?utm_source=tuicool&amp;utm_medium=referral</a><br>《腾讯新闻React同构直出优化实践》 <a href=\"http://www.alloyteam.com/2016/06/tencent-news-react-isomorphic-straight-out-optimization/?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\" rel=\"noopener\">http://www.alloyteam.com/2016/06/tencent-news-react-isomorphic-straight-out-optimization/?utm_source=tuicool&amp;utm_medium=referral</a><br>拆包<br>不用react-router，如何拆包？</p>\n<p>非基础功能，如运营活动 —轻量化类react方案<br>Preact—压缩后只有10kb，gzip后3kb<br>开源社区有较多的star（认可）<br>较好的性能和兼容性<br>api跟React接近<br>足够的框架周边，配置redux，router等使用，还有同构直出的插件<br>团队成员有能力维护的<br>作者参考文章《Preact-React的轻量解决方案》<a href=\"https://github.com/lcxfs1991/blog/issues/13?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\" rel=\"noopener\">https://github.com/lcxfs1991/blog/issues/13?utm_source=tuicool&amp;utm_medium=referral</a><br>简单回购</p>\n<p>Starter-Kit<br>steamer-react<br><a href=\"https://github.com/SteamerTeam/steamer-react/tree/react-preact\" target=\"_blank\" rel=\"noopener\">https://github.com/SteamerTeam/steamer-react/tree/react-preact</a><br>web分支，同构分支，preact兼容分支<br>腾讯发起的交流会 将于2016-10-23 日举行</p>\n<h3 id=\"《手机淘宝营销互动页面的最佳实践》黄华健（阿里巴巴-前端工程师）\"><a href=\"#《手机淘宝营销互动页面的最佳实践》黄华健（阿里巴巴-前端工程师）\" class=\"headerlink\" title=\"《手机淘宝营销互动页面的最佳实践》黄华健（阿里巴巴  前端工程师）\"></a>《手机淘宝营销互动页面的最佳实践》黄华健（阿里巴巴  前端工程师）</h3><blockquote>\n<p>呆萌的前端工程师 讲的很棒很棒</p>\n</blockquote>\n<p>他鼓励前端开发者们沉淀出自己的最佳实践，同时大家可以去看一下他们开源的解决方案：站在巨人的肩膀上才能看得更远<br>对比以前需求来了-干活的工作模式，工程化-自动化工作流能提高效率即新一代构建工具 rollup （参考文章 <a href=\"http://jixianqianduan.com/frontend-build/2016/01/20/next-generation-js-module-bunlder.html?utm_source=tuicool&amp;utm_medium=referral）\" target=\"_blank\" rel=\"noopener\">http://jixianqianduan.com/frontend-build/2016/01/20/next-generation-js-module-bunlder.html?utm_source=tuicool&amp;utm_medium=referral）</a></p>\n<p>解析ES2015Module<br>Tree-shaking</p>\n<p>再来总结下rollup： - 支持ES6模块规范打包成其它任一格式规范 - 支持tree-shaking方式打包 - 方便接入构建，如gulp - 需要书写配置任务<br>索性github上有demo，我还没有来的及实践，抛链接<br><a href=\"https://github.com/amfe/activity-template\" target=\"_blank\" rel=\"noopener\">手机淘宝营销互动脚手架</a></p>\n<h3 id=\"《从MI-Cloud的架构变迁看大型spa的复杂工程如何化简》陈恺睿-（小米-高级前端工程师）\"><a href=\"#《从MI-Cloud的架构变迁看大型spa的复杂工程如何化简》陈恺睿-（小米-高级前端工程师）\" class=\"headerlink\" title=\"《从MI Cloud的架构变迁看大型spa的复杂工程如何化简》陈恺睿 （小米 高级前端工程师）\"></a>《从MI Cloud的架构变迁看大型spa的复杂工程如何化简》陈恺睿 （小米 高级前端工程师）</h3><p>Mi Cloud的主站就是这样的一个大型的SPA，它主要定位于PC端，PC端包括Web版和桌面应用，同时也兼顾一下移动端。Mi Cloud也正在基于electron开发一个桌面应用<br>第一次重构<br>用CommonJS和browserify实现模块化方案，基于grunt实现自动化构建流程 替代之前满屏jquery 操作dom<br>第二次重构<br>又对工程基础做了进一步的升级，采用标准的ES6的模块规范，加上更强大的webpack实现模块化方案，基于gulp实现自动化构建流程，完全是流式处理，减少硬盘IO，开发环境下进行一次实时编译从原来的20s左右压缩到1s内。最近几年，前端领域新技术层出不穷，其中不乏实实在在能提高生产力的方案，从browserify+grunt到webpack+gulp就是这样一个典型的例子，从backbone到angular再到react+redux也是一个典型的例子。<br>然后开始拿业务层开刀。当时恰好有一个业务要做比较大的改版，于是我开始基于Backbone实现MVC架构。<br>得到的是一个基于Backbone的MVC架构</p>\n<p>完整的流程：<br>首先用户操作了界面，比如一个点击，view层抛出事件告诉controller，controller调用model层某个实例的方法，让model层向服务器操作，完了之后，model层抛出事件告诉controller，controller调用view层某个实例的方法，更新界面。<br>其实，我在实践这套MVC架构的时候，也一直觉得controller部分太复杂，仔细分析一下，controller内主要分为两套流程：步骤2，3是一套流程；步骤5，6是另一套流程。这两套流程其实是互相独立的、互不干涉的，但都流经同一个节点，这无疑加剧了这个节点的复杂度。<br>model层和view层不知道彼此的存在，甚至不知道controller的存在，它们只是通过抛出事件通知外界自己处于什么状态，比如view中的哪个按钮被点击了，model中的哪个字段有更新了。它们不关心谁监听这些事件。<br>好处：</p>\n<ul>\n<li>model层和view层完全分离，可以由不同的人并行开发</li>\n<li>可以不依赖走通整个流程来测试，model层和controller完全没有DOM操作，可以实现自动化的单元测试</li>\n<li>要增加或删除功能，只需要开始或停止监听事件即可，层与层之间解耦之后很容易实现对某一部分的替换、增减</li>\n</ul>\n<p>于是我将controller的两套流程分离一下，各司其职。<br>这样，不管是从model层到view层的数据流，还是从view层到model层的数据流，虽然这两个数据流的起点和终点是对调过来的，但它们流经的节点不一样，这样就清晰了很多。<br>熟悉react和redux的朋友，可能看这幅图会比较眼熟。是的，这个时候已经形成了一个单向数据流的闭环。其实，当时我也不知道这会形成所谓的单向数据流，只是在探索怎么化简复杂度罢了。<br>架构演变到这一步，其实已经开始了第二轮重构，当时还是2015年夏天，我开始热火朝天的写一些demo尝试这个架构模式。<br>另一方面，我已经开始尝试将view层组件化，也就是将一个个视图类实现成可组合可嵌套的，在通用的视图类上实现了一套添加子组件/移除子组件等等的API，将整个界面实现成一个个视图实例组成的树状结构。<br>但其中一直有一些痛点，其中以view层的痛点最加剧业务的复杂度。</p>\n<p>于是在view层我改成使用react来实现。业务层只需要写全量渲染的代码，再也不用写局部更新的代码了，框架自己会帮业务层对DOM做局部更新。手动点个赞。<br>网上也有很多使用backbone的model配合react的文章，其实就类似于我们的架构演变到这一步时的方案。<br>于是我继续实践，很快又挖出了一个痛点。。<br>更新组件树中的深层节点时很麻烦。<br>一开始的做法是，从组件树的根节点一层层的往下传数据，这显然很麻烦。<br>再次带着问题寻找解决方案。此时redux框架经过多次迭代之后，开始成熟、稳定下来，我发现redux提供的connect函数正好能让我直接把数据传递给组件树中的深层节点。<br>于是我引入了redux，最终项目的架构就变成了这样</p>\n<p>除了为业务降低复杂度的框架，大型SPA的未来还有很多挑战。比如：</p>\n<ul>\n<li>强类型，静态类型检查</li>\n<li>异常处理的最佳实践</li>\n<li><p>自动化测试的健全：因为基于react这种视图层框架几乎不需要操作DOM，基于redux这种函数式编程思想的框架管理整个应用的状态，副作用和状态都得到很好的控制<br>控制复杂度的心得。</p>\n</li>\n<li><p>分治：不管多么庞大的问题，咋一看很复杂，但把它切割成一个个小问题之后，局面就变得清晰了很多。模块化、组件化都是这个思路，我觉得前端的路由也体现了分治的思想，把路由看作一个有限状态机，它就将应用的生命周期划分成了几个大的状态。</p>\n</li>\n<li>善于利用巨人的肩膀：其实，复杂度并不会减少，它只会从一个地方转移到另一个地方，复用组件如此，框架为业务层封装复杂性也是如此，所以，善于利于巨人的肩膀，因为它已经帮你转移了复杂度。</li>\n<li>先确认瓶颈再做性能优化：虽然是老生常谈，但还是要强调一下，因为真的很有用但又很容易忘记。</li>\n<li>二八原则：考虑项目的生命周期、影响力来衡量投入的资源，好钢用在刀刃上，我个人感觉小米挺强调成本控制的，毕竟我们是创业公司，跟大公司可以适当冗余不太一样。</li>\n</ul>\n<h3 id=\"《UC前端业务套件体系》三桥（阿里巴巴UC移动事业群-高级前端工程师）\"><a href=\"#《UC前端业务套件体系》三桥（阿里巴巴UC移动事业群-高级前端工程师）\" class=\"headerlink\" title=\"《UC前端业务套件体系》三桥（阿里巴巴UC移动事业群  高级前端工程师）\"></a>《UC前端业务套件体系》三桥（阿里巴巴UC移动事业群  高级前端工程师）</h3><p>三桥大神主要讲的偏架构方向，也接近了尾声，实在太累没做过多记录。这里就不在提供摘要，近期会提供相关PPT。</p>\n<blockquote>\n<p>很可惜，只参与了工具1的分会场<br>更多内容以及PPT会近期发布。</p>\n</blockquote>"},{"title":"前端开发面试题","date":"2016-08-30T02:06:16.000Z","_content":"本文收集总结了一些前端面试题，初学者阅后也要用心钻研其中的原理，重要知识需要系统学习、透彻学习，形成自己的知识链。万不可投机取巧，临时抱佛脚只求面试侥幸混过关是错误的！也是不可能的！不可能的！不可能的！\n<!--more-->\n## <a name='preface'>前言</a> ##\n前端还是一个年轻的行业，新的行业标准， 框架， 库都不断在更新和新增，正如赫门在2015深JS大会上的《前端服务化之路》主题演讲中说的一句话：“每18至24个月，前端都会难一倍”，这些变化使前端的能力更加丰富、创造的应用也会更加完美。所以关注各种前端技术，跟上快速变化的节奏，也是身为一个前端程序员必备的技能之一。\n\n**面试有几点需注意：**\n来源[寒冬winter](http://weibo.com/wintercn \"微博：寒冬winter\") 老师，github:@wintercn\n1. 面试题目： 根据你的等级和职位的变化，入门级到专家级，广度和深度都会有所增加。\n\n1. 题目类型： 理论知识、算法、项目细节、技术视野、开放性题、工作案例。\n\n1. 细节追问： 可以确保问到你开始不懂或面试官开始不懂为止，这样可以大大延展题目的区分度和深度，知道你的实际能力。因为这种知识关联是长时期的学习，临时抱佛脚绝对是记不住的。\n\n1. 回答问题再棒，面试官（可能是你面试职位的直接领导），会考虑我要不要这个人做我的同事？所以态度很重要、除了能做事，还要会做人。（感觉更像是相亲）\n\n1. 资深的前端开发能把absolute和relative弄混，这样的人不要也罢，因为团队需要的是：你这个人具有可以依靠的才能（靠谱）。\n\n\n**前端开发知识点：**\n```\nHTML&CSS：\n    对Web标准的理解、浏览器内核差异、兼容性、hack、CSS基本功：布局、盒子模型、选择器优先级、\n    HTML5、CSS3、Flexbox\n\nJavaScript：\n    数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、RegExp、JSON、Ajax、\n    DOM、BOM、内存泄漏、跨域、异步装载、模板引擎、前端MVC、路由、模块化、Canvas、ECMAScript 6、Nodejs\n\n其他：\n    移动端、响应式、自动化构建、HTTP、离线存储、WEB安全、优化、重构、团队协作、可维护、易用性、SEO、UED、架构、职业生涯、快速学习能力\n```\n作为一名前端工程师，**无论工作年头长短都应该掌握的知识点**：\n此条由 王子墨 发表在 [攻城师的实验室](http://lab.yuanwai.wang/)\n```\n1、DOM结构 —— 两个节点之间可能存在哪些关系以及如何在节点之间任意移动。\n\n2、DOM操作 —— 如何添加、移除、移动、复制、创建和查找节点等。\n\n3、事件 —— 如何使用事件，以及IE和标准DOM事件模型之间存在的差别。\n\n4、XMLHttpRequest —— 这是什么、怎样完整地执行一次GET请求、怎样检测错误。\n\n5、严格模式与混杂模式 —— 如何触发这两种模式，区分它们有何意义。\n\n6、盒模型 —— 外边距、内边距和边框之间的关系，及IE8以下版本的浏览器中的盒模型\n\n7、块级元素与行内元素 —— 怎么用CSS控制它们、以及如何合理的使用它们\n\n8、浮动元素 —— 怎么使用它们、它们有什么问题以及怎么解决这些问题。\n\n9、HTML与XHTML —— 二者有什么区别，你觉得应该使用哪一个并说出理由。\n\n10、JSON —— 作用、用途、设计结构。\n```\n**备注：**\n> 根据自己需要选择性阅读，面试题是对理论知识的总结，让自己学会应该如何表达。\n资料答案不够正确和全面，欢迎欢迎Star和提交issues。\n格式不断修改更新中。\n更新记录：\n2016年3月25日：新增ECMAScript6 相关问题\n\n\n###更新时间:  2016-3-25\n\n## <a name='html'>HTML</a>\n- Doctype作用？标准模式与兼容模式各有什么区别?\n```\n（1）、<!DOCTYPE>声明位于位于HTML文档中的第一行，处于 <html> 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。\n\n（2）、标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。\n```\n\n- HTML5 为什么只需要写 <!DOCTYPE HTML>？\n```\n HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；\n\n 而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。\n```\n\n- 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？\n```\n首先：CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。\n\n（1）行内元素有：a b span img input select strong（强调的语气）\n（2）块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p\n\n（3）常见的空元素：\n    <br> <hr> <img> <input> <link> <meta>\n    鲜为人知的是：\n    <area> <base> <col> <command> <embed> <keygen> <param> <source> <track> <wbr>\n```\n\n- 页面导入样式时，使用link和@import有什么区别？\n```\n（1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;\n\n（2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;\n\n（3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题;\n```\n\n- 介绍一下你对浏览器内核的理解？\n```\n主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。\n渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。\n\nJS引擎则：解析和执行javascript来实现网页的动态效果。\n\n最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。\n```\n\n- 常见的浏览器内核有哪些？\n```\nTrident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]\nGecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等\nPresto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]\nWebkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]\n```\n> 详细文章：[浏览器内核的解析和对比](http://www.cnblogs.com/fullhouse/archive/2011/12/19/2293455.html)\n\n- html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和\nHTML5？\n```\n* HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。\n      绘画 canvas;\n      用于媒介回放的 video 和 audio 元素;\n      本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;\n      sessionStorage 的数据在浏览器关闭后自动删除;\n      语意化更好的内容元素，比如 article、footer、header、nav、section;\n      表单控件，calendar、date、time、email、url、search;\n      新的技术webworker, websocket, Geolocation;\n\n  移除的元素：\n      纯表现的元素：basefont，big，center，font, s，strike，tt，u;\n      对可用性产生负面影响的元素：frame，frameset，noframes；\n\n* 支持HTML5新标签：\n     IE8/IE7/IE6支持通过document.createElement方法产生的标签，\n     可以利用这一特性让这些浏览器支持HTML5新标签，\n     浏览器支持新标签后，还需要添加标签默认的样式。\n\n     当然也可以直接使用成熟的框架、比如html5shim;\n     <!--[if lt IE 9]>\n        <script> src=\"http://html5shim.googlecode.com/svn/trunk/html5.js\"</script>\n     <![endif]-->\n\n* 如何区分HTML5： DOCTYPE声明\\新增的结构元素\\功能元素\n```\n\n- 简述一下你对HTML语义化的理解？\n```\n用正确的标签做正确的事情。\nhtml语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;\n即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;\n搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;\n使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。\n```\n\n- HTML5的离线储存怎么使用，工作原理能不能解释一下？\n```\n在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。\n原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。\n\n如何使用：\n1、页面头部像下面一样加入一个manifest的属性；\n2、在cache.manifest文件的编写离线存储的资源；\n    CACHE MANIFEST\n    #v0.11\n    CACHE:\n    js/app.js\n    css/style.css\n    NETWORK:\n    resourse/logo.png\n    FALLBACK:\n    / /offline.html\n3、在离线状态时，操作window.applicationCache进行需求实现。\n\n```\n> 详细的使用请参考：[有趣的HTML5：离线存储](http://segmentfault.com/a/1190000000732617)\n\n\n- 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？\n```\n在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。\n离线的情况下，浏览器就直接使用离线存储的资源。\n```\n> 详细的使用请参考：[有趣的HTML5：离线存储](http://segmentfault.com/a/1190000000732617)\n\n- 请描述一下 cookies，sessionStorage 和 localStorage 的区别？\n```\ncookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。\ncookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。\nsessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。\n\n存储大小：\n    cookie数据大小不能超过4k。\n    sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。\n\n有期时间：\n    localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；\n    sessionStorage  数据在当前浏览器窗口关闭后自动删除。\n    cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭\n```\n\n- iframe有那些缺点？\n```\n*iframe会阻塞主页面的Onload事件；\n*搜索引擎的检索程序无法解读这种页面，不利于SEO;\n\n*iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。\n\n使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript\n动态给iframe添加src属性值，这样可以绕开以上两个问题。\n```\n\n- Label的作用是什么？是怎么用的？\n```\nlabel标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。\n\n<label for=\"Name\">Number:</label>\n<input type=“text“name=\"Name\" id=\"Name\"/>\n\n<label>Date:<input type=\"text\" name=\"B\"/></label>\n```\n\n- HTML5的form如何关闭自动完成功能？\n```\n给不想要提示的 form 或某个 input 设置为 autocomplete=off。\n```\n\n- 如何实现浏览器内多个标签页之间的通信? (阿里)\n```\nWebSocket、SharedWorker；\n也可以调用localstorge、cookies等本地存储方式；\n\nlocalstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，\n我们通过监听事件，控制它的值来进行页面信息通信；\n注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常；\n```\n\n- webSocket如何兼容低浏览器？(阿里)\n```\nAdobe Flash Socket 、\nActiveX HTMLFile (IE) 、\n基于 multipart 编码发送 XHR 、\n基于长轮询的 XHR\n```\n\n- 页面可见性（Page Visibility API） 可以有哪些用途？\n```\n通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;\n在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放；\n```\n\n- 如何在页面上实现一个圆形的可点击区域？\n```\n1、map+area或者svg\n2、border-radius\n3、纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等\n```\n\n- 实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。\n```\n<div style=\"height:1px;overflow:hidden;background:red\"></div>\n```\n\n- 网页验证码是干嘛的，是为了解决什么安全问题。\n```\n区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水；\n有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。\n```\n\n- title与h1的区别、b与strong的区别、i与em的区别？\n```\ntitle属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响；\n\nstrong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：<strong>会重读，而<B>是展示强调内容。\n\ni内容展示为斜体，em表示强调的文本；\n\nPhysical Style Elements -- 自然样式标签\nb, i, u, s, pre\nSemantic Style Elements -- 语义样式标签\nstrong, em, ins, del, code\n应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。\n```\n\n## <a name='css'>CSS</a>\n\n- 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？\n```\n（1）有两种， IE 盒子模型、W3C 盒子模型；\n（2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；\n（3）区  别： IE的content部分把 border 和 padding计算了进去;\n```\n\n- CSS选择符有哪些？哪些属性可以继承？\n```\n*   1.id选择器（ # myid）\n    2.类选择器（.myclassname）\n    3.标签选择器（div, h1, p）\n    4.相邻选择器（h1 + p）\n    5.子选择器（ul > li）\n    6.后代选择器（li a）\n    7.通配符选择器（ * ）\n    8.属性选择器（a[rel = \"external\"]）\n    9.伪类选择器（a:hover, li:nth-child）\n\n*   可继承的样式： font-size font-family color, UL LI DL DD DT;\n\n*   不可继承的样式：border padding margin width height ;\n```\n\n\n- CSS优先级算法如何计算？\n```\n*   优先级就近原则，同权重情况下样式定义最近者为准;\n\n*   载入样式以最后载入的定位为准;\n\n优先级为:\n   !important >  id > class > tag\n    important 比 内联优先级高\n```\n\n- CSS3新增伪类有那些？\n```\n举例：\np:first-of-type 选择属于其父元素的首个 <p> 元素的每个 <p> 元素。\np:last-of-type  选择属于其父元素的最后 <p> 元素的每个 <p> 元素。\np:only-of-type  选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。\np:only-child        选择属于其父元素的唯一子元素的每个 <p> 元素。\np:nth-child(2)  选择属于其父元素的第二个子元素的每个 <p> 元素。\n\n:after          在元素之前添加内容,也可以用来做清除浮动。\n:before         在元素之后添加内容\n:enabled        \n:disabled       控制表单控件的禁用状态。\n:checked        单选框或复选框被选中。\n```\n\n- 如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？\n```\n* 给div设置一个宽度，然后添加margin:0 auto属性\n  div{\n      width:200px;\n      margin:0 auto;\n   }\n\n\n* 居中一个浮动元素\n\n  确定容器的宽高 宽500 高 300 的层设置层的外边距\n .div {\n      width:500px ; height:300px;//高度可以不设\n      margin: -150px 0 0 -250px;\n      position:relative;         //相对定位\n      background-color:pink;     //方便看效果\n      left:50%;\n      top:50%;\n }\n\n* 让绝对定位的div居中\n\n  position: absolute;\n  width: 1200px;\n  background: none;\n  margin: 0 auto;\n  top: 0;\n  left: 0;\n  bottom: 0;\n  right: 0;\n```\n\n- display有哪些值？说明他们的作用。\n```\nblock         象块类型元素一样显示。\nnone          缺省值。象行内元素类型一样显示。\ninline-block  象行内元素一样显示，但其内容象块类型元素一样显示。\nlist-item     象块类型元素一样显示，并添加样式列表标记。\ntable         此元素会作为块级表格来显示\ninherit       规定应该从父元素继承 display 属性的值\n```\n\n- position的值relative和absolute定位原点是？\n```\nabsolute\n  生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。\nfixed （老IE不支持）\n  生成绝对定位的元素，相对于浏览器窗口进行定位。\nrelative\n  生成相对定位的元素，相对于其正常位置进行定位。\nstatic\n  默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。\ninherit\n  规定从父元素继承 position 属性的值。\n```\n\n- CSS3有哪些新特性？\n```\n新增各种CSS选择器    （: not(.input)：所有 class 不是“input”的节点）\n圆角           （border-radius:8px）\n多列布局        （multi-column layout）\n阴影和反射      （Shadow\\Reflect）\n文字特效      （text-shadow、）\n文字渲染      （Text-decoration）\n线性渐变      （gradient）\n旋转          （transform）\n增加了旋转,缩放,定位,倾斜,动画，多背景\ntransform:\\scale(0.85,0.90)\\ translate(0px,-30px)\\ skew(-9deg,0deg)\\Animation:\n```\n\n- 请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？\n```\n...\n```\n\n- 用纯CSS创建一个三角形的原理是什么？\n```\n把上、左、右三条边隐藏掉（颜色设为 transparent）\n#demo {\n  width: 0;\n  height: 0;\n  border-width: 20px;\n  border-style: solid;\n  border-color: transparent transparent red transparent;\n}\n\n```\n\n- 一个满屏 品 字布局 如何设计?\n```\n简单的方式：\n    上面的div宽100%，\n    下面的两个div分别宽50%，\n    然后用float或者inline使其不换行即可\n```\n\n- 经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？\n```\n* png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.\n\n* 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。\n\n* IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。\n\n  浮动ie产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 100px;}\n\n  这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)\n\n  渐进识别的方式，从总体中逐渐排除局部。\n\n  首先，巧妙的使用“\\9”这一标记，将IE游览器从所有情况中分离出来。\n  接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。\n\n  css\n      .bb{\n          background-color:#f1ee18;/*所有识别*/\n          .background-color:#00deff\\9; /*IE6、7、8识别*/\n          +background-color:#a200ff;/*IE6、7识别*/\n          _background-color:#1e0bd1;/*IE6识别*/\n      }\n\n*  IE下,可以使用获取常规属性的方法来获取自定义属性,\n   也可以使用getAttribute()获取自定义属性;\n   Firefox下,只能使用getAttribute()获取自定义属性。\n   解决方法:统一通过getAttribute()获取自定义属性。\n\n*  IE下,even对象有x,y属性,但是没有pageX,pageY属性;\n   Firefox下,event对象有pageX,pageY属性,但是没有x,y属性。\n\n*  解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。\n\n*  Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,\n   可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。\n\n超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:\nL-V-H-A :  a:link {} a:visited {} a:hover {} a:active {}\n```\n\n- li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？\n``` \n行框的排列会受到中间空白（回车\\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。\n```\n\n- 为什么要初始化CSS样式。\n```\n- 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。\n\n- 当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。\n\n最简单的初始化方法： * {padding: 0; margin: 0;} （强烈不建议）\n\n淘宝的样式初始化代码：\nbody, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td { margin:0; padding:0; }\nbody, button, input, select, textarea { font:12px/1.5tahoma, arial, \\5b8b\\4f53; }\nh1, h2, h3, h4, h5, h6{ font-size:100%; }\naddress, cite, dfn, em, var { font-style:normal; }\ncode, kbd, pre, samp { font-family:couriernew, courier, monospace; }\nsmall{ font-size:12px; }\nul, ol { list-style:none; }\na { text-decoration:none; }\na:hover { text-decoration:underline; }\nsup { vertical-align:text-top; }\nsub{ vertical-align:text-bottom; }\nlegend { color:#000; }\nfieldset, img { border:0; }\nbutton, input, select, textarea { font-size:100%; }\ntable { border-collapse:collapse; border-spacing:0; }\n```\n\n- absolute的containing block(容器块)计算方式跟正常流有什么不同？\n```\n无论属于哪种，都要先找到其祖先元素中最近的 position 值不为 static 的元素，然后再判断：\n1、若此元素为 inline 元素，则 containing block 为能够包含这个元素生成的第一个和最后一个 inline box 的 padding box (除 margin, border 外的区域) 的最小矩形；\n2、否则,则由这个祖先元素的 padding box 构成。\n如果都找不到，则为 initial containing block。\n\n补充：\n1. static(默认的)/relative：简单说就是它的父元素的内容框（即去掉padding的部分）\n2. absolute: 向上找最近的定位为absolute/relative的元素\n3. fixed: 它的containing block一律为根元素(html/body)，根元素也是initial containing block\n```\n\n- CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？\n\n- position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？\n\n- 对BFC规范(块级格式化上下文：block formatting context)的理解？\n```\n（W3C CSS 2.1 规范中的一个概念,它是一个独立容器，决定了元素如何对其内容进行定位,以及与其他元素的关系和相互作用。）\n 一个页面是由很多个 Box 组成的,元素的类型和 display 属性,决定了这个 Box 的类型。\n 不同类型的 Box,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响。\n ```\n- css定义的权重\n```\n以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下例子是演示各种定义的权重值：\n\n/*权重为1*/\ndiv{\n}\n/*权重为10*/\n.class1{\n}\n/*权重为100*/\n#id1{\n}\n/*权重为100+1=101*/\n#id1 div{\n}\n/*权重为10+1=11*/\n.class1 div{\n}\n/*权重为10+10+1=21*/\n.class1 .class2 div{\n}\n\n如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现\n```\n\n- 请解释一下为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式\n\n\n- 移动端的布局用过媒体查询吗？\n\n\n- 使用 CSS 预处理器吗？喜欢那个？\n```\nSASS (SASS、LESS没有本质区别，只因为团队前端都是用的SASS)\n```\n\n- CSS优化、提高性能的方法有哪些？\n\n- 浏览器是怎样解析CSS选择器的？\n\n- 在网页中的应该使用奇数还是偶数的字体？为什么呢？\n\n- margin和padding分别适合什么场景使用？\n\n- 抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题]\n\n- 元素竖向的百分比设定是相对于容器的高度吗？\n\n- 全屏滚动的原理是什么？用到了CSS的那些属性？\n\n- 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？\n\n- 视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）\n\n- ::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。\n\n- 如何修改chrome记住密码后自动填充表单的黄色背景 ？\n\n- 你对line-height是如何理解的？\n\n- 设置元素浮动后，该元素的display值是多少？（自动变成display:block）\n\n- 怎么让Chrome支持小于12px 的文字？\n\n- 让页面里的字体变清晰，变细用CSS怎么做？（-webkit-font-smoothing: antialiased;）\n\n- font-style属性可以让它赋值为“oblique” oblique是什么意思？\n\n- position:fixed;在android下无效怎么处理？\n\n- 如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）\n```\n 多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms\n```\n\n- display:inline-block 什么时候会显示间隙？(携程)\n```\n移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing\n```\n- overflow: scroll时不能平滑滚动的问题怎么处理？\n\n- 有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度。\n\n- png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？\n\n\n- 什么是Cookie 隔离？（或者说：请求资源的时候不要让它带cookie怎么做）\n```\n如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，\n所以不如隔离开。\n\n因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，\n这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。\n\n同时这种方式不会将cookie传入Web Server，也减少了Web Server对cookie的处理分析环节，\n提高了webserver的http请求的解析速度。\n```\n\n- style标签写在body后与body前有什么区别？\n\n- 什么是CSS 预处理器 / 后处理器？\n```\n- 预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。\n\n- 后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。\n```\n\n## <a name='js'>JavaScript</a>\n\n-  介绍js的基本数据类型。\n```\n Undefined、Null、Boolean、Number、String、Symbol(new in ECMAScript 2015)\n```\n\n-  介绍js有哪些内置对象？\n```\nObject 是 JavaScript 中所有对象的父对象\n\n数据封装类对象：Object、Array、Boolean、Number 和 String\n其他对象：Function、Arguments、Math、Date、RegExp、Error\n```\n\n-  说几条写JavaScript的基本规范？\n```\n1.不要在同一行声明多个变量。\n2.请使用 ===/!==来比较true/false或者数值\n3.使用对象字面量替代new Array这种形式\n4.不要使用全局函数。\n5.Switch语句必须带有default分支\n6.函数不应该有时候有返回值，有时候没有返回值。\n7.For循环必须使用大括号\n8.If语句必须使用大括号\n9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。\n```\n\n-  JavaScript原型，原型链 ? 有什么特点？\n```\n每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，\n如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，\n于是就这样一直找下去，也就是我们平时所说的原型链的概念。\n关系：instance.constructor.prototype = instance.__proto__\n\n特点：\nJavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。\n\n\n 当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的话，\n 就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。\n    function Func(){}\n    Func.prototype.name = \"Sean\";\n    Func.prototype.getInfo = function() {\n      return this.name;\n    }\n    var person = new Func();//现在可以参考var person = Object.create(oldObject);\n    console.log(person.getInfo());//它拥有了Func的属性和方法\n    //\"Sean\"\n    console.log(Func.prototype);\n    // Func { name=\"Sean\", getInfo=function()}\n```\n\n-  JavaScript有几种类型的值？，你能画一下他们的内存图吗？\n```\n栈：原始数据类型（Undefined，Null，Boolean，Number、String） \n堆：引用数据类型（对象、数组和函数）\n\n两种类型的区别是：存储位置不同；\n原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；\n引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其\n在栈中的地址，取得地址后从堆中获得实体\n```        \n![Stated Clearly Image](http://www.w3school.com.cn/i/ct_js_value.gif)\n\n-  Javascript如何实现继承？\n```\n1、构造继承\n2、原型继承\n3、实例继承\n4、拷贝继承\n\n原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。\n```\n```javascript\nfunction Parent(){\n    this.name = 'wang';\n}\n\nfunction Child(){\n    this.age = 28;\n}\nChild.prototype = new Parent();//继承了Parent，通过原型\n\nvar demo = new Child();\nalert(demo.age);\nalert(demo.name);//得到被继承的属性\n```\n- JavaScript继承的几种实现方式？\n> 参考：[构造函数的继承](http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html)，[非构造函数的继承](http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html)；\n\n-  javascript创建对象的几种方式？\n```\njavascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用。\n\n1、对象字面量的方式   \n\n    person={firstname:\"Mark\",lastname:\"Yun\",age:25,eyecolor:\"black\"};\n\n2、用function来模拟无参的构造函数\n\n    function Person(){}\n    var person=new Person();//定义一个function，如果使用new\"实例化\",该function可以看作是一个Class\n    person.name=\"Mark\";\n    person.age=\"25\";\n    person.work=function(){\n    alert(person.name+\" hello...\");\n    }\n    person.work();\n\n3、用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）\n\n    function Pet(name,age,hobby){\n       this.name=name;//this作用域：当前对象\n       this.age=age;\n       this.hobby=hobby;\n       this.eat=function(){\n          alert(\"我叫\"+this.name+\",我喜欢\"+this.hobby+\",是个程序员\");\n       }\n    }\n    var maidou =new Pet(\"麦兜\",25,\"coding\");//实例化、创建对象\n    maidou.eat();//调用eat方法\n\n\n4、用工厂方式来创建（内置对象）\n\n     var wcDog =new Object();\n     wcDog.name=\"旺财\";\n     wcDog.age=3;\n     wcDog.work=function(){\n       alert(\"我是\"+wcDog.name+\",汪汪汪......\");\n     }\n     wcDog.work();\n\n\n5、用原型方式来创建\n\n    function Dog(){\n    \n     }\n     Dog.prototype.name=\"旺财\";\n     Dog.prototype.eat=function(){\n     alert(this.name+\"是个吃货\");\n     }\n     var wangcai =new Dog();\n     wangcai.eat();\n\n\n5、用混合方式来创建\n\n    function Car(name,price){\n      this.name=name;\n      this.price=price; \n    }\n     Car.prototype.sell=function(){\n       alert(\"我是\"+this.name+\"，我现在卖\"+this.price+\"万元\");\n      }\n    var camry =new Car(\"凯美瑞\",27);\n    camry.sell(); \n```\n\n-  Javascript作用链域?\n```\n全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。\n当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，\n直至全局函数，这种组织形式就是作用域链。\n```\n-  谈谈This对象的理解。\n```\n  * this总是指向函数的直接调用者（而非间接调用者）；\n  * 如果有new关键字，this指向new出来的那个对象；\n  * 在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window；\n```\n\n-  eval是做什么的？\n```\n它的功能是把对应的字符串解析成JS代码并运行；\n应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。\n由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval('('+ str +')');\n```\n\n-  什么是window对象? 什么是document对象?\n\n\n-  null，undefined 的区别？\n```\n// ull，undefined 的区别？\nnull        表示一个对象被定义了，值为“空值”；\nundefined   表示不存在这个值。\n```\n```\ntypeof undefined\n    //\"undefined\"\n    undefined :是一个表示\"无\"的原始值或者说表示\"缺少值\"，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined； \n    例如变量被声明了，但没有赋值时，就等于undefined\n```\n```\ntypeof null  //\"object\"\n    null : 是一个对象(空对象, 没有任何属性和方法)；\n    例如作为函数的参数，表示该函数的参数不是对象；\n```\n注意：\n    在验证null时，一定要使用　=== ，因为 == 无法分别 null 和　undefined\n\n再来一个例子：\n  null\n  Q：有张三这个人么？\n  A：有！\n  Q：张三有房子么？\n  A：没有！\n\n  undefined\n  Q：有张三这个人么？\n  A：没有！ \n> 参考阅读：[undefined与null的区别](http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html)\n\n\n-  写一个通用的事件侦听器函数。\n```\n// event(事件)工具集，来源：github.com/markyun\nmarkyun.Event = {\n    // 页面加载完成后\n    readyEvent : function(fn) {\n        if (fn==null) {\n            fn=document;\n        }\n        var oldonload = window.onload;\n        if (typeof window.onload != 'function') {\n            window.onload = fn;\n        } else {\n            window.onload = function() {\n                oldonload();\n                fn();\n            };\n        }\n    },\n    // 视能力分别使用dom0||dom2||IE方式 来绑定事件\n    // 参数： 操作的元素,事件名称 ,事件处理程序\n    addEvent : function(element, type, handler) {\n        if (element.addEventListener) {\n            //事件类型、需要执行的函数、是否捕捉\n            element.addEventListener(type, handler, false);\n        } else if (element.attachEvent) {\n            element.attachEvent('on' + type, function() {\n                handler.call(element);\n            });\n        } else {\n            element['on' + type] = handler;\n        }\n    },\n    // 移除事件\n    removeEvent : function(element, type, handler) {\n        if (element.removeEventListener) {\n            element.removeEventListener(type, handler, false);\n        } else if (element.datachEvent) {\n            element.detachEvent('on' + type, handler);\n        } else {\n            element['on' + type] = null;\n        }\n    },\n    // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)\n    stopPropagation : function(ev) {\n        if (ev.stopPropagation) {\n            ev.stopPropagation();\n        } else {\n            ev.cancelBubble = true;\n        }\n    },\n    // 取消事件的默认行为\n    preventDefault : function(event) {\n        if (event.preventDefault) {\n            event.preventDefault();\n        } else {\n            event.returnValue = false;\n        }\n    },\n    // 获取事件目标\n    getTarget : function(event) {\n        return event.target || event.srcElement;\n    },\n    // 获取event对象的引用，取到事件的所有信息，确保随时能使用event；\n    getEvent : function(e) {\n        var ev = e || window.event;\n        if (!ev) {\n            var c = this.getEvent.caller;\n            while (c) {\n                ev = c.arguments[0];\n                if (ev && Event == ev.constructor) {\n                    break;\n                }\n                c = c.caller;\n            }\n        }\n        return ev;\n    }\n};\n```\n\n-  [\"1\", \"2\", \"3\"].map(parseInt) 答案是多少？\n```\n [1, NaN, NaN] 因为 parseInt 需要两个参数 (val, radix)，\n 其中 radix 表示解析时用的基数。\n map 传了 3 个 (element, index, array)，对应的 radix 不合法导致解析失败。\n```\n\n-  事件是？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？\n```\n 1. 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。\n 2. 事件处理机制：IE是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件；\n 3. ev.stopPropagation();（旧ie的方法 ev.cancelBubble = true;）\n```\n\n-  什么是闭包（closure），为什么要用它？\n```\n闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。\n\n闭包的特性：\n\n1.函数内再嵌套函数\n2.内部函数可以引用外层的参数和变量\n3.参数和变量不会被垃圾回收机制回收\n\n//li节点的onclick事件都能正确的弹出当前被点击的li索引\n <ul id=\"testUL\">\n    <li> index = 0</li>\n    <li> index = 1</li>\n    <li> index = 2</li>\n    <li> index = 3</li>\n</ul>\n<script type=\"text/javascript\">\n    var nodes = document.getElementsByTagName(\"li\");\n    for(i = 0;i<nodes.length;i+= 1){\n        nodes[i].onclick = function(){\n            console.log(i+1);//不用闭包的话，值每次都是4\n        }(i);\n    }\n</script>\n\n\n执行say667()后,say667()闭包内部变量会存在,而闭包内部函数的内部变量不会存在\n使得Javascript的垃圾回收机制GC不会收回say667()所占用的资源\n因为say667()的内部函数的执行需要依赖say667()中的变量\n这是对闭包作用的非常直白的描述\n\n  function say667() {\n    // Local variable that ends up within closure\n    var num = 666;\n    var sayAlert = function() {\n        alert(num);\n    }\n    num++;\n    return sayAlert;\n}\n\n var sayAlert = say667();\n sayAlert()//执行结果应该弹出的667\n```\n\n-  javascript 代码中的\"use strict\";是什么意思 ? 使用它区别是什么？\n```\nuse strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,\n\n使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。\n默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值;\n全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数,arguments.callee也不允许使用；\n消除代码运行的一些不安全之处，保证代码运行的安全,限制函数中的arguments修改，严格模式下的eval函数的行为和非严格模式的也不相同;\n\n提高编译器效率，增加运行速度；\n为未来新版本的Javascript标准化做铺垫。\n```\n\n-  如何判断一个对象是否属于某个类？\n```\n使用instanceof （待完善）\n if(a instanceof Person){\n     alert('yes');\n }\n```\n\n-  new操作符具体干了什么呢?\n```\n   1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。\n   2、属性和方法被加入到 this 引用的对象中。\n   3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。\n\nvar obj  = {};\nobj.__proto__ = Base.prototype;\nBase.call(obj);\n```\n\n-  用原生JavaScript的实现过什么功能吗？\n\n\n-  Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？\n```\nhasOwnProperty\n\njavaScript中hasOwnProperty函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员。\n使用方法：\nobject.hasOwnProperty(proName)\n其中参数object是必选项。一个对象的实例。\nproName是必选项。一个属性名称的字符串值。\n\n如果 object 具有指定名称的属性，那么JavaScript中hasOwnProperty函数方法返回 true，反之则返回 false。\n```\n\n-  JSON 的了解？\n```\nJSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。\n它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小\n如：{\"age\":\"12\", \"name\":\"back\"}\n\nJSON字符串转换为JSON对象:\nvar obj =eval('('+ str +')');\nvar obj = str.parseJSON();\nvar obj = JSON.parse(str);\n\nJSON对象转换为JSON字符串：\nvar last=obj.toJSONString();\nvar last=JSON.stringify(obj);\n```\n\n-  `[].forEach.call($$(\"*\"),function(a){a.style.outline=\"1px solid #\"+(~~(Math.random()*(1<<24))).toString(16)})` 能解释一下这段代码的意思吗？\n\n\n-  js延迟加载的方式有哪些？\n```\ndefer和async、动态创建DOM方式（用得最多）、按需异步载入js\n```\n\n-  Ajax 是什么? 如何创建一个Ajax？\n```\najax的全称：Asynchronous Javascript And XML。\n异步传输+js+xml。\n所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。\n\n(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象\n(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息\n(3)设置响应HTTP请求状态变化的函数\n(4)发送HTTP请求\n(5)获取异步调用返回的数据\n(6)使用JavaScript和DOM实现局部刷新\n```\n\n-  同步和异步的区别?\n```\n  同步的概念应该是来自于OS中关于同步的概念:不同进程为协同完成某项工作而在先后次序上调整(通过阻塞,唤醒等方式).同步强调的是顺序性.谁先谁后.异步则不存在这种顺序性.\n    \n  \n  同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作。\n\n  异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。\n  \n  （待完善）\n```\n\n-  如何解决跨域问题?\n```\njsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面\n```\n\n-  页面编码和被请求的资源编码如果不一致如何处理？\n\n-  模块化开发怎么做？\n```\n[ 立即执行函数](http://benalman.com/news/2010/11/immediately-invoked-function-expression/),不暴露私有成员\n\nvar module1 = (function(){\n　　　　var _count = 0;\n　　　　var m1 = function(){\n　　　　　　//...\n　　　　};\n　　　　var m2 = function(){\n　　　　　　//...\n　　　　};\n　　　　return {\n　　　　　　m1 : m1,\n　　　　　　m2 : m2\n　　　　};\n　　})();\n\n（待完善）\n```\n\n-  AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？\n```\n> AMD 规范在这里：https://github.com/amdjs/amdjs-api/wiki/AMD\n\n> CMD 规范在这里：https://github.com/seajs/seajs/issues/242\n\nAsynchronous Module Definition，异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中。\n\n 区别：\n\n    1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.\n    2. CMD 推崇依赖就近，AMD 推崇依赖前置。看代码：\n\n// CMD\ndefine(function(require, exports, module) {\n    var a = require('./a')\n    a.doSomething()\n    // 此处略去 100 行\n    var b = require('./b') // 依赖可以就近书写\n    b.doSomething()\n    // ...\n})\n\n// AMD 默认推荐\ndefine(['./a', './b'], function(a, b) { // 依赖必须一开始就写好\n    a.doSomething()\n    // 此处略去 100 行\n    b.doSomething()\n    // ...\n})\n```\n\n-  requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何\n缓存的？）\n\n-  谈一谈你对ECMAScript6的了解？\n\n-  ECMAScript6 怎么写class么，为什么会出现class这种东西? \n\n-  异步加载JS的方式有哪些？\n```\n(1) defer，只支持IE\n\n(2) async：\n\n(3) 创建script，插入到DOM中，加载完毕后callBack\n```\n- documen.write和 innerHTML的区别\n```\ndocument.write只能重绘整个页面\n\ninnerHTML可以重绘页面的一部分\n```\n- DOM操作——怎样添加、移除、移动、复制、创建和查找节点?\n```\n（1）创建新节点\ncreateDocumentFragment()    //创建一个DOM片段\ncreateElement()   //创建一个具体的元素\ncreateTextNode()   //创建一个文本节点\n（2）添加、移除、替换、插入\nappendChild()\nremoveChild()\nreplaceChild()\ninsertBefore() //在已有的子节点前插入一个新的子节点\n（3）查找\ngetElementsByTagName()    //通过标签名称\ngetElementsByName()    //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)\ngetElementById()    //通过元素Id，唯一性\n```\n-  .call() 和 .apply() 的区别？\n```\n例子中用 add 来替换 sub，add.call(sub,3,1) == add(3,1) ，所以运行结果为：alert(4);\n\n注意：js 中的函数其实是对象，函数名是对 Function 对象的引用。\n\n  function add(a,b)\n  {\n      alert(a+b);\n  }\n\n  function sub(a,b)\n  {\n      alert(a-b);\n  }\n\n  add.call(sub,3,1);\n```\n\n-  数组和对象有哪些原生方法，列举一下？\n\n-  JS 怎么实现一个类。怎么实例化这个类\n\n-  JavaScript中的作用域与变量声明提升？\n\n-  如何编写高性能的Javascript？\n\n-  那些操作会造成内存泄漏？\n\n-  JQuery的源码看过吗？能不能简单概况一下它的实现原理？\n\n-  jQuery.fn的init方法返回的this指的是什么对象？为什么要返回this？\n\n-  jquery中如何将数组转化为json字符串，然后再转化回来？\n\n-  jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？ \n\n-  jquery.extend 与 jquery.fn.extend的区别？\n\n-  jQuery 的队列是如何实现的？队列可以用在哪些地方？\n\n-  谈一下Jquery中的bind(),live(),delegate(),on()的区别？\n\n-  JQuery一个对象可以同时绑定多个事件，这是如何实现的？\n\n-  是否知道自定义事件。jQuery里的fire函数是什么意思，什么时候用？\n\n-  jQuery 是通过哪个方法和 Sizzle 选择器结合的？（jQuery.fn.find()进入Sizzle）\n\n-  针对 jQuery性能的优化方法？\n\n-  Jquery与jQuery UI 有啥区别？\n```\n*jQuery是一个js库，主要提供的功能是选择器，属性修改和事件绑定等等。\n\n*jQuery UI则是在jQuery的基础上，利用jQuery的扩展性，设计的插件。\n 提供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等\n```\n\n-  JQuery的源码看过吗？能不能简单说一下它的实现原理？\n\n-  jquery 中如何将数组转化为json字符串，然后再转化回来？\n```\njQuery中没有提供这个功能，所以你需要先编写两个jQuery的扩展：\n\n$.fn.stringifyArray = function(array) {\n    return JSON.stringify(array)\n}\n\n$.fn.parseArray = function(array) {\n    return JSON.parse(array)\n}\n\n然后调用：\n$(\"\").stringifyArray(array)\n```\n\n-  jQuery和Zepto的区别？各自的使用场景？\n\n-  针对 jQuery 的优化方法？\n```\n*基于Class的选择性的性能相对于Id选择器开销很大，因为需遍历所有DOM元素。\n\n*频繁操作的DOM，先缓存起来再操作。用Jquery的链式调用更好。\n 比如：var str=$(\"a\").attr(\"href\");\n\n*for (var i = size; i < arr.length; i++) {}\n for 循环每一次循环都查找了数组 (arr) 的.length 属性，在开始循环的时候设置一个变量来存储这个数字，可以让循环跑得更快：\n for (var i = size, length = arr.length; i < length; i++) {}\n```\n\n-  Zepto的点透问题如何解决？\n\n-  jQueryUI如何自定义组件?\n\n-  需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？\n\n- 如何判断当前脚本运行在浏览器还是node环境中？（阿里）\n```\n通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中\n```\n-  移动端最小触控区域是多大？\n\n-  jQuery 的 slideUp动画 ，如果目标元素是被外部事件驱动, 当鼠标快速地连续触发外部元素事件, 动画会滞后的反复执行，该如何处理呢?\n\n-  把 Script 标签 放在页面的最底部的body封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？\n\n-  移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？（click 有 300ms 延迟,为了实现safari的双击事件的设计，浏览器要知道你是不是要双击操作。）\n\n-  知道各种JS框架(Angular, Backbone, Ember, React, Meteor, Knockout...)么? 能讲出他们各自的优点和缺点么?\n\n-  Underscore 对哪些 JS 原生对象进行了扩展以及提供了哪些好用的函数方法？\n\n-  解释JavaScript中的作用域与变量声明提升？\n\n-  那些操作会造成内存泄漏？\n```\n内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。\n垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。\n\nsetTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。\n闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）\n```\n\n-  JQuery一个对象可以同时绑定多个事件，这是如何实现的？\n\n-  Node.js的适用场景？\n\n-  (如果会用node)知道route, middleware, cluster, nodemon, pm2, server-side rendering么?\n\n-  解释一下 Backbone 的 MVC 实现方式？\n\n- 什么是“前端路由”?什么时候适合使用“前端路由”? “前端路由”有哪些优点和缺点?\n\n- 知道什么是webkit么? 知道怎么用浏览器的各种工具来调试和debug代码么?\n\n- 如何测试前端代码么? 知道BDD, TDD, Unit Test么? 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)?\n\n- 前端templating(Mustache, underscore, handlebars)是干嘛的, 怎么用?\n\n- 简述一下 Handlebars 的基本用法？\n\n- 简述一下 Handlerbars 的对模板的基本处理流程， 如何编译的？如何缓存的？\n\n- 用js实现千位分隔符?(来源：[前端农民工](http://div.io/topic/744)，提示：正则+replace)\n```\nfunction commafy(num) {\n     num = num + '';\n     var reg = /(-?d+)(d{3})/;\n    \n    if(reg.test(num)){\n     num = num.replace(reg, '$1,$2');\n    }\n    return num;\n}\n```\n    \n- 检测浏览器版本版本有哪些方式？\n```\n功能检测、userAgent特征检测\n\n比如：navigator.userAgent\n//\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36\n  (KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36\"\n```\n\n- What is a Polyfill? \n```\npolyfill 是“在旧版浏览器上复制标准 API 的 JavaScript 补充”,可以动态地加载 JavaScript 代码或库，在不支持这些标准 API 的浏览器中模拟它们。\n例如，geolocation（地理位置）polyfill 可以在 navigator 对象上添加全局的 geolocation 对象，还能添加 getCurrentPosition 函数以及“坐标”回调对象，\n所有这些都是 W3C 地理位置 API 定义的对象和函数。因为 polyfill 模拟标准 API，所以能够以一种面向所有浏览器未来的方式针对这些 API 进行开发，\n一旦对这些 API 的支持变成绝对大多数，则可以方便地去掉 polyfill，无需做任何额外工作。\n```\n\n- 做的项目中，有没有用过或自己实现一些 polyfill 方案（兼容性处理方案）？\n```\n比如： html5shiv、Geolocation、Placeholder \n```\n\n- 我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？\n\n\n#### <a name='other'>ECMAScript6 相关</a>\n\n- Object.is() 与原来的比较操作符“ ===”、“ ==”的区别？ \n```\n两等号判等，会在比较时进行类型转换；\n三等号判等(判断严格)，比较时不进行隐式类型转换,（类型不同则会返回false）； \n\nObject.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，\n但 Object.is(NaN, NaN) 会返回 true.\n\nObject.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。\n```\n\n#### <a name='other'>前端框架相关</a>\n\n- react-router 路由系统的实现原理？\n\n- React中如何解决第三方类库的问题?\n\n\n## <a name='other'>其他问题</a>\n\n- 原来公司工作流程是怎么样的，如何与其他人协作的？如何夸部门合作的？\n\n- 你遇到过比较难的技术问题是？你是如何解决的？\n\n- 设计模式 知道什么是singleton, factory, strategy, decrator么?\n\n- 常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？\n\n- 页面重构怎么操作？\n```\n网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。\n也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。\n\n对于传统的网站来说重构通常是：\n\n表格(table)布局改为DIV+CSS\n使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)\n对于移动平台的优化\n针对于SEO进行优化\n深层次的网站重构应该考虑的方面\n\n减少代码间的耦合\n让代码保持弹性\n严格按规范编写代码\n设计可扩展的API\n代替旧有的框架、语言(如VB)\n增强用户体验\n通常来说对于速度的优化也包含在重构中\n\n压缩JS、CSS、image等前端资源(通常是由服务器来解决)\n程序的性能优化(如数据读写)\n采用CDN来加速资源加载\n对于JS DOM的优化\nHTTP服务器的文件缓存\n```\n- 列举IE与其他浏览器不一样的特性？\n```\n1、事件不同之处：\n\n触发事件的元素被认为是目标（target）。而在 IE 中，目标包含在 event 对象的 srcElement 属性；\n\n获取字符代码、如果按键代表一个字符（shift、ctrl、alt除外），IE 的 keyCode 会返回字符代码（Unicode），DOM 中按键的代码和字符是分离的，要获取字符代码，需要使用 charCode 属性；\n\n阻止某个事件的默认行为，IE 中阻止某个事件的默认行为，必须将 returnValue 属性设置为 false，Mozilla 中，需要调用 preventDefault() 方法；\n\n停止事件冒泡，IE 中阻止事件进一步冒泡，需要设置 cancelBubble 为 true，Mozzilla 中，需要调用 stopPropagation()；\n```\n\n- 99%的网站都需要被重构是那本书上写的？\n```\n网站重构：应用web标准进行设计（第2版）\n```\n- 什么叫优雅降级和渐进增强？\n```\n优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。\n如：border-shadow\n\n渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。\n如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验；\n```\n- 是否了解公钥加密和私钥加密。\n```\n一般情况下是指私钥用于对数据进行签名，公钥用于对签名进行验证;\nHTTP网站在浏览器端用公钥加密敏感数据，然后在服务器端再用私钥解密。\n```\n\n- WEB应用从服务器主动推送Data到客户端有那些方式？\n```\nhtml5提供的Websocket\n不可见的iframe\nWebSocket通过Flash\nXHR长时间连接\nXHR Multipart Streaming\n<script>标签的长时间连接(可跨域)\n```\n- 对Node的优点和缺点提出了自己的看法？\n```\n*（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，\n  因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。\n  此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，\n  因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。\n\n*（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，\n  而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。\n```\n\n- 你有用过哪些前端性能优化的方法？\n```\n（1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。\n\n（2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数\n\n（3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。\n\n（4） 当需要设置的样式很多时设置className而不是直接操作style。\n\n（5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。\n\n（6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。\n\n（7） 图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。\n\n（8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。\n对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。\n```\n\n- http状态码有那些？分别代表是什么意思？\n```\n简单版\n[\n    100  Continue   继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息\n    200  OK         正常返回信息\n    201  Created    请求成功并且服务器创建了新的资源\n    202  Accepted   服务器已接受请求，但尚未处理\n    301  Moved Permanently  请求的网页已永久移动到新位置。\n    302 Found       临时性重定向。\n    303 See Other   临时性重定向，且总是使用 GET 请求新的 URI。\n    304  Not Modified 自从上次请求后，请求的网页未修改过。\n\n    400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。\n    401 Unauthorized 请求未授权。\n    403 Forbidden   禁止访问。\n    404 Not Found   找不到如何与 URI 相匹配的资源。\n\n    500 Internal Server Error  最常见的服务器端错误。\n    503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。\n]\n\n完整版\n1**(信息类)：表示接收到请求并且继续处理\n100——客户必须继续发出请求\n101——客户要求服务器根据请求转换HTTP协议版本\n\n2**(响应成功)：表示动作被成功接收、理解和接受\n200——表明该请求被成功地完成，所请求的资源发送回客户端\n201——提示知道新文件的URL\n202——接受和处理、但处理未完成\n203——返回信息不确定或不完整\n204——请求收到，但返回信息为空\n205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件\n206——服务器已经完成了部分用户的GET请求\n\n3**(重定向类)：为了完成指定的动作，必须接受进一步处理\n300——请求的资源可在多处得到\n301——本网页被永久性转移到另一个URL\n302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。\n303——建议客户访问其他URL或访问方式\n304——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用\n305——请求的资源必须从服务器指定的地址得到\n306——前一版本HTTP中使用的代码，现行版本中不再使用\n307——申明请求的资源临时性删除\n\n4**(客户端错误类)：请求包含错误语法或不能正确执行\n400——客户端请求有语法错误，不能被服务器所理解\n401——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用\nHTTP 401.1 - 未授权：登录失败\n　　HTTP 401.2 - 未授权：服务器配置问题导致登录失败\n　　HTTP 401.3 - ACL 禁止访问资源\n　　HTTP 401.4 - 未授权：授权被筛选器拒绝\nHTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败\n402——保留有效ChargeTo头响应\n403——禁止访问，服务器收到请求，但是拒绝提供服务\nHTTP 403.1 禁止访问：禁止可执行访问\n　　HTTP 403.2 - 禁止访问：禁止读访问\n　　HTTP 403.3 - 禁止访问：禁止写访问\n　　HTTP 403.4 - 禁止访问：要求 SSL\n　　HTTP 403.5 - 禁止访问：要求 SSL 128\n　　HTTP 403.6 - 禁止访问：IP 地址被拒绝\n　　HTTP 403.7 - 禁止访问：要求客户证书\n　　HTTP 403.8 - 禁止访问：禁止站点访问\n　　HTTP 403.9 - 禁止访问：连接的用户过多\n　　HTTP 403.10 - 禁止访问：配置无效\n　　HTTP 403.11 - 禁止访问：密码更改\n　　HTTP 403.12 - 禁止访问：映射器拒绝访问\n　　HTTP 403.13 - 禁止访问：客户证书已被吊销\n　　HTTP 403.15 - 禁止访问：客户访问许可过多\n　　HTTP 403.16 - 禁止访问：客户证书不可信或者无效\nHTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效\n404——一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL\n405——用户在Request-Line字段定义的方法不允许\n406——根据用户发送的Accept拖，请求资源不可访问\n407——类似401，用户必须首先在代理服务器上得到授权\n408——客户端没有在用户指定的饿时间内完成请求\n409——对当前资源状态，请求不能完成\n410——服务器上不再有此资源且无进一步的参考地址\n411——服务器拒绝用户定义的Content-Length属性请求\n412——一个或多个请求头字段在当前请求中错误\n413——请求的资源大于服务器允许的大小\n414——请求的资源URL长于服务器允许的长度\n415——请求资源不支持请求项目格式\n416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段\n417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。\n\n5**(服务端错误类)：服务器不能正确执行一个正确的请求\nHTTP 500 - 服务器遇到错误，无法完成请求\n　　HTTP 500.100 - 内部服务器错误 - ASP 错误\n　　HTTP 500-11 服务器关闭\n　　HTTP 500-12 应用程序重新启动\n　　HTTP 500-13 - 服务器太忙\n　　HTTP 500-14 - 应用程序无效\n　　HTTP 500-15 - 不允许请求 global.asa\n　　Error 501 - 未实现\nHTTP 502 - 网关错误\nHTTP 503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常\n\n- 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）\n\n注：这题胜在区分度高，知识点覆盖广，再不懂的人，也能答出几句，\n而高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、\n到浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JS API绑定等等；\n\n详细版：\n1、浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;\n2、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;\n3、通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;\n4、进行HTTP协议会话，客户端发送报头(请求报头);\n5、进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;\n6、进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;\n7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;\n8、浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;\n9、文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;\n10、页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。\n\n简洁版：\n浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；\n服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；\n浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；\n载入解析到的资源文件，渲染页面，完成。\n```\n\n- 部分地区用户反应网站很卡，请问有哪些可能性的原因，以及解决方法？\n\n- 从打开app到刷新出内容，整个过程中都发生了什么，如果感觉慢，怎么定位问题，怎么解决?\n\n- 除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？\n\n- 你用的得心应手用的熟练地编辑器&开发环境是什么样子？\n```\nSublime Text 3 + 相关插件编写前端代码\nGoogle chrome 、Mozilla Firefox浏览器 +firebug 兼容测试和预览页面UI、动画效果和交互功能\nNode.js+Gulp\ngit 用于版本控制和Code Review\n```\n\n- 对前端工程师这个职位是怎么样理解的？它的前景会怎么样？\n```\n前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。\n1、实现界面交互\n2、提升用户体验\n3、有了Node.js，前端可以实现服务端的一些事情\n\n前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，\n\n参与项目，快速高质量完成实现效果图，精确到1px；\n\n与团队成员，UI设计，产品经理的沟通；\n\n做好的页面结构，页面重构和用户体验；\n\n处理hack，兼容、写出优美的代码格式；\n\n针对服务器的优化、拥抱最新前端技术。\n```\n\n- 你怎么看待Web App 、hybrid App、Native App？\n\n- 你移动端前端开发的理解？（和 Web 前端开发的主要区别是什么？）\n\n- 你对加班的看法？\n```\n加班就像借钱，原则应当是------救急不救穷\n```\n\n- 平时如何管理你的项目？\n```\n先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等；\n\n编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；\n\n标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；\n\n页面进行标注（例如 页面 模块 开始和结束）；\n\nCSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）；\n\nJS 分文件夹存放 命名以该JS功能为准的英文翻译。\n\n图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理\n```\n\n- 如何设计突发大规模并发架构？\n\n- 当团队人手不足，把功能代码写完已经需要加班的情况下，你会做前端代码的测试吗？\n\n- 说说最近最流行的一些东西吧？常去哪些网站？\n```\nES6\\WebAssembly\\Node\\MVVM\\Web Components\\React\\React Native\\Webpack 组件化\n```\n\n- 知道什么是SEO并且怎么优化么? 知道各种meta data的含义么?\n\n- 移动端（Android IOS）怎么做好用户体验?\n```\n清晰的视觉纵线、\n信息的分组、极致的减法、\n利用选择代替输入、\n标签及文字的排布方式、\n依靠明文确认密码、\n合理的键盘利用、\n```\n\n- 简单描述一下你做过的移动APP项目研发流程？\n\n- 你在现在的团队处于什么样的角色，起到了什么明显的作用？\n\n- 你认为怎样才是全端工程师（Full Stack developer）？\n\n- 介绍一个你最得意的作品吧？\n\n- 你有自己的技术博客吗，用了哪些技术？\n\n- 对前端安全有什么看法？\n\n- 是否了解Web注入攻击，说下原理，最常见的两种攻击（XSS 和 CSRF）了解到什么程度？\n\n- 项目中遇到国哪些印象深刻的技术难题，具体是什么问题，怎么解决？。\n\n- 最近在学什么东西？\n\n- 你的优点是什么？缺点是什么？\n\n- 如何管理前端团队?\n\n- 最近在学什么？能谈谈你未来3，5年给自己的规划吗？\n\n\n## <a name='web'>前端学习网站推荐</a>\n\n[极客标签](http://www.gbtags.com/)  \n[码农周刊](http://weekly.manong.io/issues/)\n[前端周刊](http://www.feweekly.com/issues)\n[慕课网](http://www.imooc.com/)\n[div.io](http://div.io)\n[Hacker News](https://news.ycombinator.com/news)\n[InfoQ](http://www.infoq.com/)\n[w3cplus](http://www.w3cplus.com/)\n[Stack Overflow](http://stackoverflow.com/)\n[w3school](http://www.w3school.com.cn/)\n[mozilla](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript)\n\n\n\n## <a name='web'>文档推荐</a>\n\n1. [jQuery 基本原理](http://docs.huihoo.com/jquery/jquery-fundamentals/zh-cn/index.html \"jQuery 基本原理\")\n\n2. [JavaScript 秘密花园](http://bonsaiden.github.io/JavaScript-Garden/zh/)\n\n3. [CSS参考手册](http://css.doyoe.com/)\n\n4. [JavaScript 标准参考教程](http://javascript.ruanyifeng.com/)\n\n5. [ECMAScript 6入门](http://es6.ruanyifeng.com/)","source":"_posts/前端开发面试题.md","raw":"---\ntitle: 前端开发面试题\ndate: 2016-08-30 10:06:16\ntags: 面试\ncategory: 前端\n---\n本文收集总结了一些前端面试题，初学者阅后也要用心钻研其中的原理，重要知识需要系统学习、透彻学习，形成自己的知识链。万不可投机取巧，临时抱佛脚只求面试侥幸混过关是错误的！也是不可能的！不可能的！不可能的！\n<!--more-->\n## <a name='preface'>前言</a> ##\n前端还是一个年轻的行业，新的行业标准， 框架， 库都不断在更新和新增，正如赫门在2015深JS大会上的《前端服务化之路》主题演讲中说的一句话：“每18至24个月，前端都会难一倍”，这些变化使前端的能力更加丰富、创造的应用也会更加完美。所以关注各种前端技术，跟上快速变化的节奏，也是身为一个前端程序员必备的技能之一。\n\n**面试有几点需注意：**\n来源[寒冬winter](http://weibo.com/wintercn \"微博：寒冬winter\") 老师，github:@wintercn\n1. 面试题目： 根据你的等级和职位的变化，入门级到专家级，广度和深度都会有所增加。\n\n1. 题目类型： 理论知识、算法、项目细节、技术视野、开放性题、工作案例。\n\n1. 细节追问： 可以确保问到你开始不懂或面试官开始不懂为止，这样可以大大延展题目的区分度和深度，知道你的实际能力。因为这种知识关联是长时期的学习，临时抱佛脚绝对是记不住的。\n\n1. 回答问题再棒，面试官（可能是你面试职位的直接领导），会考虑我要不要这个人做我的同事？所以态度很重要、除了能做事，还要会做人。（感觉更像是相亲）\n\n1. 资深的前端开发能把absolute和relative弄混，这样的人不要也罢，因为团队需要的是：你这个人具有可以依靠的才能（靠谱）。\n\n\n**前端开发知识点：**\n```\nHTML&CSS：\n    对Web标准的理解、浏览器内核差异、兼容性、hack、CSS基本功：布局、盒子模型、选择器优先级、\n    HTML5、CSS3、Flexbox\n\nJavaScript：\n    数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、RegExp、JSON、Ajax、\n    DOM、BOM、内存泄漏、跨域、异步装载、模板引擎、前端MVC、路由、模块化、Canvas、ECMAScript 6、Nodejs\n\n其他：\n    移动端、响应式、自动化构建、HTTP、离线存储、WEB安全、优化、重构、团队协作、可维护、易用性、SEO、UED、架构、职业生涯、快速学习能力\n```\n作为一名前端工程师，**无论工作年头长短都应该掌握的知识点**：\n此条由 王子墨 发表在 [攻城师的实验室](http://lab.yuanwai.wang/)\n```\n1、DOM结构 —— 两个节点之间可能存在哪些关系以及如何在节点之间任意移动。\n\n2、DOM操作 —— 如何添加、移除、移动、复制、创建和查找节点等。\n\n3、事件 —— 如何使用事件，以及IE和标准DOM事件模型之间存在的差别。\n\n4、XMLHttpRequest —— 这是什么、怎样完整地执行一次GET请求、怎样检测错误。\n\n5、严格模式与混杂模式 —— 如何触发这两种模式，区分它们有何意义。\n\n6、盒模型 —— 外边距、内边距和边框之间的关系，及IE8以下版本的浏览器中的盒模型\n\n7、块级元素与行内元素 —— 怎么用CSS控制它们、以及如何合理的使用它们\n\n8、浮动元素 —— 怎么使用它们、它们有什么问题以及怎么解决这些问题。\n\n9、HTML与XHTML —— 二者有什么区别，你觉得应该使用哪一个并说出理由。\n\n10、JSON —— 作用、用途、设计结构。\n```\n**备注：**\n> 根据自己需要选择性阅读，面试题是对理论知识的总结，让自己学会应该如何表达。\n资料答案不够正确和全面，欢迎欢迎Star和提交issues。\n格式不断修改更新中。\n更新记录：\n2016年3月25日：新增ECMAScript6 相关问题\n\n\n###更新时间:  2016-3-25\n\n## <a name='html'>HTML</a>\n- Doctype作用？标准模式与兼容模式各有什么区别?\n```\n（1）、<!DOCTYPE>声明位于位于HTML文档中的第一行，处于 <html> 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。\n\n（2）、标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。\n```\n\n- HTML5 为什么只需要写 <!DOCTYPE HTML>？\n```\n HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；\n\n 而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。\n```\n\n- 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？\n```\n首先：CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。\n\n（1）行内元素有：a b span img input select strong（强调的语气）\n（2）块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p\n\n（3）常见的空元素：\n    <br> <hr> <img> <input> <link> <meta>\n    鲜为人知的是：\n    <area> <base> <col> <command> <embed> <keygen> <param> <source> <track> <wbr>\n```\n\n- 页面导入样式时，使用link和@import有什么区别？\n```\n（1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;\n\n（2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;\n\n（3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题;\n```\n\n- 介绍一下你对浏览器内核的理解？\n```\n主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。\n渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。\n\nJS引擎则：解析和执行javascript来实现网页的动态效果。\n\n最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。\n```\n\n- 常见的浏览器内核有哪些？\n```\nTrident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]\nGecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等\nPresto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]\nWebkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]\n```\n> 详细文章：[浏览器内核的解析和对比](http://www.cnblogs.com/fullhouse/archive/2011/12/19/2293455.html)\n\n- html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和\nHTML5？\n```\n* HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。\n      绘画 canvas;\n      用于媒介回放的 video 和 audio 元素;\n      本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;\n      sessionStorage 的数据在浏览器关闭后自动删除;\n      语意化更好的内容元素，比如 article、footer、header、nav、section;\n      表单控件，calendar、date、time、email、url、search;\n      新的技术webworker, websocket, Geolocation;\n\n  移除的元素：\n      纯表现的元素：basefont，big，center，font, s，strike，tt，u;\n      对可用性产生负面影响的元素：frame，frameset，noframes；\n\n* 支持HTML5新标签：\n     IE8/IE7/IE6支持通过document.createElement方法产生的标签，\n     可以利用这一特性让这些浏览器支持HTML5新标签，\n     浏览器支持新标签后，还需要添加标签默认的样式。\n\n     当然也可以直接使用成熟的框架、比如html5shim;\n     <!--[if lt IE 9]>\n        <script> src=\"http://html5shim.googlecode.com/svn/trunk/html5.js\"</script>\n     <![endif]-->\n\n* 如何区分HTML5： DOCTYPE声明\\新增的结构元素\\功能元素\n```\n\n- 简述一下你对HTML语义化的理解？\n```\n用正确的标签做正确的事情。\nhtml语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;\n即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;\n搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;\n使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。\n```\n\n- HTML5的离线储存怎么使用，工作原理能不能解释一下？\n```\n在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。\n原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。\n\n如何使用：\n1、页面头部像下面一样加入一个manifest的属性；\n2、在cache.manifest文件的编写离线存储的资源；\n    CACHE MANIFEST\n    #v0.11\n    CACHE:\n    js/app.js\n    css/style.css\n    NETWORK:\n    resourse/logo.png\n    FALLBACK:\n    / /offline.html\n3、在离线状态时，操作window.applicationCache进行需求实现。\n\n```\n> 详细的使用请参考：[有趣的HTML5：离线存储](http://segmentfault.com/a/1190000000732617)\n\n\n- 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？\n```\n在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。\n离线的情况下，浏览器就直接使用离线存储的资源。\n```\n> 详细的使用请参考：[有趣的HTML5：离线存储](http://segmentfault.com/a/1190000000732617)\n\n- 请描述一下 cookies，sessionStorage 和 localStorage 的区别？\n```\ncookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。\ncookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。\nsessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。\n\n存储大小：\n    cookie数据大小不能超过4k。\n    sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。\n\n有期时间：\n    localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；\n    sessionStorage  数据在当前浏览器窗口关闭后自动删除。\n    cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭\n```\n\n- iframe有那些缺点？\n```\n*iframe会阻塞主页面的Onload事件；\n*搜索引擎的检索程序无法解读这种页面，不利于SEO;\n\n*iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。\n\n使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript\n动态给iframe添加src属性值，这样可以绕开以上两个问题。\n```\n\n- Label的作用是什么？是怎么用的？\n```\nlabel标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。\n\n<label for=\"Name\">Number:</label>\n<input type=“text“name=\"Name\" id=\"Name\"/>\n\n<label>Date:<input type=\"text\" name=\"B\"/></label>\n```\n\n- HTML5的form如何关闭自动完成功能？\n```\n给不想要提示的 form 或某个 input 设置为 autocomplete=off。\n```\n\n- 如何实现浏览器内多个标签页之间的通信? (阿里)\n```\nWebSocket、SharedWorker；\n也可以调用localstorge、cookies等本地存储方式；\n\nlocalstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，\n我们通过监听事件，控制它的值来进行页面信息通信；\n注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常；\n```\n\n- webSocket如何兼容低浏览器？(阿里)\n```\nAdobe Flash Socket 、\nActiveX HTMLFile (IE) 、\n基于 multipart 编码发送 XHR 、\n基于长轮询的 XHR\n```\n\n- 页面可见性（Page Visibility API） 可以有哪些用途？\n```\n通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;\n在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放；\n```\n\n- 如何在页面上实现一个圆形的可点击区域？\n```\n1、map+area或者svg\n2、border-radius\n3、纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等\n```\n\n- 实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。\n```\n<div style=\"height:1px;overflow:hidden;background:red\"></div>\n```\n\n- 网页验证码是干嘛的，是为了解决什么安全问题。\n```\n区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水；\n有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。\n```\n\n- title与h1的区别、b与strong的区别、i与em的区别？\n```\ntitle属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响；\n\nstrong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：<strong>会重读，而<B>是展示强调内容。\n\ni内容展示为斜体，em表示强调的文本；\n\nPhysical Style Elements -- 自然样式标签\nb, i, u, s, pre\nSemantic Style Elements -- 语义样式标签\nstrong, em, ins, del, code\n应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。\n```\n\n## <a name='css'>CSS</a>\n\n- 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？\n```\n（1）有两种， IE 盒子模型、W3C 盒子模型；\n（2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；\n（3）区  别： IE的content部分把 border 和 padding计算了进去;\n```\n\n- CSS选择符有哪些？哪些属性可以继承？\n```\n*   1.id选择器（ # myid）\n    2.类选择器（.myclassname）\n    3.标签选择器（div, h1, p）\n    4.相邻选择器（h1 + p）\n    5.子选择器（ul > li）\n    6.后代选择器（li a）\n    7.通配符选择器（ * ）\n    8.属性选择器（a[rel = \"external\"]）\n    9.伪类选择器（a:hover, li:nth-child）\n\n*   可继承的样式： font-size font-family color, UL LI DL DD DT;\n\n*   不可继承的样式：border padding margin width height ;\n```\n\n\n- CSS优先级算法如何计算？\n```\n*   优先级就近原则，同权重情况下样式定义最近者为准;\n\n*   载入样式以最后载入的定位为准;\n\n优先级为:\n   !important >  id > class > tag\n    important 比 内联优先级高\n```\n\n- CSS3新增伪类有那些？\n```\n举例：\np:first-of-type 选择属于其父元素的首个 <p> 元素的每个 <p> 元素。\np:last-of-type  选择属于其父元素的最后 <p> 元素的每个 <p> 元素。\np:only-of-type  选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。\np:only-child        选择属于其父元素的唯一子元素的每个 <p> 元素。\np:nth-child(2)  选择属于其父元素的第二个子元素的每个 <p> 元素。\n\n:after          在元素之前添加内容,也可以用来做清除浮动。\n:before         在元素之后添加内容\n:enabled        \n:disabled       控制表单控件的禁用状态。\n:checked        单选框或复选框被选中。\n```\n\n- 如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？\n```\n* 给div设置一个宽度，然后添加margin:0 auto属性\n  div{\n      width:200px;\n      margin:0 auto;\n   }\n\n\n* 居中一个浮动元素\n\n  确定容器的宽高 宽500 高 300 的层设置层的外边距\n .div {\n      width:500px ; height:300px;//高度可以不设\n      margin: -150px 0 0 -250px;\n      position:relative;         //相对定位\n      background-color:pink;     //方便看效果\n      left:50%;\n      top:50%;\n }\n\n* 让绝对定位的div居中\n\n  position: absolute;\n  width: 1200px;\n  background: none;\n  margin: 0 auto;\n  top: 0;\n  left: 0;\n  bottom: 0;\n  right: 0;\n```\n\n- display有哪些值？说明他们的作用。\n```\nblock         象块类型元素一样显示。\nnone          缺省值。象行内元素类型一样显示。\ninline-block  象行内元素一样显示，但其内容象块类型元素一样显示。\nlist-item     象块类型元素一样显示，并添加样式列表标记。\ntable         此元素会作为块级表格来显示\ninherit       规定应该从父元素继承 display 属性的值\n```\n\n- position的值relative和absolute定位原点是？\n```\nabsolute\n  生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。\nfixed （老IE不支持）\n  生成绝对定位的元素，相对于浏览器窗口进行定位。\nrelative\n  生成相对定位的元素，相对于其正常位置进行定位。\nstatic\n  默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。\ninherit\n  规定从父元素继承 position 属性的值。\n```\n\n- CSS3有哪些新特性？\n```\n新增各种CSS选择器    （: not(.input)：所有 class 不是“input”的节点）\n圆角           （border-radius:8px）\n多列布局        （multi-column layout）\n阴影和反射      （Shadow\\Reflect）\n文字特效      （text-shadow、）\n文字渲染      （Text-decoration）\n线性渐变      （gradient）\n旋转          （transform）\n增加了旋转,缩放,定位,倾斜,动画，多背景\ntransform:\\scale(0.85,0.90)\\ translate(0px,-30px)\\ skew(-9deg,0deg)\\Animation:\n```\n\n- 请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？\n```\n...\n```\n\n- 用纯CSS创建一个三角形的原理是什么？\n```\n把上、左、右三条边隐藏掉（颜色设为 transparent）\n#demo {\n  width: 0;\n  height: 0;\n  border-width: 20px;\n  border-style: solid;\n  border-color: transparent transparent red transparent;\n}\n\n```\n\n- 一个满屏 品 字布局 如何设计?\n```\n简单的方式：\n    上面的div宽100%，\n    下面的两个div分别宽50%，\n    然后用float或者inline使其不换行即可\n```\n\n- 经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？\n```\n* png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.\n\n* 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。\n\n* IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。\n\n  浮动ie产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 100px;}\n\n  这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)\n\n  渐进识别的方式，从总体中逐渐排除局部。\n\n  首先，巧妙的使用“\\9”这一标记，将IE游览器从所有情况中分离出来。\n  接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。\n\n  css\n      .bb{\n          background-color:#f1ee18;/*所有识别*/\n          .background-color:#00deff\\9; /*IE6、7、8识别*/\n          +background-color:#a200ff;/*IE6、7识别*/\n          _background-color:#1e0bd1;/*IE6识别*/\n      }\n\n*  IE下,可以使用获取常规属性的方法来获取自定义属性,\n   也可以使用getAttribute()获取自定义属性;\n   Firefox下,只能使用getAttribute()获取自定义属性。\n   解决方法:统一通过getAttribute()获取自定义属性。\n\n*  IE下,even对象有x,y属性,但是没有pageX,pageY属性;\n   Firefox下,event对象有pageX,pageY属性,但是没有x,y属性。\n\n*  解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。\n\n*  Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,\n   可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。\n\n超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:\nL-V-H-A :  a:link {} a:visited {} a:hover {} a:active {}\n```\n\n- li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？\n``` \n行框的排列会受到中间空白（回车\\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。\n```\n\n- 为什么要初始化CSS样式。\n```\n- 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。\n\n- 当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。\n\n最简单的初始化方法： * {padding: 0; margin: 0;} （强烈不建议）\n\n淘宝的样式初始化代码：\nbody, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td { margin:0; padding:0; }\nbody, button, input, select, textarea { font:12px/1.5tahoma, arial, \\5b8b\\4f53; }\nh1, h2, h3, h4, h5, h6{ font-size:100%; }\naddress, cite, dfn, em, var { font-style:normal; }\ncode, kbd, pre, samp { font-family:couriernew, courier, monospace; }\nsmall{ font-size:12px; }\nul, ol { list-style:none; }\na { text-decoration:none; }\na:hover { text-decoration:underline; }\nsup { vertical-align:text-top; }\nsub{ vertical-align:text-bottom; }\nlegend { color:#000; }\nfieldset, img { border:0; }\nbutton, input, select, textarea { font-size:100%; }\ntable { border-collapse:collapse; border-spacing:0; }\n```\n\n- absolute的containing block(容器块)计算方式跟正常流有什么不同？\n```\n无论属于哪种，都要先找到其祖先元素中最近的 position 值不为 static 的元素，然后再判断：\n1、若此元素为 inline 元素，则 containing block 为能够包含这个元素生成的第一个和最后一个 inline box 的 padding box (除 margin, border 外的区域) 的最小矩形；\n2、否则,则由这个祖先元素的 padding box 构成。\n如果都找不到，则为 initial containing block。\n\n补充：\n1. static(默认的)/relative：简单说就是它的父元素的内容框（即去掉padding的部分）\n2. absolute: 向上找最近的定位为absolute/relative的元素\n3. fixed: 它的containing block一律为根元素(html/body)，根元素也是initial containing block\n```\n\n- CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？\n\n- position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？\n\n- 对BFC规范(块级格式化上下文：block formatting context)的理解？\n```\n（W3C CSS 2.1 规范中的一个概念,它是一个独立容器，决定了元素如何对其内容进行定位,以及与其他元素的关系和相互作用。）\n 一个页面是由很多个 Box 组成的,元素的类型和 display 属性,决定了这个 Box 的类型。\n 不同类型的 Box,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响。\n ```\n- css定义的权重\n```\n以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下例子是演示各种定义的权重值：\n\n/*权重为1*/\ndiv{\n}\n/*权重为10*/\n.class1{\n}\n/*权重为100*/\n#id1{\n}\n/*权重为100+1=101*/\n#id1 div{\n}\n/*权重为10+1=11*/\n.class1 div{\n}\n/*权重为10+10+1=21*/\n.class1 .class2 div{\n}\n\n如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现\n```\n\n- 请解释一下为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式\n\n\n- 移动端的布局用过媒体查询吗？\n\n\n- 使用 CSS 预处理器吗？喜欢那个？\n```\nSASS (SASS、LESS没有本质区别，只因为团队前端都是用的SASS)\n```\n\n- CSS优化、提高性能的方法有哪些？\n\n- 浏览器是怎样解析CSS选择器的？\n\n- 在网页中的应该使用奇数还是偶数的字体？为什么呢？\n\n- margin和padding分别适合什么场景使用？\n\n- 抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题]\n\n- 元素竖向的百分比设定是相对于容器的高度吗？\n\n- 全屏滚动的原理是什么？用到了CSS的那些属性？\n\n- 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？\n\n- 视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）\n\n- ::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。\n\n- 如何修改chrome记住密码后自动填充表单的黄色背景 ？\n\n- 你对line-height是如何理解的？\n\n- 设置元素浮动后，该元素的display值是多少？（自动变成display:block）\n\n- 怎么让Chrome支持小于12px 的文字？\n\n- 让页面里的字体变清晰，变细用CSS怎么做？（-webkit-font-smoothing: antialiased;）\n\n- font-style属性可以让它赋值为“oblique” oblique是什么意思？\n\n- position:fixed;在android下无效怎么处理？\n\n- 如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）\n```\n 多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms\n```\n\n- display:inline-block 什么时候会显示间隙？(携程)\n```\n移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing\n```\n- overflow: scroll时不能平滑滚动的问题怎么处理？\n\n- 有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度。\n\n- png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？\n\n\n- 什么是Cookie 隔离？（或者说：请求资源的时候不要让它带cookie怎么做）\n```\n如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，\n所以不如隔离开。\n\n因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，\n这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。\n\n同时这种方式不会将cookie传入Web Server，也减少了Web Server对cookie的处理分析环节，\n提高了webserver的http请求的解析速度。\n```\n\n- style标签写在body后与body前有什么区别？\n\n- 什么是CSS 预处理器 / 后处理器？\n```\n- 预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。\n\n- 后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。\n```\n\n## <a name='js'>JavaScript</a>\n\n-  介绍js的基本数据类型。\n```\n Undefined、Null、Boolean、Number、String、Symbol(new in ECMAScript 2015)\n```\n\n-  介绍js有哪些内置对象？\n```\nObject 是 JavaScript 中所有对象的父对象\n\n数据封装类对象：Object、Array、Boolean、Number 和 String\n其他对象：Function、Arguments、Math、Date、RegExp、Error\n```\n\n-  说几条写JavaScript的基本规范？\n```\n1.不要在同一行声明多个变量。\n2.请使用 ===/!==来比较true/false或者数值\n3.使用对象字面量替代new Array这种形式\n4.不要使用全局函数。\n5.Switch语句必须带有default分支\n6.函数不应该有时候有返回值，有时候没有返回值。\n7.For循环必须使用大括号\n8.If语句必须使用大括号\n9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。\n```\n\n-  JavaScript原型，原型链 ? 有什么特点？\n```\n每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，\n如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，\n于是就这样一直找下去，也就是我们平时所说的原型链的概念。\n关系：instance.constructor.prototype = instance.__proto__\n\n特点：\nJavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。\n\n\n 当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的话，\n 就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。\n    function Func(){}\n    Func.prototype.name = \"Sean\";\n    Func.prototype.getInfo = function() {\n      return this.name;\n    }\n    var person = new Func();//现在可以参考var person = Object.create(oldObject);\n    console.log(person.getInfo());//它拥有了Func的属性和方法\n    //\"Sean\"\n    console.log(Func.prototype);\n    // Func { name=\"Sean\", getInfo=function()}\n```\n\n-  JavaScript有几种类型的值？，你能画一下他们的内存图吗？\n```\n栈：原始数据类型（Undefined，Null，Boolean，Number、String） \n堆：引用数据类型（对象、数组和函数）\n\n两种类型的区别是：存储位置不同；\n原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；\n引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其\n在栈中的地址，取得地址后从堆中获得实体\n```        \n![Stated Clearly Image](http://www.w3school.com.cn/i/ct_js_value.gif)\n\n-  Javascript如何实现继承？\n```\n1、构造继承\n2、原型继承\n3、实例继承\n4、拷贝继承\n\n原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。\n```\n```javascript\nfunction Parent(){\n    this.name = 'wang';\n}\n\nfunction Child(){\n    this.age = 28;\n}\nChild.prototype = new Parent();//继承了Parent，通过原型\n\nvar demo = new Child();\nalert(demo.age);\nalert(demo.name);//得到被继承的属性\n```\n- JavaScript继承的几种实现方式？\n> 参考：[构造函数的继承](http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html)，[非构造函数的继承](http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html)；\n\n-  javascript创建对象的几种方式？\n```\njavascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用。\n\n1、对象字面量的方式   \n\n    person={firstname:\"Mark\",lastname:\"Yun\",age:25,eyecolor:\"black\"};\n\n2、用function来模拟无参的构造函数\n\n    function Person(){}\n    var person=new Person();//定义一个function，如果使用new\"实例化\",该function可以看作是一个Class\n    person.name=\"Mark\";\n    person.age=\"25\";\n    person.work=function(){\n    alert(person.name+\" hello...\");\n    }\n    person.work();\n\n3、用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）\n\n    function Pet(name,age,hobby){\n       this.name=name;//this作用域：当前对象\n       this.age=age;\n       this.hobby=hobby;\n       this.eat=function(){\n          alert(\"我叫\"+this.name+\",我喜欢\"+this.hobby+\",是个程序员\");\n       }\n    }\n    var maidou =new Pet(\"麦兜\",25,\"coding\");//实例化、创建对象\n    maidou.eat();//调用eat方法\n\n\n4、用工厂方式来创建（内置对象）\n\n     var wcDog =new Object();\n     wcDog.name=\"旺财\";\n     wcDog.age=3;\n     wcDog.work=function(){\n       alert(\"我是\"+wcDog.name+\",汪汪汪......\");\n     }\n     wcDog.work();\n\n\n5、用原型方式来创建\n\n    function Dog(){\n    \n     }\n     Dog.prototype.name=\"旺财\";\n     Dog.prototype.eat=function(){\n     alert(this.name+\"是个吃货\");\n     }\n     var wangcai =new Dog();\n     wangcai.eat();\n\n\n5、用混合方式来创建\n\n    function Car(name,price){\n      this.name=name;\n      this.price=price; \n    }\n     Car.prototype.sell=function(){\n       alert(\"我是\"+this.name+\"，我现在卖\"+this.price+\"万元\");\n      }\n    var camry =new Car(\"凯美瑞\",27);\n    camry.sell(); \n```\n\n-  Javascript作用链域?\n```\n全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。\n当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，\n直至全局函数，这种组织形式就是作用域链。\n```\n-  谈谈This对象的理解。\n```\n  * this总是指向函数的直接调用者（而非间接调用者）；\n  * 如果有new关键字，this指向new出来的那个对象；\n  * 在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window；\n```\n\n-  eval是做什么的？\n```\n它的功能是把对应的字符串解析成JS代码并运行；\n应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。\n由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval('('+ str +')');\n```\n\n-  什么是window对象? 什么是document对象?\n\n\n-  null，undefined 的区别？\n```\n// ull，undefined 的区别？\nnull        表示一个对象被定义了，值为“空值”；\nundefined   表示不存在这个值。\n```\n```\ntypeof undefined\n    //\"undefined\"\n    undefined :是一个表示\"无\"的原始值或者说表示\"缺少值\"，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined； \n    例如变量被声明了，但没有赋值时，就等于undefined\n```\n```\ntypeof null  //\"object\"\n    null : 是一个对象(空对象, 没有任何属性和方法)；\n    例如作为函数的参数，表示该函数的参数不是对象；\n```\n注意：\n    在验证null时，一定要使用　=== ，因为 == 无法分别 null 和　undefined\n\n再来一个例子：\n  null\n  Q：有张三这个人么？\n  A：有！\n  Q：张三有房子么？\n  A：没有！\n\n  undefined\n  Q：有张三这个人么？\n  A：没有！ \n> 参考阅读：[undefined与null的区别](http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html)\n\n\n-  写一个通用的事件侦听器函数。\n```\n// event(事件)工具集，来源：github.com/markyun\nmarkyun.Event = {\n    // 页面加载完成后\n    readyEvent : function(fn) {\n        if (fn==null) {\n            fn=document;\n        }\n        var oldonload = window.onload;\n        if (typeof window.onload != 'function') {\n            window.onload = fn;\n        } else {\n            window.onload = function() {\n                oldonload();\n                fn();\n            };\n        }\n    },\n    // 视能力分别使用dom0||dom2||IE方式 来绑定事件\n    // 参数： 操作的元素,事件名称 ,事件处理程序\n    addEvent : function(element, type, handler) {\n        if (element.addEventListener) {\n            //事件类型、需要执行的函数、是否捕捉\n            element.addEventListener(type, handler, false);\n        } else if (element.attachEvent) {\n            element.attachEvent('on' + type, function() {\n                handler.call(element);\n            });\n        } else {\n            element['on' + type] = handler;\n        }\n    },\n    // 移除事件\n    removeEvent : function(element, type, handler) {\n        if (element.removeEventListener) {\n            element.removeEventListener(type, handler, false);\n        } else if (element.datachEvent) {\n            element.detachEvent('on' + type, handler);\n        } else {\n            element['on' + type] = null;\n        }\n    },\n    // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)\n    stopPropagation : function(ev) {\n        if (ev.stopPropagation) {\n            ev.stopPropagation();\n        } else {\n            ev.cancelBubble = true;\n        }\n    },\n    // 取消事件的默认行为\n    preventDefault : function(event) {\n        if (event.preventDefault) {\n            event.preventDefault();\n        } else {\n            event.returnValue = false;\n        }\n    },\n    // 获取事件目标\n    getTarget : function(event) {\n        return event.target || event.srcElement;\n    },\n    // 获取event对象的引用，取到事件的所有信息，确保随时能使用event；\n    getEvent : function(e) {\n        var ev = e || window.event;\n        if (!ev) {\n            var c = this.getEvent.caller;\n            while (c) {\n                ev = c.arguments[0];\n                if (ev && Event == ev.constructor) {\n                    break;\n                }\n                c = c.caller;\n            }\n        }\n        return ev;\n    }\n};\n```\n\n-  [\"1\", \"2\", \"3\"].map(parseInt) 答案是多少？\n```\n [1, NaN, NaN] 因为 parseInt 需要两个参数 (val, radix)，\n 其中 radix 表示解析时用的基数。\n map 传了 3 个 (element, index, array)，对应的 radix 不合法导致解析失败。\n```\n\n-  事件是？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？\n```\n 1. 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。\n 2. 事件处理机制：IE是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件；\n 3. ev.stopPropagation();（旧ie的方法 ev.cancelBubble = true;）\n```\n\n-  什么是闭包（closure），为什么要用它？\n```\n闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。\n\n闭包的特性：\n\n1.函数内再嵌套函数\n2.内部函数可以引用外层的参数和变量\n3.参数和变量不会被垃圾回收机制回收\n\n//li节点的onclick事件都能正确的弹出当前被点击的li索引\n <ul id=\"testUL\">\n    <li> index = 0</li>\n    <li> index = 1</li>\n    <li> index = 2</li>\n    <li> index = 3</li>\n</ul>\n<script type=\"text/javascript\">\n    var nodes = document.getElementsByTagName(\"li\");\n    for(i = 0;i<nodes.length;i+= 1){\n        nodes[i].onclick = function(){\n            console.log(i+1);//不用闭包的话，值每次都是4\n        }(i);\n    }\n</script>\n\n\n执行say667()后,say667()闭包内部变量会存在,而闭包内部函数的内部变量不会存在\n使得Javascript的垃圾回收机制GC不会收回say667()所占用的资源\n因为say667()的内部函数的执行需要依赖say667()中的变量\n这是对闭包作用的非常直白的描述\n\n  function say667() {\n    // Local variable that ends up within closure\n    var num = 666;\n    var sayAlert = function() {\n        alert(num);\n    }\n    num++;\n    return sayAlert;\n}\n\n var sayAlert = say667();\n sayAlert()//执行结果应该弹出的667\n```\n\n-  javascript 代码中的\"use strict\";是什么意思 ? 使用它区别是什么？\n```\nuse strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,\n\n使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。\n默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值;\n全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数,arguments.callee也不允许使用；\n消除代码运行的一些不安全之处，保证代码运行的安全,限制函数中的arguments修改，严格模式下的eval函数的行为和非严格模式的也不相同;\n\n提高编译器效率，增加运行速度；\n为未来新版本的Javascript标准化做铺垫。\n```\n\n-  如何判断一个对象是否属于某个类？\n```\n使用instanceof （待完善）\n if(a instanceof Person){\n     alert('yes');\n }\n```\n\n-  new操作符具体干了什么呢?\n```\n   1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。\n   2、属性和方法被加入到 this 引用的对象中。\n   3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。\n\nvar obj  = {};\nobj.__proto__ = Base.prototype;\nBase.call(obj);\n```\n\n-  用原生JavaScript的实现过什么功能吗？\n\n\n-  Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？\n```\nhasOwnProperty\n\njavaScript中hasOwnProperty函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员。\n使用方法：\nobject.hasOwnProperty(proName)\n其中参数object是必选项。一个对象的实例。\nproName是必选项。一个属性名称的字符串值。\n\n如果 object 具有指定名称的属性，那么JavaScript中hasOwnProperty函数方法返回 true，反之则返回 false。\n```\n\n-  JSON 的了解？\n```\nJSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。\n它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小\n如：{\"age\":\"12\", \"name\":\"back\"}\n\nJSON字符串转换为JSON对象:\nvar obj =eval('('+ str +')');\nvar obj = str.parseJSON();\nvar obj = JSON.parse(str);\n\nJSON对象转换为JSON字符串：\nvar last=obj.toJSONString();\nvar last=JSON.stringify(obj);\n```\n\n-  `[].forEach.call($$(\"*\"),function(a){a.style.outline=\"1px solid #\"+(~~(Math.random()*(1<<24))).toString(16)})` 能解释一下这段代码的意思吗？\n\n\n-  js延迟加载的方式有哪些？\n```\ndefer和async、动态创建DOM方式（用得最多）、按需异步载入js\n```\n\n-  Ajax 是什么? 如何创建一个Ajax？\n```\najax的全称：Asynchronous Javascript And XML。\n异步传输+js+xml。\n所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。\n\n(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象\n(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息\n(3)设置响应HTTP请求状态变化的函数\n(4)发送HTTP请求\n(5)获取异步调用返回的数据\n(6)使用JavaScript和DOM实现局部刷新\n```\n\n-  同步和异步的区别?\n```\n  同步的概念应该是来自于OS中关于同步的概念:不同进程为协同完成某项工作而在先后次序上调整(通过阻塞,唤醒等方式).同步强调的是顺序性.谁先谁后.异步则不存在这种顺序性.\n    \n  \n  同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作。\n\n  异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。\n  \n  （待完善）\n```\n\n-  如何解决跨域问题?\n```\njsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面\n```\n\n-  页面编码和被请求的资源编码如果不一致如何处理？\n\n-  模块化开发怎么做？\n```\n[ 立即执行函数](http://benalman.com/news/2010/11/immediately-invoked-function-expression/),不暴露私有成员\n\nvar module1 = (function(){\n　　　　var _count = 0;\n　　　　var m1 = function(){\n　　　　　　//...\n　　　　};\n　　　　var m2 = function(){\n　　　　　　//...\n　　　　};\n　　　　return {\n　　　　　　m1 : m1,\n　　　　　　m2 : m2\n　　　　};\n　　})();\n\n（待完善）\n```\n\n-  AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？\n```\n> AMD 规范在这里：https://github.com/amdjs/amdjs-api/wiki/AMD\n\n> CMD 规范在这里：https://github.com/seajs/seajs/issues/242\n\nAsynchronous Module Definition，异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中。\n\n 区别：\n\n    1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.\n    2. CMD 推崇依赖就近，AMD 推崇依赖前置。看代码：\n\n// CMD\ndefine(function(require, exports, module) {\n    var a = require('./a')\n    a.doSomething()\n    // 此处略去 100 行\n    var b = require('./b') // 依赖可以就近书写\n    b.doSomething()\n    // ...\n})\n\n// AMD 默认推荐\ndefine(['./a', './b'], function(a, b) { // 依赖必须一开始就写好\n    a.doSomething()\n    // 此处略去 100 行\n    b.doSomething()\n    // ...\n})\n```\n\n-  requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何\n缓存的？）\n\n-  谈一谈你对ECMAScript6的了解？\n\n-  ECMAScript6 怎么写class么，为什么会出现class这种东西? \n\n-  异步加载JS的方式有哪些？\n```\n(1) defer，只支持IE\n\n(2) async：\n\n(3) 创建script，插入到DOM中，加载完毕后callBack\n```\n- documen.write和 innerHTML的区别\n```\ndocument.write只能重绘整个页面\n\ninnerHTML可以重绘页面的一部分\n```\n- DOM操作——怎样添加、移除、移动、复制、创建和查找节点?\n```\n（1）创建新节点\ncreateDocumentFragment()    //创建一个DOM片段\ncreateElement()   //创建一个具体的元素\ncreateTextNode()   //创建一个文本节点\n（2）添加、移除、替换、插入\nappendChild()\nremoveChild()\nreplaceChild()\ninsertBefore() //在已有的子节点前插入一个新的子节点\n（3）查找\ngetElementsByTagName()    //通过标签名称\ngetElementsByName()    //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)\ngetElementById()    //通过元素Id，唯一性\n```\n-  .call() 和 .apply() 的区别？\n```\n例子中用 add 来替换 sub，add.call(sub,3,1) == add(3,1) ，所以运行结果为：alert(4);\n\n注意：js 中的函数其实是对象，函数名是对 Function 对象的引用。\n\n  function add(a,b)\n  {\n      alert(a+b);\n  }\n\n  function sub(a,b)\n  {\n      alert(a-b);\n  }\n\n  add.call(sub,3,1);\n```\n\n-  数组和对象有哪些原生方法，列举一下？\n\n-  JS 怎么实现一个类。怎么实例化这个类\n\n-  JavaScript中的作用域与变量声明提升？\n\n-  如何编写高性能的Javascript？\n\n-  那些操作会造成内存泄漏？\n\n-  JQuery的源码看过吗？能不能简单概况一下它的实现原理？\n\n-  jQuery.fn的init方法返回的this指的是什么对象？为什么要返回this？\n\n-  jquery中如何将数组转化为json字符串，然后再转化回来？\n\n-  jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？ \n\n-  jquery.extend 与 jquery.fn.extend的区别？\n\n-  jQuery 的队列是如何实现的？队列可以用在哪些地方？\n\n-  谈一下Jquery中的bind(),live(),delegate(),on()的区别？\n\n-  JQuery一个对象可以同时绑定多个事件，这是如何实现的？\n\n-  是否知道自定义事件。jQuery里的fire函数是什么意思，什么时候用？\n\n-  jQuery 是通过哪个方法和 Sizzle 选择器结合的？（jQuery.fn.find()进入Sizzle）\n\n-  针对 jQuery性能的优化方法？\n\n-  Jquery与jQuery UI 有啥区别？\n```\n*jQuery是一个js库，主要提供的功能是选择器，属性修改和事件绑定等等。\n\n*jQuery UI则是在jQuery的基础上，利用jQuery的扩展性，设计的插件。\n 提供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等\n```\n\n-  JQuery的源码看过吗？能不能简单说一下它的实现原理？\n\n-  jquery 中如何将数组转化为json字符串，然后再转化回来？\n```\njQuery中没有提供这个功能，所以你需要先编写两个jQuery的扩展：\n\n$.fn.stringifyArray = function(array) {\n    return JSON.stringify(array)\n}\n\n$.fn.parseArray = function(array) {\n    return JSON.parse(array)\n}\n\n然后调用：\n$(\"\").stringifyArray(array)\n```\n\n-  jQuery和Zepto的区别？各自的使用场景？\n\n-  针对 jQuery 的优化方法？\n```\n*基于Class的选择性的性能相对于Id选择器开销很大，因为需遍历所有DOM元素。\n\n*频繁操作的DOM，先缓存起来再操作。用Jquery的链式调用更好。\n 比如：var str=$(\"a\").attr(\"href\");\n\n*for (var i = size; i < arr.length; i++) {}\n for 循环每一次循环都查找了数组 (arr) 的.length 属性，在开始循环的时候设置一个变量来存储这个数字，可以让循环跑得更快：\n for (var i = size, length = arr.length; i < length; i++) {}\n```\n\n-  Zepto的点透问题如何解决？\n\n-  jQueryUI如何自定义组件?\n\n-  需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？\n\n- 如何判断当前脚本运行在浏览器还是node环境中？（阿里）\n```\n通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中\n```\n-  移动端最小触控区域是多大？\n\n-  jQuery 的 slideUp动画 ，如果目标元素是被外部事件驱动, 当鼠标快速地连续触发外部元素事件, 动画会滞后的反复执行，该如何处理呢?\n\n-  把 Script 标签 放在页面的最底部的body封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？\n\n-  移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？（click 有 300ms 延迟,为了实现safari的双击事件的设计，浏览器要知道你是不是要双击操作。）\n\n-  知道各种JS框架(Angular, Backbone, Ember, React, Meteor, Knockout...)么? 能讲出他们各自的优点和缺点么?\n\n-  Underscore 对哪些 JS 原生对象进行了扩展以及提供了哪些好用的函数方法？\n\n-  解释JavaScript中的作用域与变量声明提升？\n\n-  那些操作会造成内存泄漏？\n```\n内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。\n垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。\n\nsetTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。\n闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）\n```\n\n-  JQuery一个对象可以同时绑定多个事件，这是如何实现的？\n\n-  Node.js的适用场景？\n\n-  (如果会用node)知道route, middleware, cluster, nodemon, pm2, server-side rendering么?\n\n-  解释一下 Backbone 的 MVC 实现方式？\n\n- 什么是“前端路由”?什么时候适合使用“前端路由”? “前端路由”有哪些优点和缺点?\n\n- 知道什么是webkit么? 知道怎么用浏览器的各种工具来调试和debug代码么?\n\n- 如何测试前端代码么? 知道BDD, TDD, Unit Test么? 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)?\n\n- 前端templating(Mustache, underscore, handlebars)是干嘛的, 怎么用?\n\n- 简述一下 Handlebars 的基本用法？\n\n- 简述一下 Handlerbars 的对模板的基本处理流程， 如何编译的？如何缓存的？\n\n- 用js实现千位分隔符?(来源：[前端农民工](http://div.io/topic/744)，提示：正则+replace)\n```\nfunction commafy(num) {\n     num = num + '';\n     var reg = /(-?d+)(d{3})/;\n    \n    if(reg.test(num)){\n     num = num.replace(reg, '$1,$2');\n    }\n    return num;\n}\n```\n    \n- 检测浏览器版本版本有哪些方式？\n```\n功能检测、userAgent特征检测\n\n比如：navigator.userAgent\n//\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36\n  (KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36\"\n```\n\n- What is a Polyfill? \n```\npolyfill 是“在旧版浏览器上复制标准 API 的 JavaScript 补充”,可以动态地加载 JavaScript 代码或库，在不支持这些标准 API 的浏览器中模拟它们。\n例如，geolocation（地理位置）polyfill 可以在 navigator 对象上添加全局的 geolocation 对象，还能添加 getCurrentPosition 函数以及“坐标”回调对象，\n所有这些都是 W3C 地理位置 API 定义的对象和函数。因为 polyfill 模拟标准 API，所以能够以一种面向所有浏览器未来的方式针对这些 API 进行开发，\n一旦对这些 API 的支持变成绝对大多数，则可以方便地去掉 polyfill，无需做任何额外工作。\n```\n\n- 做的项目中，有没有用过或自己实现一些 polyfill 方案（兼容性处理方案）？\n```\n比如： html5shiv、Geolocation、Placeholder \n```\n\n- 我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？\n\n\n#### <a name='other'>ECMAScript6 相关</a>\n\n- Object.is() 与原来的比较操作符“ ===”、“ ==”的区别？ \n```\n两等号判等，会在比较时进行类型转换；\n三等号判等(判断严格)，比较时不进行隐式类型转换,（类型不同则会返回false）； \n\nObject.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，\n但 Object.is(NaN, NaN) 会返回 true.\n\nObject.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。\n```\n\n#### <a name='other'>前端框架相关</a>\n\n- react-router 路由系统的实现原理？\n\n- React中如何解决第三方类库的问题?\n\n\n## <a name='other'>其他问题</a>\n\n- 原来公司工作流程是怎么样的，如何与其他人协作的？如何夸部门合作的？\n\n- 你遇到过比较难的技术问题是？你是如何解决的？\n\n- 设计模式 知道什么是singleton, factory, strategy, decrator么?\n\n- 常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？\n\n- 页面重构怎么操作？\n```\n网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。\n也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。\n\n对于传统的网站来说重构通常是：\n\n表格(table)布局改为DIV+CSS\n使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)\n对于移动平台的优化\n针对于SEO进行优化\n深层次的网站重构应该考虑的方面\n\n减少代码间的耦合\n让代码保持弹性\n严格按规范编写代码\n设计可扩展的API\n代替旧有的框架、语言(如VB)\n增强用户体验\n通常来说对于速度的优化也包含在重构中\n\n压缩JS、CSS、image等前端资源(通常是由服务器来解决)\n程序的性能优化(如数据读写)\n采用CDN来加速资源加载\n对于JS DOM的优化\nHTTP服务器的文件缓存\n```\n- 列举IE与其他浏览器不一样的特性？\n```\n1、事件不同之处：\n\n触发事件的元素被认为是目标（target）。而在 IE 中，目标包含在 event 对象的 srcElement 属性；\n\n获取字符代码、如果按键代表一个字符（shift、ctrl、alt除外），IE 的 keyCode 会返回字符代码（Unicode），DOM 中按键的代码和字符是分离的，要获取字符代码，需要使用 charCode 属性；\n\n阻止某个事件的默认行为，IE 中阻止某个事件的默认行为，必须将 returnValue 属性设置为 false，Mozilla 中，需要调用 preventDefault() 方法；\n\n停止事件冒泡，IE 中阻止事件进一步冒泡，需要设置 cancelBubble 为 true，Mozzilla 中，需要调用 stopPropagation()；\n```\n\n- 99%的网站都需要被重构是那本书上写的？\n```\n网站重构：应用web标准进行设计（第2版）\n```\n- 什么叫优雅降级和渐进增强？\n```\n优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。\n如：border-shadow\n\n渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。\n如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验；\n```\n- 是否了解公钥加密和私钥加密。\n```\n一般情况下是指私钥用于对数据进行签名，公钥用于对签名进行验证;\nHTTP网站在浏览器端用公钥加密敏感数据，然后在服务器端再用私钥解密。\n```\n\n- WEB应用从服务器主动推送Data到客户端有那些方式？\n```\nhtml5提供的Websocket\n不可见的iframe\nWebSocket通过Flash\nXHR长时间连接\nXHR Multipart Streaming\n<script>标签的长时间连接(可跨域)\n```\n- 对Node的优点和缺点提出了自己的看法？\n```\n*（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，\n  因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。\n  此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，\n  因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。\n\n*（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，\n  而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。\n```\n\n- 你有用过哪些前端性能优化的方法？\n```\n（1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。\n\n（2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数\n\n（3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。\n\n（4） 当需要设置的样式很多时设置className而不是直接操作style。\n\n（5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。\n\n（6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。\n\n（7） 图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。\n\n（8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。\n对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。\n```\n\n- http状态码有那些？分别代表是什么意思？\n```\n简单版\n[\n    100  Continue   继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息\n    200  OK         正常返回信息\n    201  Created    请求成功并且服务器创建了新的资源\n    202  Accepted   服务器已接受请求，但尚未处理\n    301  Moved Permanently  请求的网页已永久移动到新位置。\n    302 Found       临时性重定向。\n    303 See Other   临时性重定向，且总是使用 GET 请求新的 URI。\n    304  Not Modified 自从上次请求后，请求的网页未修改过。\n\n    400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。\n    401 Unauthorized 请求未授权。\n    403 Forbidden   禁止访问。\n    404 Not Found   找不到如何与 URI 相匹配的资源。\n\n    500 Internal Server Error  最常见的服务器端错误。\n    503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。\n]\n\n完整版\n1**(信息类)：表示接收到请求并且继续处理\n100——客户必须继续发出请求\n101——客户要求服务器根据请求转换HTTP协议版本\n\n2**(响应成功)：表示动作被成功接收、理解和接受\n200——表明该请求被成功地完成，所请求的资源发送回客户端\n201——提示知道新文件的URL\n202——接受和处理、但处理未完成\n203——返回信息不确定或不完整\n204——请求收到，但返回信息为空\n205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件\n206——服务器已经完成了部分用户的GET请求\n\n3**(重定向类)：为了完成指定的动作，必须接受进一步处理\n300——请求的资源可在多处得到\n301——本网页被永久性转移到另一个URL\n302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。\n303——建议客户访问其他URL或访问方式\n304——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用\n305——请求的资源必须从服务器指定的地址得到\n306——前一版本HTTP中使用的代码，现行版本中不再使用\n307——申明请求的资源临时性删除\n\n4**(客户端错误类)：请求包含错误语法或不能正确执行\n400——客户端请求有语法错误，不能被服务器所理解\n401——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用\nHTTP 401.1 - 未授权：登录失败\n　　HTTP 401.2 - 未授权：服务器配置问题导致登录失败\n　　HTTP 401.3 - ACL 禁止访问资源\n　　HTTP 401.4 - 未授权：授权被筛选器拒绝\nHTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败\n402——保留有效ChargeTo头响应\n403——禁止访问，服务器收到请求，但是拒绝提供服务\nHTTP 403.1 禁止访问：禁止可执行访问\n　　HTTP 403.2 - 禁止访问：禁止读访问\n　　HTTP 403.3 - 禁止访问：禁止写访问\n　　HTTP 403.4 - 禁止访问：要求 SSL\n　　HTTP 403.5 - 禁止访问：要求 SSL 128\n　　HTTP 403.6 - 禁止访问：IP 地址被拒绝\n　　HTTP 403.7 - 禁止访问：要求客户证书\n　　HTTP 403.8 - 禁止访问：禁止站点访问\n　　HTTP 403.9 - 禁止访问：连接的用户过多\n　　HTTP 403.10 - 禁止访问：配置无效\n　　HTTP 403.11 - 禁止访问：密码更改\n　　HTTP 403.12 - 禁止访问：映射器拒绝访问\n　　HTTP 403.13 - 禁止访问：客户证书已被吊销\n　　HTTP 403.15 - 禁止访问：客户访问许可过多\n　　HTTP 403.16 - 禁止访问：客户证书不可信或者无效\nHTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效\n404——一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL\n405——用户在Request-Line字段定义的方法不允许\n406——根据用户发送的Accept拖，请求资源不可访问\n407——类似401，用户必须首先在代理服务器上得到授权\n408——客户端没有在用户指定的饿时间内完成请求\n409——对当前资源状态，请求不能完成\n410——服务器上不再有此资源且无进一步的参考地址\n411——服务器拒绝用户定义的Content-Length属性请求\n412——一个或多个请求头字段在当前请求中错误\n413——请求的资源大于服务器允许的大小\n414——请求的资源URL长于服务器允许的长度\n415——请求资源不支持请求项目格式\n416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段\n417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。\n\n5**(服务端错误类)：服务器不能正确执行一个正确的请求\nHTTP 500 - 服务器遇到错误，无法完成请求\n　　HTTP 500.100 - 内部服务器错误 - ASP 错误\n　　HTTP 500-11 服务器关闭\n　　HTTP 500-12 应用程序重新启动\n　　HTTP 500-13 - 服务器太忙\n　　HTTP 500-14 - 应用程序无效\n　　HTTP 500-15 - 不允许请求 global.asa\n　　Error 501 - 未实现\nHTTP 502 - 网关错误\nHTTP 503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常\n\n- 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）\n\n注：这题胜在区分度高，知识点覆盖广，再不懂的人，也能答出几句，\n而高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、\n到浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JS API绑定等等；\n\n详细版：\n1、浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;\n2、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;\n3、通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;\n4、进行HTTP协议会话，客户端发送报头(请求报头);\n5、进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;\n6、进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;\n7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;\n8、浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;\n9、文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;\n10、页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。\n\n简洁版：\n浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；\n服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；\n浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；\n载入解析到的资源文件，渲染页面，完成。\n```\n\n- 部分地区用户反应网站很卡，请问有哪些可能性的原因，以及解决方法？\n\n- 从打开app到刷新出内容，整个过程中都发生了什么，如果感觉慢，怎么定位问题，怎么解决?\n\n- 除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？\n\n- 你用的得心应手用的熟练地编辑器&开发环境是什么样子？\n```\nSublime Text 3 + 相关插件编写前端代码\nGoogle chrome 、Mozilla Firefox浏览器 +firebug 兼容测试和预览页面UI、动画效果和交互功能\nNode.js+Gulp\ngit 用于版本控制和Code Review\n```\n\n- 对前端工程师这个职位是怎么样理解的？它的前景会怎么样？\n```\n前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。\n1、实现界面交互\n2、提升用户体验\n3、有了Node.js，前端可以实现服务端的一些事情\n\n前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，\n\n参与项目，快速高质量完成实现效果图，精确到1px；\n\n与团队成员，UI设计，产品经理的沟通；\n\n做好的页面结构，页面重构和用户体验；\n\n处理hack，兼容、写出优美的代码格式；\n\n针对服务器的优化、拥抱最新前端技术。\n```\n\n- 你怎么看待Web App 、hybrid App、Native App？\n\n- 你移动端前端开发的理解？（和 Web 前端开发的主要区别是什么？）\n\n- 你对加班的看法？\n```\n加班就像借钱，原则应当是------救急不救穷\n```\n\n- 平时如何管理你的项目？\n```\n先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等；\n\n编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；\n\n标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；\n\n页面进行标注（例如 页面 模块 开始和结束）；\n\nCSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）；\n\nJS 分文件夹存放 命名以该JS功能为准的英文翻译。\n\n图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理\n```\n\n- 如何设计突发大规模并发架构？\n\n- 当团队人手不足，把功能代码写完已经需要加班的情况下，你会做前端代码的测试吗？\n\n- 说说最近最流行的一些东西吧？常去哪些网站？\n```\nES6\\WebAssembly\\Node\\MVVM\\Web Components\\React\\React Native\\Webpack 组件化\n```\n\n- 知道什么是SEO并且怎么优化么? 知道各种meta data的含义么?\n\n- 移动端（Android IOS）怎么做好用户体验?\n```\n清晰的视觉纵线、\n信息的分组、极致的减法、\n利用选择代替输入、\n标签及文字的排布方式、\n依靠明文确认密码、\n合理的键盘利用、\n```\n\n- 简单描述一下你做过的移动APP项目研发流程？\n\n- 你在现在的团队处于什么样的角色，起到了什么明显的作用？\n\n- 你认为怎样才是全端工程师（Full Stack developer）？\n\n- 介绍一个你最得意的作品吧？\n\n- 你有自己的技术博客吗，用了哪些技术？\n\n- 对前端安全有什么看法？\n\n- 是否了解Web注入攻击，说下原理，最常见的两种攻击（XSS 和 CSRF）了解到什么程度？\n\n- 项目中遇到国哪些印象深刻的技术难题，具体是什么问题，怎么解决？。\n\n- 最近在学什么东西？\n\n- 你的优点是什么？缺点是什么？\n\n- 如何管理前端团队?\n\n- 最近在学什么？能谈谈你未来3，5年给自己的规划吗？\n\n\n## <a name='web'>前端学习网站推荐</a>\n\n[极客标签](http://www.gbtags.com/)  \n[码农周刊](http://weekly.manong.io/issues/)\n[前端周刊](http://www.feweekly.com/issues)\n[慕课网](http://www.imooc.com/)\n[div.io](http://div.io)\n[Hacker News](https://news.ycombinator.com/news)\n[InfoQ](http://www.infoq.com/)\n[w3cplus](http://www.w3cplus.com/)\n[Stack Overflow](http://stackoverflow.com/)\n[w3school](http://www.w3school.com.cn/)\n[mozilla](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript)\n\n\n\n## <a name='web'>文档推荐</a>\n\n1. [jQuery 基本原理](http://docs.huihoo.com/jquery/jquery-fundamentals/zh-cn/index.html \"jQuery 基本原理\")\n\n2. [JavaScript 秘密花园](http://bonsaiden.github.io/JavaScript-Garden/zh/)\n\n3. [CSS参考手册](http://css.doyoe.com/)\n\n4. [JavaScript 标准参考教程](http://javascript.ruanyifeng.com/)\n\n5. [ECMAScript 6入门](http://es6.ruanyifeng.com/)","slug":"前端开发面试题","published":1,"updated":"2019-03-21T03:42:03.284Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtifjpuj0013lohi5kvoj5l1","content":"<p>本文收集总结了一些前端面试题，初学者阅后也要用心钻研其中的原理，重要知识需要系统学习、透彻学习，形成自己的知识链。万不可投机取巧，临时抱佛脚只求面试侥幸混过关是错误的！也是不可能的！不可能的！不可能的！<br><a id=\"more\"></a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a><a name=\"preface\">前言</a></h2><p>前端还是一个年轻的行业，新的行业标准， 框架， 库都不断在更新和新增，正如赫门在2015深JS大会上的《前端服务化之路》主题演讲中说的一句话：“每18至24个月，前端都会难一倍”，这些变化使前端的能力更加丰富、创造的应用也会更加完美。所以关注各种前端技术，跟上快速变化的节奏，也是身为一个前端程序员必备的技能之一。</p>\n<p><strong>面试有几点需注意：</strong><br>来源<a href=\"http://weibo.com/wintercn\" title=\"微博：寒冬winter\" target=\"_blank\" rel=\"noopener\">寒冬winter</a> 老师，github:@wintercn</p>\n<ol>\n<li><p>面试题目： 根据你的等级和职位的变化，入门级到专家级，广度和深度都会有所增加。</p>\n</li>\n<li><p>题目类型： 理论知识、算法、项目细节、技术视野、开放性题、工作案例。</p>\n</li>\n<li><p>细节追问： 可以确保问到你开始不懂或面试官开始不懂为止，这样可以大大延展题目的区分度和深度，知道你的实际能力。因为这种知识关联是长时期的学习，临时抱佛脚绝对是记不住的。</p>\n</li>\n<li><p>回答问题再棒，面试官（可能是你面试职位的直接领导），会考虑我要不要这个人做我的同事？所以态度很重要、除了能做事，还要会做人。（感觉更像是相亲）</p>\n</li>\n<li><p>资深的前端开发能把absolute和relative弄混，这样的人不要也罢，因为团队需要的是：你这个人具有可以依靠的才能（靠谱）。</p>\n</li>\n</ol>\n<p><strong>前端开发知识点：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTML&amp;CSS：</span><br><span class=\"line\">    对Web标准的理解、浏览器内核差异、兼容性、hack、CSS基本功：布局、盒子模型、选择器优先级、</span><br><span class=\"line\">    HTML5、CSS3、Flexbox</span><br><span class=\"line\"></span><br><span class=\"line\">JavaScript：</span><br><span class=\"line\">    数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、RegExp、JSON、Ajax、</span><br><span class=\"line\">    DOM、BOM、内存泄漏、跨域、异步装载、模板引擎、前端MVC、路由、模块化、Canvas、ECMAScript 6、Nodejs</span><br><span class=\"line\"></span><br><span class=\"line\">其他：</span><br><span class=\"line\">    移动端、响应式、自动化构建、HTTP、离线存储、WEB安全、优化、重构、团队协作、可维护、易用性、SEO、UED、架构、职业生涯、快速学习能力</span><br></pre></td></tr></table></figure></p>\n<p>作为一名前端工程师，<strong>无论工作年头长短都应该掌握的知识点</strong>：<br>此条由 王子墨 发表在 <a href=\"http://lab.yuanwai.wang/\" target=\"_blank\" rel=\"noopener\">攻城师的实验室</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、DOM结构 —— 两个节点之间可能存在哪些关系以及如何在节点之间任意移动。</span><br><span class=\"line\"></span><br><span class=\"line\">2、DOM操作 —— 如何添加、移除、移动、复制、创建和查找节点等。</span><br><span class=\"line\"></span><br><span class=\"line\">3、事件 —— 如何使用事件，以及IE和标准DOM事件模型之间存在的差别。</span><br><span class=\"line\"></span><br><span class=\"line\">4、XMLHttpRequest —— 这是什么、怎样完整地执行一次GET请求、怎样检测错误。</span><br><span class=\"line\"></span><br><span class=\"line\">5、严格模式与混杂模式 —— 如何触发这两种模式，区分它们有何意义。</span><br><span class=\"line\"></span><br><span class=\"line\">6、盒模型 —— 外边距、内边距和边框之间的关系，及IE8以下版本的浏览器中的盒模型</span><br><span class=\"line\"></span><br><span class=\"line\">7、块级元素与行内元素 —— 怎么用CSS控制它们、以及如何合理的使用它们</span><br><span class=\"line\"></span><br><span class=\"line\">8、浮动元素 —— 怎么使用它们、它们有什么问题以及怎么解决这些问题。</span><br><span class=\"line\"></span><br><span class=\"line\">9、HTML与XHTML —— 二者有什么区别，你觉得应该使用哪一个并说出理由。</span><br><span class=\"line\"></span><br><span class=\"line\">10、JSON —— 作用、用途、设计结构。</span><br></pre></td></tr></table></figure></p>\n<p><strong>备注：</strong></p>\n<blockquote>\n<p>根据自己需要选择性阅读，面试题是对理论知识的总结，让自己学会应该如何表达。<br>资料答案不够正确和全面，欢迎欢迎Star和提交issues。<br>格式不断修改更新中。<br>更新记录：<br>2016年3月25日：新增ECMAScript6 相关问题</p>\n</blockquote>\n<p>###更新时间:  2016-3-25</p>\n<h2 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a><a name=\"html\">HTML</a></h2><ul>\n<li><p>Doctype作用？标准模式与兼容模式各有什么区别?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）、&lt;!DOCTYPE&gt;声明位于位于HTML文档中的第一行，处于 &lt;html&gt; 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。</span><br><span class=\"line\"></span><br><span class=\"line\">（2）、标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；</span><br><span class=\"line\"></span><br><span class=\"line\">而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">首先：CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。</span><br><span class=\"line\"></span><br><span class=\"line\">（1）行内元素有：a b span img input select strong（强调的语气）</span><br><span class=\"line\">（2）块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p</span><br><span class=\"line\"></span><br><span class=\"line\">（3）常见的空元素：</span><br><span class=\"line\">    &lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;</span><br><span class=\"line\">    鲜为人知的是：</span><br><span class=\"line\">    &lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;keygen&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>页面导入样式时，使用link和@import有什么区别？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;</span><br><span class=\"line\"></span><br><span class=\"line\">（2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;</span><br><span class=\"line\"></span><br><span class=\"line\">（3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>介绍一下你对浏览器内核的理解？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。</span><br><span class=\"line\">渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。</span><br><span class=\"line\"></span><br><span class=\"line\">JS引擎则：解析和执行javascript来实现网页的动态效果。</span><br><span class=\"line\"></span><br><span class=\"line\">最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>常见的浏览器内核有哪些？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]</span><br><span class=\"line\">Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等</span><br><span class=\"line\">Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]</span><br><span class=\"line\">Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>详细文章：<a href=\"http://www.cnblogs.com/fullhouse/archive/2011/12/19/2293455.html\" target=\"_blank\" rel=\"noopener\">浏览器内核的解析和对比</a></p>\n</blockquote>\n<ul>\n<li><p>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和<br>HTML5？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</span><br><span class=\"line\">      绘画 canvas;</span><br><span class=\"line\">      用于媒介回放的 video 和 audio 元素;</span><br><span class=\"line\">      本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;</span><br><span class=\"line\">      sessionStorage 的数据在浏览器关闭后自动删除;</span><br><span class=\"line\">      语意化更好的内容元素，比如 article、footer、header、nav、section;</span><br><span class=\"line\">      表单控件，calendar、date、time、email、url、search;</span><br><span class=\"line\">      新的技术webworker, websocket, Geolocation;</span><br><span class=\"line\"></span><br><span class=\"line\">  移除的元素：</span><br><span class=\"line\">      纯表现的元素：basefont，big，center，font, s，strike，tt，u;</span><br><span class=\"line\">      对可用性产生负面影响的元素：frame，frameset，noframes；</span><br><span class=\"line\"></span><br><span class=\"line\">* 支持HTML5新标签：</span><br><span class=\"line\">     IE8/IE7/IE6支持通过document.createElement方法产生的标签，</span><br><span class=\"line\">     可以利用这一特性让这些浏览器支持HTML5新标签，</span><br><span class=\"line\">     浏览器支持新标签后，还需要添加标签默认的样式。</span><br><span class=\"line\"></span><br><span class=\"line\">     当然也可以直接使用成熟的框架、比如html5shim;</span><br><span class=\"line\">     &lt;!--[if lt IE 9]&gt;</span><br><span class=\"line\">        &lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt;</span><br><span class=\"line\">     &lt;![endif]--&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">* 如何区分HTML5： DOCTYPE声明\\新增的结构元素\\功能元素</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>简述一下你对HTML语义化的理解？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用正确的标签做正确的事情。</span><br><span class=\"line\">html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;</span><br><span class=\"line\">即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;</span><br><span class=\"line\">搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;</span><br><span class=\"line\">使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>HTML5的离线储存怎么使用，工作原理能不能解释一下？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。</span><br><span class=\"line\">原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</span><br><span class=\"line\"></span><br><span class=\"line\">如何使用：</span><br><span class=\"line\">1、页面头部像下面一样加入一个manifest的属性；</span><br><span class=\"line\">2、在cache.manifest文件的编写离线存储的资源；</span><br><span class=\"line\">    CACHE MANIFEST</span><br><span class=\"line\">    #v0.11</span><br><span class=\"line\">    CACHE:</span><br><span class=\"line\">    js/app.js</span><br><span class=\"line\">    css/style.css</span><br><span class=\"line\">    NETWORK:</span><br><span class=\"line\">    resourse/logo.png</span><br><span class=\"line\">    FALLBACK:</span><br><span class=\"line\">    / /offline.html</span><br><span class=\"line\">3、在离线状态时，操作window.applicationCache进行需求实现。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>详细的使用请参考：<a href=\"http://segmentfault.com/a/1190000000732617\" target=\"_blank\" rel=\"noopener\">有趣的HTML5：离线存储</a></p>\n</blockquote>\n<ul>\n<li>浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。</span><br><span class=\"line\">离线的情况下，浏览器就直接使用离线存储的资源。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>详细的使用请参考：<a href=\"http://segmentfault.com/a/1190000000732617\" target=\"_blank\" rel=\"noopener\">有趣的HTML5：离线存储</a></p>\n</blockquote>\n<ul>\n<li><p>请描述一下 cookies，sessionStorage 和 localStorage 的区别？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。</span><br><span class=\"line\">cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。</span><br><span class=\"line\">sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</span><br><span class=\"line\"></span><br><span class=\"line\">存储大小：</span><br><span class=\"line\">    cookie数据大小不能超过4k。</span><br><span class=\"line\">    sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</span><br><span class=\"line\"></span><br><span class=\"line\">有期时间：</span><br><span class=\"line\">    localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；</span><br><span class=\"line\">    sessionStorage  数据在当前浏览器窗口关闭后自动删除。</span><br><span class=\"line\">    cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>iframe有那些缺点？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*iframe会阻塞主页面的Onload事件；</span><br><span class=\"line\">*搜索引擎的检索程序无法解读这种页面，不利于SEO;</span><br><span class=\"line\"></span><br><span class=\"line\">*iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</span><br><span class=\"line\"></span><br><span class=\"line\">使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript</span><br><span class=\"line\">动态给iframe添加src属性值，这样可以绕开以上两个问题。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Label的作用是什么？是怎么用的？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;label for=&quot;Name&quot;&gt;Number:&lt;/label&gt;</span><br><span class=\"line\">&lt;input type=“text“name=&quot;Name&quot; id=&quot;Name&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;label&gt;Date:&lt;input type=&quot;text&quot; name=&quot;B&quot;/&gt;&lt;/label&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>HTML5的form如何关闭自动完成功能？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给不想要提示的 form 或某个 input 设置为 autocomplete=off。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如何实现浏览器内多个标签页之间的通信? (阿里)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WebSocket、SharedWorker；</span><br><span class=\"line\">也可以调用localstorge、cookies等本地存储方式；</span><br><span class=\"line\"></span><br><span class=\"line\">localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，</span><br><span class=\"line\">我们通过监听事件，控制它的值来进行页面信息通信；</span><br><span class=\"line\">注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常；</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>webSocket如何兼容低浏览器？(阿里)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Adobe Flash Socket 、</span><br><span class=\"line\">ActiveX HTMLFile (IE) 、</span><br><span class=\"line\">基于 multipart 编码发送 XHR 、</span><br><span class=\"line\">基于长轮询的 XHR</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>页面可见性（Page Visibility API） 可以有哪些用途？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;</span><br><span class=\"line\">在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放；</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如何在页面上实现一个圆形的可点击区域？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、map+area或者svg</span><br><span class=\"line\">2、border-radius</span><br><span class=\"line\">3、纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div style=&quot;height:1px;overflow:hidden;background:red&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>网页验证码是干嘛的，是为了解决什么安全问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水；</span><br><span class=\"line\">有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>title与h1的区别、b与strong的区别、i与em的区别？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响；</span><br><span class=\"line\"></span><br><span class=\"line\">strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：&lt;strong&gt;会重读，而&lt;B&gt;是展示强调内容。</span><br><span class=\"line\"></span><br><span class=\"line\">i内容展示为斜体，em表示强调的文本；</span><br><span class=\"line\"></span><br><span class=\"line\">Physical Style Elements -- 自然样式标签</span><br><span class=\"line\">b, i, u, s, pre</span><br><span class=\"line\">Semantic Style Elements -- 语义样式标签</span><br><span class=\"line\">strong, em, ins, del, code</span><br><span class=\"line\">应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a><a name=\"css\">CSS</a></h2><ul>\n<li><p>介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）有两种， IE 盒子模型、W3C 盒子模型；</span><br><span class=\"line\">（2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；</span><br><span class=\"line\">（3）区  别： IE的content部分把 border 和 padding计算了进去;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>CSS选择符有哪些？哪些属性可以继承？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*   1.id选择器（ # myid）</span><br><span class=\"line\">    2.类选择器（.myclassname）</span><br><span class=\"line\">    3.标签选择器（div, h1, p）</span><br><span class=\"line\">    4.相邻选择器（h1 + p）</span><br><span class=\"line\">    5.子选择器（ul &gt; li）</span><br><span class=\"line\">    6.后代选择器（li a）</span><br><span class=\"line\">    7.通配符选择器（ * ）</span><br><span class=\"line\">    8.属性选择器（a[rel = &quot;external&quot;]）</span><br><span class=\"line\">    9.伪类选择器（a:hover, li:nth-child）</span><br><span class=\"line\"></span><br><span class=\"line\">*   可继承的样式： font-size font-family color, UL LI DL DD DT;</span><br><span class=\"line\"></span><br><span class=\"line\">*   不可继承的样式：border padding margin width height ;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>CSS优先级算法如何计算？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*   优先级就近原则，同权重情况下样式定义最近者为准;</span><br><span class=\"line\"></span><br><span class=\"line\">*   载入样式以最后载入的定位为准;</span><br><span class=\"line\"></span><br><span class=\"line\">优先级为:</span><br><span class=\"line\">   !important &gt;  id &gt; class &gt; tag</span><br><span class=\"line\">    important 比 内联优先级高</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>CSS3新增伪类有那些？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">举例：</span><br><span class=\"line\">p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class=\"line\">p:last-of-type  选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class=\"line\">p:only-of-type  选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class=\"line\">p:only-child        选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。</span><br><span class=\"line\">p:nth-child(2)  选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。</span><br><span class=\"line\"></span><br><span class=\"line\">:after          在元素之前添加内容,也可以用来做清除浮动。</span><br><span class=\"line\">:before         在元素之后添加内容</span><br><span class=\"line\">:enabled        </span><br><span class=\"line\">:disabled       控制表单控件的禁用状态。</span><br><span class=\"line\">:checked        单选框或复选框被选中。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 给div设置一个宽度，然后添加margin:0 auto属性</span><br><span class=\"line\">  div&#123;</span><br><span class=\"line\">      width:200px;</span><br><span class=\"line\">      margin:0 auto;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">* 居中一个浮动元素</span><br><span class=\"line\"></span><br><span class=\"line\">  确定容器的宽高 宽500 高 300 的层设置层的外边距</span><br><span class=\"line\"> .div &#123;</span><br><span class=\"line\">      width:500px ; height:300px;//高度可以不设</span><br><span class=\"line\">      margin: -150px 0 0 -250px;</span><br><span class=\"line\">      position:relative;         //相对定位</span><br><span class=\"line\">      background-color:pink;     //方便看效果</span><br><span class=\"line\">      left:50%;</span><br><span class=\"line\">      top:50%;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">* 让绝对定位的div居中</span><br><span class=\"line\"></span><br><span class=\"line\">  position: absolute;</span><br><span class=\"line\">  width: 1200px;</span><br><span class=\"line\">  background: none;</span><br><span class=\"line\">  margin: 0 auto;</span><br><span class=\"line\">  top: 0;</span><br><span class=\"line\">  left: 0;</span><br><span class=\"line\">  bottom: 0;</span><br><span class=\"line\">  right: 0;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>display有哪些值？说明他们的作用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">block         象块类型元素一样显示。</span><br><span class=\"line\">none          缺省值。象行内元素类型一样显示。</span><br><span class=\"line\">inline-block  象行内元素一样显示，但其内容象块类型元素一样显示。</span><br><span class=\"line\">list-item     象块类型元素一样显示，并添加样式列表标记。</span><br><span class=\"line\">table         此元素会作为块级表格来显示</span><br><span class=\"line\">inherit       规定应该从父元素继承 display 属性的值</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>position的值relative和absolute定位原点是？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">absolute</span><br><span class=\"line\">  生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。</span><br><span class=\"line\">fixed （老IE不支持）</span><br><span class=\"line\">  生成绝对定位的元素，相对于浏览器窗口进行定位。</span><br><span class=\"line\">relative</span><br><span class=\"line\">  生成相对定位的元素，相对于其正常位置进行定位。</span><br><span class=\"line\">static</span><br><span class=\"line\">  默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。</span><br><span class=\"line\">inherit</span><br><span class=\"line\">  规定从父元素继承 position 属性的值。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>CSS3有哪些新特性？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">新增各种CSS选择器    （: not(.input)：所有 class 不是“input”的节点）</span><br><span class=\"line\">圆角           （border-radius:8px）</span><br><span class=\"line\">多列布局        （multi-column layout）</span><br><span class=\"line\">阴影和反射      （Shadow\\Reflect）</span><br><span class=\"line\">文字特效      （text-shadow、）</span><br><span class=\"line\">文字渲染      （Text-decoration）</span><br><span class=\"line\">线性渐变      （gradient）</span><br><span class=\"line\">旋转          （transform）</span><br><span class=\"line\">增加了旋转,缩放,定位,倾斜,动画，多背景</span><br><span class=\"line\">transform:\\scale(0.85,0.90)\\ translate(0px,-30px)\\ skew(-9deg,0deg)\\Animation:</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用纯CSS创建一个三角形的原理是什么？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">把上、左、右三条边隐藏掉（颜色设为 transparent）</span><br><span class=\"line\">#demo &#123;</span><br><span class=\"line\">  width: 0;</span><br><span class=\"line\">  height: 0;</span><br><span class=\"line\">  border-width: 20px;</span><br><span class=\"line\">  border-style: solid;</span><br><span class=\"line\">  border-color: transparent transparent red transparent;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>一个满屏 品 字布局 如何设计?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">简单的方式：</span><br><span class=\"line\">    上面的div宽100%，</span><br><span class=\"line\">    下面的两个div分别宽50%，</span><br><span class=\"line\">    然后用float或者inline使其不换行即可</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.</span><br><span class=\"line\"></span><br><span class=\"line\">* 浏览器默认的margin和padding不同。解决方案是加一个全局的*&#123;margin:0;padding:0;&#125;来统一。</span><br><span class=\"line\"></span><br><span class=\"line\">* IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。</span><br><span class=\"line\"></span><br><span class=\"line\">  浮动ie产生的双倍距离 #box&#123; float:left; width:10px; margin:0 0 0 100px;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)</span><br><span class=\"line\"></span><br><span class=\"line\">  渐进识别的方式，从总体中逐渐排除局部。</span><br><span class=\"line\"></span><br><span class=\"line\">  首先，巧妙的使用“\\9”这一标记，将IE游览器从所有情况中分离出来。</span><br><span class=\"line\">  接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。</span><br><span class=\"line\"></span><br><span class=\"line\">  css</span><br><span class=\"line\">      .bb&#123;</span><br><span class=\"line\">          background-color:#f1ee18;/*所有识别*/</span><br><span class=\"line\">          .background-color:#00deff\\9; /*IE6、7、8识别*/</span><br><span class=\"line\">          +background-color:#a200ff;/*IE6、7识别*/</span><br><span class=\"line\">          _background-color:#1e0bd1;/*IE6识别*/</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">*  IE下,可以使用获取常规属性的方法来获取自定义属性,</span><br><span class=\"line\">   也可以使用getAttribute()获取自定义属性;</span><br><span class=\"line\">   Firefox下,只能使用getAttribute()获取自定义属性。</span><br><span class=\"line\">   解决方法:统一通过getAttribute()获取自定义属性。</span><br><span class=\"line\"></span><br><span class=\"line\">*  IE下,even对象有x,y属性,但是没有pageX,pageY属性;</span><br><span class=\"line\">   Firefox下,event对象有pageX,pageY属性,但是没有x,y属性。</span><br><span class=\"line\"></span><br><span class=\"line\">*  解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。</span><br><span class=\"line\"></span><br><span class=\"line\">*  Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,</span><br><span class=\"line\">   可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。</span><br><span class=\"line\"></span><br><span class=\"line\">超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:</span><br><span class=\"line\">L-V-H-A :  a:link &#123;&#125; a:visited &#123;&#125; a:hover &#123;&#125; a:active &#123;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">行框的排列会受到中间空白（回车\\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>为什么要初始化CSS样式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</span><br><span class=\"line\"></span><br><span class=\"line\">- 当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。</span><br><span class=\"line\"></span><br><span class=\"line\">最简单的初始化方法： * &#123;padding: 0; margin: 0;&#125; （强烈不建议）</span><br><span class=\"line\"></span><br><span class=\"line\">淘宝的样式初始化代码：</span><br><span class=\"line\">body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td &#123; margin:0; padding:0; &#125;</span><br><span class=\"line\">body, button, input, select, textarea &#123; font:12px/1.5tahoma, arial, \\5b8b\\4f53; &#125;</span><br><span class=\"line\">h1, h2, h3, h4, h5, h6&#123; font-size:100%; &#125;</span><br><span class=\"line\">address, cite, dfn, em, var &#123; font-style:normal; &#125;</span><br><span class=\"line\">code, kbd, pre, samp &#123; font-family:couriernew, courier, monospace; &#125;</span><br><span class=\"line\">small&#123; font-size:12px; &#125;</span><br><span class=\"line\">ul, ol &#123; list-style:none; &#125;</span><br><span class=\"line\">a &#123; text-decoration:none; &#125;</span><br><span class=\"line\">a:hover &#123; text-decoration:underline; &#125;</span><br><span class=\"line\">sup &#123; vertical-align:text-top; &#125;</span><br><span class=\"line\">sub&#123; vertical-align:text-bottom; &#125;</span><br><span class=\"line\">legend &#123; color:#000; &#125;</span><br><span class=\"line\">fieldset, img &#123; border:0; &#125;</span><br><span class=\"line\">button, input, select, textarea &#123; font-size:100%; &#125;</span><br><span class=\"line\">table &#123; border-collapse:collapse; border-spacing:0; &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>absolute的containing block(容器块)计算方式跟正常流有什么不同？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">无论属于哪种，都要先找到其祖先元素中最近的 position 值不为 static 的元素，然后再判断：</span><br><span class=\"line\">1、若此元素为 inline 元素，则 containing block 为能够包含这个元素生成的第一个和最后一个 inline box 的 padding box (除 margin, border 外的区域) 的最小矩形；</span><br><span class=\"line\">2、否则,则由这个祖先元素的 padding box 构成。</span><br><span class=\"line\">如果都找不到，则为 initial containing block。</span><br><span class=\"line\"></span><br><span class=\"line\">补充：</span><br><span class=\"line\">1. static(默认的)/relative：简单说就是它的父元素的内容框（即去掉padding的部分）</span><br><span class=\"line\">2. absolute: 向上找最近的定位为absolute/relative的元素</span><br><span class=\"line\">3. fixed: 它的containing block一律为根元素(html/body)，根元素也是initial containing block</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？</p>\n</li>\n<li><p>position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？</p>\n</li>\n<li><p>对BFC规范(块级格式化上下文：block formatting context)的理解？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（W3C CSS 2.1 规范中的一个概念,它是一个独立容器，决定了元素如何对其内容进行定位,以及与其他元素的关系和相互作用。）</span><br><span class=\"line\"> 一个页面是由很多个 Box 组成的,元素的类型和 display 属性,决定了这个 Box 的类型。</span><br><span class=\"line\"> 不同类型的 Box,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>css定义的权重</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下例子是演示各种定义的权重值：</span><br><span class=\"line\"></span><br><span class=\"line\">/*权重为1*/</span><br><span class=\"line\">div&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*权重为10*/</span><br><span class=\"line\">.class1&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*权重为100*/</span><br><span class=\"line\">#id1&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*权重为100+1=101*/</span><br><span class=\"line\">#id1 div&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*权重为10+1=11*/</span><br><span class=\"line\">.class1 div&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*权重为10+10+1=21*/</span><br><span class=\"line\">.class1 .class2 div&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>请解释一下为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式</p>\n</li>\n</ul>\n<ul>\n<li>移动端的布局用过媒体查询吗？</li>\n</ul>\n<ul>\n<li><p>使用 CSS 预处理器吗？喜欢那个？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SASS (SASS、LESS没有本质区别，只因为团队前端都是用的SASS)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>CSS优化、提高性能的方法有哪些？</p>\n</li>\n<li><p>浏览器是怎样解析CSS选择器的？</p>\n</li>\n<li><p>在网页中的应该使用奇数还是偶数的字体？为什么呢？</p>\n</li>\n<li><p>margin和padding分别适合什么场景使用？</p>\n</li>\n<li><p>抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题]</p>\n</li>\n<li><p>元素竖向的百分比设定是相对于容器的高度吗？</p>\n</li>\n<li><p>全屏滚动的原理是什么？用到了CSS的那些属性？</p>\n</li>\n<li><p>什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？</p>\n</li>\n<li><p>视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）</p>\n</li>\n<li><p>::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。</p>\n</li>\n<li><p>如何修改chrome记住密码后自动填充表单的黄色背景 ？</p>\n</li>\n<li><p>你对line-height是如何理解的？</p>\n</li>\n<li><p>设置元素浮动后，该元素的display值是多少？（自动变成display:block）</p>\n</li>\n<li><p>怎么让Chrome支持小于12px 的文字？</p>\n</li>\n<li><p>让页面里的字体变清晰，变细用CSS怎么做？（-webkit-font-smoothing: antialiased;）</p>\n</li>\n<li><p>font-style属性可以让它赋值为“oblique” oblique是什么意思？</p>\n</li>\n<li><p>position:fixed;在android下无效怎么处理？</p>\n</li>\n<li><p>如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>display:inline-block 什么时候会显示间隙？(携程)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>overflow: scroll时不能平滑滚动的问题怎么处理？</p>\n</li>\n<li><p>有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度。</p>\n</li>\n<li><p>png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？</p>\n</li>\n</ul>\n<ul>\n<li><p>什么是Cookie 隔离？（或者说：请求资源的时候不要让它带cookie怎么做）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，</span><br><span class=\"line\">所以不如隔离开。</span><br><span class=\"line\"></span><br><span class=\"line\">因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，</span><br><span class=\"line\">这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。</span><br><span class=\"line\"></span><br><span class=\"line\">同时这种方式不会将cookie传入Web Server，也减少了Web Server对cookie的处理分析环节，</span><br><span class=\"line\">提高了webserver的http请求的解析速度。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>style标签写在body后与body前有什么区别？</p>\n</li>\n<li><p>什么是CSS 预处理器 / 后处理器？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。</span><br><span class=\"line\"></span><br><span class=\"line\">- 后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a><a name=\"js\">JavaScript</a></h2><ul>\n<li><p>介绍js的基本数据类型。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Undefined、Null、Boolean、Number、String、Symbol(new in ECMAScript 2015)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>介绍js有哪些内置对象？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object 是 JavaScript 中所有对象的父对象</span><br><span class=\"line\"></span><br><span class=\"line\">数据封装类对象：Object、Array、Boolean、Number 和 String</span><br><span class=\"line\">其他对象：Function、Arguments、Math、Date、RegExp、Error</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>说几条写JavaScript的基本规范？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.不要在同一行声明多个变量。</span><br><span class=\"line\">2.请使用 ===/!==来比较true/false或者数值</span><br><span class=\"line\">3.使用对象字面量替代new Array这种形式</span><br><span class=\"line\">4.不要使用全局函数。</span><br><span class=\"line\">5.Switch语句必须带有default分支</span><br><span class=\"line\">6.函数不应该有时候有返回值，有时候没有返回值。</span><br><span class=\"line\">7.For循环必须使用大括号</span><br><span class=\"line\">8.If语句必须使用大括号</span><br><span class=\"line\">9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>JavaScript原型，原型链 ? 有什么特点？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，</span><br><span class=\"line\">如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，</span><br><span class=\"line\">于是就这样一直找下去，也就是我们平时所说的原型链的概念。</span><br><span class=\"line\">关系：instance.constructor.prototype = instance.__proto__</span><br><span class=\"line\"></span><br><span class=\"line\">特点：</span><br><span class=\"line\">JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"> 当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的话，</span><br><span class=\"line\"> 就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。</span><br><span class=\"line\">    function Func()&#123;&#125;</span><br><span class=\"line\">    Func.prototype.name = &quot;Sean&quot;;</span><br><span class=\"line\">    Func.prototype.getInfo = function() &#123;</span><br><span class=\"line\">      return this.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var person = new Func();//现在可以参考var person = Object.create(oldObject);</span><br><span class=\"line\">    console.log(person.getInfo());//它拥有了Func的属性和方法</span><br><span class=\"line\">    //&quot;Sean&quot;</span><br><span class=\"line\">    console.log(Func.prototype);</span><br><span class=\"line\">    // Func &#123; name=&quot;Sean&quot;, getInfo=function()&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>JavaScript有几种类型的值？，你能画一下他们的内存图吗？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">栈：原始数据类型（Undefined，Null，Boolean，Number、String） </span><br><span class=\"line\">堆：引用数据类型（对象、数组和函数）</span><br><span class=\"line\"></span><br><span class=\"line\">两种类型的区别是：存储位置不同；</span><br><span class=\"line\">原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</span><br><span class=\"line\">引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其</span><br><span class=\"line\">在栈中的地址，取得地址后从堆中获得实体</span><br><span class=\"line\">```        </span><br><span class=\"line\">![Stated Clearly Image](http://www.w3school.com.cn/i/ct_js_value.gif)</span><br><span class=\"line\"></span><br><span class=\"line\">-  Javascript如何实现继承？</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>1、构造继承<br>2、原型继承<br>3、实例继承<br>4、拷贝继承</p>\n<p>原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```javascript</span><br><span class=\"line\">function Parent()&#123;</span><br><span class=\"line\">    this.name = &apos;wang&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Child()&#123;</span><br><span class=\"line\">    this.age = 28;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Child.prototype = new Parent();//继承了Parent，通过原型</span><br><span class=\"line\"></span><br><span class=\"line\">var demo = new Child();</span><br><span class=\"line\">alert(demo.age);</span><br><span class=\"line\">alert(demo.name);//得到被继承的属性</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>JavaScript继承的几种实现方式？</p>\n<blockquote>\n<p>参考：<a href=\"http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html\" target=\"_blank\" rel=\"noopener\">构造函数的继承</a>，<a href=\"http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html\" target=\"_blank\" rel=\"noopener\">非构造函数的继承</a>；</p>\n</blockquote>\n</li>\n<li><p>javascript创建对象的几种方式？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用。</span><br><span class=\"line\"></span><br><span class=\"line\">1、对象字面量的方式   </span><br><span class=\"line\"></span><br><span class=\"line\">    person=&#123;firstname:&quot;Mark&quot;,lastname:&quot;Yun&quot;,age:25,eyecolor:&quot;black&quot;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">2、用function来模拟无参的构造函数</span><br><span class=\"line\"></span><br><span class=\"line\">    function Person()&#123;&#125;</span><br><span class=\"line\">    var person=new Person();//定义一个function，如果使用new&quot;实例化&quot;,该function可以看作是一个Class</span><br><span class=\"line\">    person.name=&quot;Mark&quot;;</span><br><span class=\"line\">    person.age=&quot;25&quot;;</span><br><span class=\"line\">    person.work=function()&#123;</span><br><span class=\"line\">    alert(person.name+&quot; hello...&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    person.work();</span><br><span class=\"line\"></span><br><span class=\"line\">3、用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）</span><br><span class=\"line\"></span><br><span class=\"line\">    function Pet(name,age,hobby)&#123;</span><br><span class=\"line\">       this.name=name;//this作用域：当前对象</span><br><span class=\"line\">       this.age=age;</span><br><span class=\"line\">       this.hobby=hobby;</span><br><span class=\"line\">       this.eat=function()&#123;</span><br><span class=\"line\">          alert(&quot;我叫&quot;+this.name+&quot;,我喜欢&quot;+this.hobby+&quot;,是个程序员&quot;);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var maidou =new Pet(&quot;麦兜&quot;,25,&quot;coding&quot;);//实例化、创建对象</span><br><span class=\"line\">    maidou.eat();//调用eat方法</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">4、用工厂方式来创建（内置对象）</span><br><span class=\"line\"></span><br><span class=\"line\">     var wcDog =new Object();</span><br><span class=\"line\">     wcDog.name=&quot;旺财&quot;;</span><br><span class=\"line\">     wcDog.age=3;</span><br><span class=\"line\">     wcDog.work=function()&#123;</span><br><span class=\"line\">       alert(&quot;我是&quot;+wcDog.name+&quot;,汪汪汪......&quot;);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     wcDog.work();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">5、用原型方式来创建</span><br><span class=\"line\"></span><br><span class=\"line\">    function Dog()&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     Dog.prototype.name=&quot;旺财&quot;;</span><br><span class=\"line\">     Dog.prototype.eat=function()&#123;</span><br><span class=\"line\">     alert(this.name+&quot;是个吃货&quot;);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     var wangcai =new Dog();</span><br><span class=\"line\">     wangcai.eat();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">5、用混合方式来创建</span><br><span class=\"line\"></span><br><span class=\"line\">    function Car(name,price)&#123;</span><br><span class=\"line\">      this.name=name;</span><br><span class=\"line\">      this.price=price; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     Car.prototype.sell=function()&#123;</span><br><span class=\"line\">       alert(&quot;我是&quot;+this.name+&quot;，我现在卖&quot;+this.price+&quot;万元&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    var camry =new Car(&quot;凯美瑞&quot;,27);</span><br><span class=\"line\">    camry.sell();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Javascript作用链域?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。</span><br><span class=\"line\">当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，</span><br><span class=\"line\">直至全局函数，这种组织形式就是作用域链。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>谈谈This对象的理解。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* this总是指向函数的直接调用者（而非间接调用者）；</span><br><span class=\"line\">* 如果有new关键字，this指向new出来的那个对象；</span><br><span class=\"line\">* 在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window；</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>eval是做什么的？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">它的功能是把对应的字符串解析成JS代码并运行；</span><br><span class=\"line\">应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。</span><br><span class=\"line\">由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(&apos;(&apos;+ str +&apos;)&apos;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>什么是window对象? 什么是document对象?</p>\n</li>\n</ul>\n<ul>\n<li>null，undefined 的区别？<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ull，undefined 的区别？</span><br><span class=\"line\">null        表示一个对象被定义了，值为“空值”；</span><br><span class=\"line\">undefined   表示不存在这个值。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof undefined</span><br><span class=\"line\">    //&quot;undefined&quot;</span><br><span class=\"line\">    undefined :是一个表示&quot;无&quot;的原始值或者说表示&quot;缺少值&quot;，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined； </span><br><span class=\"line\">    例如变量被声明了，但没有赋值时，就等于undefined</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof null  //&quot;object&quot;</span><br><span class=\"line\">    null : 是一个对象(空对象, 没有任何属性和方法)；</span><br><span class=\"line\">    例如作为函数的参数，表示该函数的参数不是对象；</span><br></pre></td></tr></table></figure>\n<p>注意：<br>    在验证null时，一定要使用　=== ，因为 == 无法分别 null 和　undefined</p>\n<p>再来一个例子：<br>  null<br>  Q：有张三这个人么？<br>  A：有！<br>  Q：张三有房子么？<br>  A：没有！</p>\n<p>  undefined<br>  Q：有张三这个人么？<br>  A：没有！ </p>\n<blockquote>\n<p>参考阅读：<a href=\"http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html\" target=\"_blank\" rel=\"noopener\">undefined与null的区别</a></p>\n</blockquote>\n<ul>\n<li><p>写一个通用的事件侦听器函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// event(事件)工具集，来源：github.com/markyun</span><br><span class=\"line\">markyun.Event = &#123;</span><br><span class=\"line\">    // 页面加载完成后</span><br><span class=\"line\">    readyEvent : function(fn) &#123;</span><br><span class=\"line\">        if (fn==null) &#123;</span><br><span class=\"line\">            fn=document;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        var oldonload = window.onload;</span><br><span class=\"line\">        if (typeof window.onload != &apos;function&apos;) &#123;</span><br><span class=\"line\">            window.onload = fn;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            window.onload = function() &#123;</span><br><span class=\"line\">                oldonload();</span><br><span class=\"line\">                fn();</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 视能力分别使用dom0||dom2||IE方式 来绑定事件</span><br><span class=\"line\">    // 参数： 操作的元素,事件名称 ,事件处理程序</span><br><span class=\"line\">    addEvent : function(element, type, handler) &#123;</span><br><span class=\"line\">        if (element.addEventListener) &#123;</span><br><span class=\"line\">            //事件类型、需要执行的函数、是否捕捉</span><br><span class=\"line\">            element.addEventListener(type, handler, false);</span><br><span class=\"line\">        &#125; else if (element.attachEvent) &#123;</span><br><span class=\"line\">            element.attachEvent(&apos;on&apos; + type, function() &#123;</span><br><span class=\"line\">                handler.call(element);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            element[&apos;on&apos; + type] = handler;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 移除事件</span><br><span class=\"line\">    removeEvent : function(element, type, handler) &#123;</span><br><span class=\"line\">        if (element.removeEventListener) &#123;</span><br><span class=\"line\">            element.removeEventListener(type, handler, false);</span><br><span class=\"line\">        &#125; else if (element.datachEvent) &#123;</span><br><span class=\"line\">            element.detachEvent(&apos;on&apos; + type, handler);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            element[&apos;on&apos; + type] = null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)</span><br><span class=\"line\">    stopPropagation : function(ev) &#123;</span><br><span class=\"line\">        if (ev.stopPropagation) &#123;</span><br><span class=\"line\">            ev.stopPropagation();</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            ev.cancelBubble = true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 取消事件的默认行为</span><br><span class=\"line\">    preventDefault : function(event) &#123;</span><br><span class=\"line\">        if (event.preventDefault) &#123;</span><br><span class=\"line\">            event.preventDefault();</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            event.returnValue = false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 获取事件目标</span><br><span class=\"line\">    getTarget : function(event) &#123;</span><br><span class=\"line\">        return event.target || event.srcElement;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 获取event对象的引用，取到事件的所有信息，确保随时能使用event；</span><br><span class=\"line\">    getEvent : function(e) &#123;</span><br><span class=\"line\">        var ev = e || window.event;</span><br><span class=\"line\">        if (!ev) &#123;</span><br><span class=\"line\">            var c = this.getEvent.caller;</span><br><span class=\"line\">            while (c) &#123;</span><br><span class=\"line\">                ev = c.arguments[0];</span><br><span class=\"line\">                if (ev &amp;&amp; Event == ev.constructor) &#123;</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                c = c.caller;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>[“1”, “2”, “3”].map(parseInt) 答案是多少？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, NaN, NaN] 因为 parseInt 需要两个参数 (val, radix)，</span><br><span class=\"line\">其中 radix 表示解析时用的基数。</span><br><span class=\"line\">map 传了 3 个 (element, index, array)，对应的 radix 不合法导致解析失败。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>事件是？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。</span><br><span class=\"line\">2. 事件处理机制：IE是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件；</span><br><span class=\"line\">3. ev.stopPropagation();（旧ie的方法 ev.cancelBubble = true;）</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>什么是闭包（closure），为什么要用它？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。</span><br><span class=\"line\"></span><br><span class=\"line\">闭包的特性：</span><br><span class=\"line\"></span><br><span class=\"line\">1.函数内再嵌套函数</span><br><span class=\"line\">2.内部函数可以引用外层的参数和变量</span><br><span class=\"line\">3.参数和变量不会被垃圾回收机制回收</span><br><span class=\"line\"></span><br><span class=\"line\">//li节点的onclick事件都能正确的弹出当前被点击的li索引</span><br><span class=\"line\"> &lt;ul id=&quot;testUL&quot;&gt;</span><br><span class=\"line\">    &lt;li&gt; index = 0&lt;/li&gt;</span><br><span class=\"line\">    &lt;li&gt; index = 1&lt;/li&gt;</span><br><span class=\"line\">    &lt;li&gt; index = 2&lt;/li&gt;</span><br><span class=\"line\">    &lt;li&gt; index = 3&lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">    var nodes = document.getElementsByTagName(&quot;li&quot;);</span><br><span class=\"line\">    for(i = 0;i&lt;nodes.length;i+= 1)&#123;</span><br><span class=\"line\">        nodes[i].onclick = function()&#123;</span><br><span class=\"line\">            console.log(i+1);//不用闭包的话，值每次都是4</span><br><span class=\"line\">        &#125;(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">执行say667()后,say667()闭包内部变量会存在,而闭包内部函数的内部变量不会存在</span><br><span class=\"line\">使得Javascript的垃圾回收机制GC不会收回say667()所占用的资源</span><br><span class=\"line\">因为say667()的内部函数的执行需要依赖say667()中的变量</span><br><span class=\"line\">这是对闭包作用的非常直白的描述</span><br><span class=\"line\"></span><br><span class=\"line\">  function say667() &#123;</span><br><span class=\"line\">    // Local variable that ends up within closure</span><br><span class=\"line\">    var num = 666;</span><br><span class=\"line\">    var sayAlert = function() &#123;</span><br><span class=\"line\">        alert(num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    num++;</span><br><span class=\"line\">    return sayAlert;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> var sayAlert = say667();</span><br><span class=\"line\"> sayAlert()//执行结果应该弹出的667</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,</span><br><span class=\"line\"></span><br><span class=\"line\">使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。</span><br><span class=\"line\">默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值;</span><br><span class=\"line\">全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数,arguments.callee也不允许使用；</span><br><span class=\"line\">消除代码运行的一些不安全之处，保证代码运行的安全,限制函数中的arguments修改，严格模式下的eval函数的行为和非严格模式的也不相同;</span><br><span class=\"line\"></span><br><span class=\"line\">提高编译器效率，增加运行速度；</span><br><span class=\"line\">为未来新版本的Javascript标准化做铺垫。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如何判断一个对象是否属于某个类？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用instanceof （待完善）</span><br><span class=\"line\"> if(a instanceof Person)&#123;</span><br><span class=\"line\">     alert(&apos;yes&apos;);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>new操作符具体干了什么呢?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</span><br><span class=\"line\">   2、属性和方法被加入到 this 引用的对象中。</span><br><span class=\"line\">   3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。</span><br><span class=\"line\"></span><br><span class=\"line\">var obj  = &#123;&#125;;</span><br><span class=\"line\">obj.__proto__ = Base.prototype;</span><br><span class=\"line\">Base.call(obj);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用原生JavaScript的实现过什么功能吗？</p>\n</li>\n</ul>\n<ul>\n<li><p>Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hasOwnProperty</span><br><span class=\"line\"></span><br><span class=\"line\">javaScript中hasOwnProperty函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员。</span><br><span class=\"line\">使用方法：</span><br><span class=\"line\">object.hasOwnProperty(proName)</span><br><span class=\"line\">其中参数object是必选项。一个对象的实例。</span><br><span class=\"line\">proName是必选项。一个属性名称的字符串值。</span><br><span class=\"line\"></span><br><span class=\"line\">如果 object 具有指定名称的属性，那么JavaScript中hasOwnProperty函数方法返回 true，反之则返回 false。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>JSON 的了解？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。</span><br><span class=\"line\">它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小</span><br><span class=\"line\">如：&#123;&quot;age&quot;:&quot;12&quot;, &quot;name&quot;:&quot;back&quot;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">JSON字符串转换为JSON对象:</span><br><span class=\"line\">var obj =eval(&apos;(&apos;+ str +&apos;)&apos;);</span><br><span class=\"line\">var obj = str.parseJSON();</span><br><span class=\"line\">var obj = JSON.parse(str);</span><br><span class=\"line\"></span><br><span class=\"line\">JSON对象转换为JSON字符串：</span><br><span class=\"line\">var last=obj.toJSONString();</span><br><span class=\"line\">var last=JSON.stringify(obj);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>[].forEach.call($$(&quot;*&quot;),function(a){a.style.outline=&quot;1px solid #&quot;+(~~(Math.random()*(1&lt;&lt;24))).toString(16)})</code> 能解释一下这段代码的意思吗？</p>\n</li>\n</ul>\n<ul>\n<li><p>js延迟加载的方式有哪些？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">defer和async、动态创建DOM方式（用得最多）、按需异步载入js</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Ajax 是什么? 如何创建一个Ajax？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ajax的全称：Asynchronous Javascript And XML。</span><br><span class=\"line\">异步传输+js+xml。</span><br><span class=\"line\">所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。</span><br><span class=\"line\"></span><br><span class=\"line\">(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象</span><br><span class=\"line\">(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息</span><br><span class=\"line\">(3)设置响应HTTP请求状态变化的函数</span><br><span class=\"line\">(4)发送HTTP请求</span><br><span class=\"line\">(5)获取异步调用返回的数据</span><br><span class=\"line\">(6)使用JavaScript和DOM实现局部刷新</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>同步和异步的区别?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">同步的概念应该是来自于OS中关于同步的概念:不同进程为协同完成某项工作而在先后次序上调整(通过阻塞,唤醒等方式).同步强调的是顺序性.谁先谁后.异步则不存在这种顺序性.</span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作。</span><br><span class=\"line\"></span><br><span class=\"line\">异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。</span><br><span class=\"line\"></span><br><span class=\"line\">（待完善）</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如何解决跨域问题?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>页面编码和被请求的资源编码如果不一致如何处理？</p>\n</li>\n<li><p>模块化开发怎么做？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ 立即执行函数](http://benalman.com/news/2010/11/immediately-invoked-function-expression/),不暴露私有成员</span><br><span class=\"line\"></span><br><span class=\"line\">var module1 = (function()&#123;</span><br><span class=\"line\">　　　　var _count = 0;</span><br><span class=\"line\">　　　　var m1 = function()&#123;</span><br><span class=\"line\">　　　　　　//...</span><br><span class=\"line\">　　　　&#125;;</span><br><span class=\"line\">　　　　var m2 = function()&#123;</span><br><span class=\"line\">　　　　　　//...</span><br><span class=\"line\">　　　　&#125;;</span><br><span class=\"line\">　　　　return &#123;</span><br><span class=\"line\">　　　　　　m1 : m1,</span><br><span class=\"line\">　　　　　　m2 : m2</span><br><span class=\"line\">　　　　&#125;;</span><br><span class=\"line\">　　&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">（待完善）</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; AMD 规范在这里：https://github.com/amdjs/amdjs-api/wiki/AMD</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; CMD 规范在这里：https://github.com/seajs/seajs/issues/242</span><br><span class=\"line\"></span><br><span class=\"line\">Asynchronous Module Definition，异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中。</span><br><span class=\"line\"></span><br><span class=\"line\"> 区别：</span><br><span class=\"line\"></span><br><span class=\"line\">    1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.</span><br><span class=\"line\">    2. CMD 推崇依赖就近，AMD 推崇依赖前置。看代码：</span><br><span class=\"line\"></span><br><span class=\"line\">// CMD</span><br><span class=\"line\">define(function(require, exports, module) &#123;</span><br><span class=\"line\">    var a = require(&apos;./a&apos;)</span><br><span class=\"line\">    a.doSomething()</span><br><span class=\"line\">    // 此处略去 100 行</span><br><span class=\"line\">    var b = require(&apos;./b&apos;) // 依赖可以就近书写</span><br><span class=\"line\">    b.doSomething()</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// AMD 默认推荐</span><br><span class=\"line\">define([&apos;./a&apos;, &apos;./b&apos;], function(a, b) &#123; // 依赖必须一开始就写好</span><br><span class=\"line\">    a.doSomething()</span><br><span class=\"line\">    // 此处略去 100 行</span><br><span class=\"line\">    b.doSomething()</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何<br>缓存的？）</p>\n</li>\n<li><p>谈一谈你对ECMAScript6的了解？</p>\n</li>\n<li><p>ECMAScript6 怎么写class么，为什么会出现class这种东西? </p>\n</li>\n<li><p>异步加载JS的方式有哪些？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(1) defer，只支持IE</span><br><span class=\"line\"></span><br><span class=\"line\">(2) async：</span><br><span class=\"line\"></span><br><span class=\"line\">(3) 创建script，插入到DOM中，加载完毕后callBack</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>documen.write和 innerHTML的区别</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.write只能重绘整个页面</span><br><span class=\"line\"></span><br><span class=\"line\">innerHTML可以重绘页面的一部分</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>DOM操作——怎样添加、移除、移动、复制、创建和查找节点?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）创建新节点</span><br><span class=\"line\">createDocumentFragment()    //创建一个DOM片段</span><br><span class=\"line\">createElement()   //创建一个具体的元素</span><br><span class=\"line\">createTextNode()   //创建一个文本节点</span><br><span class=\"line\">（2）添加、移除、替换、插入</span><br><span class=\"line\">appendChild()</span><br><span class=\"line\">removeChild()</span><br><span class=\"line\">replaceChild()</span><br><span class=\"line\">insertBefore() //在已有的子节点前插入一个新的子节点</span><br><span class=\"line\">（3）查找</span><br><span class=\"line\">getElementsByTagName()    //通过标签名称</span><br><span class=\"line\">getElementsByName()    //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)</span><br><span class=\"line\">getElementById()    //通过元素Id，唯一性</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>.call() 和 .apply() 的区别？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例子中用 add 来替换 sub，add.call(sub,3,1) == add(3,1) ，所以运行结果为：alert(4);</span><br><span class=\"line\"></span><br><span class=\"line\">注意：js 中的函数其实是对象，函数名是对 Function 对象的引用。</span><br><span class=\"line\"></span><br><span class=\"line\">  function add(a,b)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      alert(a+b);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  function sub(a,b)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      alert(a-b);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  add.call(sub,3,1);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>数组和对象有哪些原生方法，列举一下？</p>\n</li>\n<li><p>JS 怎么实现一个类。怎么实例化这个类</p>\n</li>\n<li><p>JavaScript中的作用域与变量声明提升？</p>\n</li>\n<li><p>如何编写高性能的Javascript？</p>\n</li>\n<li><p>那些操作会造成内存泄漏？</p>\n</li>\n<li><p>JQuery的源码看过吗？能不能简单概况一下它的实现原理？</p>\n</li>\n<li><p>jQuery.fn的init方法返回的this指的是什么对象？为什么要返回this？</p>\n</li>\n<li><p>jquery中如何将数组转化为json字符串，然后再转化回来？</p>\n</li>\n<li><p>jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？ </p>\n</li>\n<li><p>jquery.extend 与 jquery.fn.extend的区别？</p>\n</li>\n<li><p>jQuery 的队列是如何实现的？队列可以用在哪些地方？</p>\n</li>\n<li><p>谈一下Jquery中的bind(),live(),delegate(),on()的区别？</p>\n</li>\n<li><p>JQuery一个对象可以同时绑定多个事件，这是如何实现的？</p>\n</li>\n<li><p>是否知道自定义事件。jQuery里的fire函数是什么意思，什么时候用？</p>\n</li>\n<li><p>jQuery 是通过哪个方法和 Sizzle 选择器结合的？（jQuery.fn.find()进入Sizzle）</p>\n</li>\n<li><p>针对 jQuery性能的优化方法？</p>\n</li>\n<li><p>Jquery与jQuery UI 有啥区别？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*jQuery是一个js库，主要提供的功能是选择器，属性修改和事件绑定等等。</span><br><span class=\"line\"></span><br><span class=\"line\">*jQuery UI则是在jQuery的基础上，利用jQuery的扩展性，设计的插件。</span><br><span class=\"line\"> 提供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>JQuery的源码看过吗？能不能简单说一下它的实现原理？</p>\n</li>\n<li><p>jquery 中如何将数组转化为json字符串，然后再转化回来？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jQuery中没有提供这个功能，所以你需要先编写两个jQuery的扩展：</span><br><span class=\"line\"></span><br><span class=\"line\">$.fn.stringifyArray = function(array) &#123;</span><br><span class=\"line\">    return JSON.stringify(array)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$.fn.parseArray = function(array) &#123;</span><br><span class=\"line\">    return JSON.parse(array)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">然后调用：</span><br><span class=\"line\">$(&quot;&quot;).stringifyArray(array)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>jQuery和Zepto的区别？各自的使用场景？</p>\n</li>\n<li><p>针对 jQuery 的优化方法？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*基于Class的选择性的性能相对于Id选择器开销很大，因为需遍历所有DOM元素。</span><br><span class=\"line\"></span><br><span class=\"line\">*频繁操作的DOM，先缓存起来再操作。用Jquery的链式调用更好。</span><br><span class=\"line\"> 比如：var str=$(&quot;a&quot;).attr(&quot;href&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">*for (var i = size; i &lt; arr.length; i++) &#123;&#125;</span><br><span class=\"line\"> for 循环每一次循环都查找了数组 (arr) 的.length 属性，在开始循环的时候设置一个变量来存储这个数字，可以让循环跑得更快：</span><br><span class=\"line\"> for (var i = size, length = arr.length; i &lt; length; i++) &#123;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Zepto的点透问题如何解决？</p>\n</li>\n<li><p>jQueryUI如何自定义组件?</p>\n</li>\n<li><p>需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？</p>\n</li>\n<li><p>如何判断当前脚本运行在浏览器还是node环境中？（阿里）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>移动端最小触控区域是多大？</p>\n</li>\n<li><p>jQuery 的 slideUp动画 ，如果目标元素是被外部事件驱动, 当鼠标快速地连续触发外部元素事件, 动画会滞后的反复执行，该如何处理呢?</p>\n</li>\n<li><p>把 Script 标签 放在页面的最底部的body封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？</p>\n</li>\n<li><p>移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？（click 有 300ms 延迟,为了实现safari的双击事件的设计，浏览器要知道你是不是要双击操作。）</p>\n</li>\n<li><p>知道各种JS框架(Angular, Backbone, Ember, React, Meteor, Knockout…)么? 能讲出他们各自的优点和缺点么?</p>\n</li>\n<li><p>Underscore 对哪些 JS 原生对象进行了扩展以及提供了哪些好用的函数方法？</p>\n</li>\n<li><p>解释JavaScript中的作用域与变量声明提升？</p>\n</li>\n<li><p>那些操作会造成内存泄漏？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。</span><br><span class=\"line\">垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。</span><br><span class=\"line\">闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>JQuery一个对象可以同时绑定多个事件，这是如何实现的？</p>\n</li>\n<li><p>Node.js的适用场景？</p>\n</li>\n<li><p>(如果会用node)知道route, middleware, cluster, nodemon, pm2, server-side rendering么?</p>\n</li>\n<li><p>解释一下 Backbone 的 MVC 实现方式？</p>\n</li>\n<li><p>什么是“前端路由”?什么时候适合使用“前端路由”? “前端路由”有哪些优点和缺点?</p>\n</li>\n<li><p>知道什么是webkit么? 知道怎么用浏览器的各种工具来调试和debug代码么?</p>\n</li>\n<li><p>如何测试前端代码么? 知道BDD, TDD, Unit Test么? 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)?</p>\n</li>\n<li><p>前端templating(Mustache, underscore, handlebars)是干嘛的, 怎么用?</p>\n</li>\n<li><p>简述一下 Handlebars 的基本用法？</p>\n</li>\n<li><p>简述一下 Handlerbars 的对模板的基本处理流程， 如何编译的？如何缓存的？</p>\n</li>\n<li><p>用js实现千位分隔符?(来源：<a href=\"http://div.io/topic/744\" target=\"_blank\" rel=\"noopener\">前端农民工</a>，提示：正则+replace)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function commafy(num) &#123;</span><br><span class=\"line\">     num = num + &apos;&apos;;</span><br><span class=\"line\">     var reg = /(-?d+)(d&#123;3&#125;)/;</span><br><span class=\"line\">    </span><br><span class=\"line\">    if(reg.test(num))&#123;</span><br><span class=\"line\">     num = num.replace(reg, &apos;$1,$2&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return num;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>检测浏览器版本版本有哪些方式？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">功能检测、userAgent特征检测</span><br><span class=\"line\"></span><br><span class=\"line\">比如：navigator.userAgent</span><br><span class=\"line\">//&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36</span><br><span class=\"line\">  (KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>What is a Polyfill? </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">polyfill 是“在旧版浏览器上复制标准 API 的 JavaScript 补充”,可以动态地加载 JavaScript 代码或库，在不支持这些标准 API 的浏览器中模拟它们。</span><br><span class=\"line\">例如，geolocation（地理位置）polyfill 可以在 navigator 对象上添加全局的 geolocation 对象，还能添加 getCurrentPosition 函数以及“坐标”回调对象，</span><br><span class=\"line\">所有这些都是 W3C 地理位置 API 定义的对象和函数。因为 polyfill 模拟标准 API，所以能够以一种面向所有浏览器未来的方式针对这些 API 进行开发，</span><br><span class=\"line\">一旦对这些 API 的支持变成绝对大多数，则可以方便地去掉 polyfill，无需做任何额外工作。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>做的项目中，有没有用过或自己实现一些 polyfill 方案（兼容性处理方案）？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">比如： html5shiv、Geolocation、Placeholder</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？</p>\n</li>\n</ul>\n<h4 id=\"ECMAScript6-相关\"><a href=\"#ECMAScript6-相关\" class=\"headerlink\" title=\"ECMAScript6 相关\"></a><a name=\"other\">ECMAScript6 相关</a></h4><ul>\n<li>Object.is() 与原来的比较操作符“ ===”、“ ==”的区别？ <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">两等号判等，会在比较时进行类型转换；</span><br><span class=\"line\">三等号判等(判断严格)，比较时不进行隐式类型转换,（类型不同则会返回false）； </span><br><span class=\"line\"></span><br><span class=\"line\">Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，</span><br><span class=\"line\">但 Object.is(NaN, NaN) 会返回 true.</span><br><span class=\"line\"></span><br><span class=\"line\">Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"前端框架相关\"><a href=\"#前端框架相关\" class=\"headerlink\" title=\"前端框架相关\"></a><a name=\"other\">前端框架相关</a></h4><ul>\n<li><p>react-router 路由系统的实现原理？</p>\n</li>\n<li><p>React中如何解决第三方类库的问题?</p>\n</li>\n</ul>\n<h2 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a><a name=\"other\">其他问题</a></h2><ul>\n<li><p>原来公司工作流程是怎么样的，如何与其他人协作的？如何夸部门合作的？</p>\n</li>\n<li><p>你遇到过比较难的技术问题是？你是如何解决的？</p>\n</li>\n<li><p>设计模式 知道什么是singleton, factory, strategy, decrator么?</p>\n</li>\n<li><p>常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？</p>\n</li>\n<li><p>页面重构怎么操作？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。</span><br><span class=\"line\">也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。</span><br><span class=\"line\"></span><br><span class=\"line\">对于传统的网站来说重构通常是：</span><br><span class=\"line\"></span><br><span class=\"line\">表格(table)布局改为DIV+CSS</span><br><span class=\"line\">使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)</span><br><span class=\"line\">对于移动平台的优化</span><br><span class=\"line\">针对于SEO进行优化</span><br><span class=\"line\">深层次的网站重构应该考虑的方面</span><br><span class=\"line\"></span><br><span class=\"line\">减少代码间的耦合</span><br><span class=\"line\">让代码保持弹性</span><br><span class=\"line\">严格按规范编写代码</span><br><span class=\"line\">设计可扩展的API</span><br><span class=\"line\">代替旧有的框架、语言(如VB)</span><br><span class=\"line\">增强用户体验</span><br><span class=\"line\">通常来说对于速度的优化也包含在重构中</span><br><span class=\"line\"></span><br><span class=\"line\">压缩JS、CSS、image等前端资源(通常是由服务器来解决)</span><br><span class=\"line\">程序的性能优化(如数据读写)</span><br><span class=\"line\">采用CDN来加速资源加载</span><br><span class=\"line\">对于JS DOM的优化</span><br><span class=\"line\">HTTP服务器的文件缓存</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>列举IE与其他浏览器不一样的特性？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、事件不同之处：</span><br><span class=\"line\"></span><br><span class=\"line\">触发事件的元素被认为是目标（target）。而在 IE 中，目标包含在 event 对象的 srcElement 属性；</span><br><span class=\"line\"></span><br><span class=\"line\">获取字符代码、如果按键代表一个字符（shift、ctrl、alt除外），IE 的 keyCode 会返回字符代码（Unicode），DOM 中按键的代码和字符是分离的，要获取字符代码，需要使用 charCode 属性；</span><br><span class=\"line\"></span><br><span class=\"line\">阻止某个事件的默认行为，IE 中阻止某个事件的默认行为，必须将 returnValue 属性设置为 false，Mozilla 中，需要调用 preventDefault() 方法；</span><br><span class=\"line\"></span><br><span class=\"line\">停止事件冒泡，IE 中阻止事件进一步冒泡，需要设置 cancelBubble 为 true，Mozzilla 中，需要调用 stopPropagation()；</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>99%的网站都需要被重构是那本书上写的？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">网站重构：应用web标准进行设计（第2版）</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>什么叫优雅降级和渐进增强？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。</span><br><span class=\"line\">如：border-shadow</span><br><span class=\"line\"></span><br><span class=\"line\">渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。</span><br><span class=\"line\">如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验；</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>是否了解公钥加密和私钥加密。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一般情况下是指私钥用于对数据进行签名，公钥用于对签名进行验证;</span><br><span class=\"line\">HTTP网站在浏览器端用公钥加密敏感数据，然后在服务器端再用私钥解密。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>WEB应用从服务器主动推送Data到客户端有那些方式？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html5提供的Websocket</span><br><span class=\"line\">不可见的iframe</span><br><span class=\"line\">WebSocket通过Flash</span><br><span class=\"line\">XHR长时间连接</span><br><span class=\"line\">XHR Multipart Streaming</span><br><span class=\"line\">&lt;script&gt;标签的长时间连接(可跨域)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对Node的优点和缺点提出了自己的看法？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，</span><br><span class=\"line\">  因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。</span><br><span class=\"line\">  此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，</span><br><span class=\"line\">  因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。</span><br><span class=\"line\"></span><br><span class=\"line\">*（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，</span><br><span class=\"line\">  而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>你有用过哪些前端性能优化的方法？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。</span><br><span class=\"line\"></span><br><span class=\"line\">（2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数</span><br><span class=\"line\"></span><br><span class=\"line\">（3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。</span><br><span class=\"line\"></span><br><span class=\"line\">（4） 当需要设置的样式很多时设置className而不是直接操作style。</span><br><span class=\"line\"></span><br><span class=\"line\">（5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。</span><br><span class=\"line\"></span><br><span class=\"line\">（6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。</span><br><span class=\"line\"></span><br><span class=\"line\">（7） 图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。</span><br><span class=\"line\"></span><br><span class=\"line\">（8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。</span><br><span class=\"line\">对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>http状态码有那些？分别代表是什么意思？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">简单版</span><br><span class=\"line\">[</span><br><span class=\"line\">    100  Continue   继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</span><br><span class=\"line\">    200  OK         正常返回信息</span><br><span class=\"line\">    201  Created    请求成功并且服务器创建了新的资源</span><br><span class=\"line\">    202  Accepted   服务器已接受请求，但尚未处理</span><br><span class=\"line\">    301  Moved Permanently  请求的网页已永久移动到新位置。</span><br><span class=\"line\">    302 Found       临时性重定向。</span><br><span class=\"line\">    303 See Other   临时性重定向，且总是使用 GET 请求新的 URI。</span><br><span class=\"line\">    304  Not Modified 自从上次请求后，请求的网页未修改过。</span><br><span class=\"line\"></span><br><span class=\"line\">    400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</span><br><span class=\"line\">    401 Unauthorized 请求未授权。</span><br><span class=\"line\">    403 Forbidden   禁止访问。</span><br><span class=\"line\">    404 Not Found   找不到如何与 URI 相匹配的资源。</span><br><span class=\"line\"></span><br><span class=\"line\">    500 Internal Server Error  最常见的服务器端错误。</span><br><span class=\"line\">    503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">完整版</span><br><span class=\"line\">1**(信息类)：表示接收到请求并且继续处理</span><br><span class=\"line\">100——客户必须继续发出请求</span><br><span class=\"line\">101——客户要求服务器根据请求转换HTTP协议版本</span><br><span class=\"line\"></span><br><span class=\"line\">2**(响应成功)：表示动作被成功接收、理解和接受</span><br><span class=\"line\">200——表明该请求被成功地完成，所请求的资源发送回客户端</span><br><span class=\"line\">201——提示知道新文件的URL</span><br><span class=\"line\">202——接受和处理、但处理未完成</span><br><span class=\"line\">203——返回信息不确定或不完整</span><br><span class=\"line\">204——请求收到，但返回信息为空</span><br><span class=\"line\">205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件</span><br><span class=\"line\">206——服务器已经完成了部分用户的GET请求</span><br><span class=\"line\"></span><br><span class=\"line\">3**(重定向类)：为了完成指定的动作，必须接受进一步处理</span><br><span class=\"line\">300——请求的资源可在多处得到</span><br><span class=\"line\">301——本网页被永久性转移到另一个URL</span><br><span class=\"line\">302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。</span><br><span class=\"line\">303——建议客户访问其他URL或访问方式</span><br><span class=\"line\">304——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用</span><br><span class=\"line\">305——请求的资源必须从服务器指定的地址得到</span><br><span class=\"line\">306——前一版本HTTP中使用的代码，现行版本中不再使用</span><br><span class=\"line\">307——申明请求的资源临时性删除</span><br><span class=\"line\"></span><br><span class=\"line\">4**(客户端错误类)：请求包含错误语法或不能正确执行</span><br><span class=\"line\">400——客户端请求有语法错误，不能被服务器所理解</span><br><span class=\"line\">401——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</span><br><span class=\"line\">HTTP 401.1 - 未授权：登录失败</span><br><span class=\"line\">　　HTTP 401.2 - 未授权：服务器配置问题导致登录失败</span><br><span class=\"line\">　　HTTP 401.3 - ACL 禁止访问资源</span><br><span class=\"line\">　　HTTP 401.4 - 未授权：授权被筛选器拒绝</span><br><span class=\"line\">HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败</span><br><span class=\"line\">402——保留有效ChargeTo头响应</span><br><span class=\"line\">403——禁止访问，服务器收到请求，但是拒绝提供服务</span><br><span class=\"line\">HTTP 403.1 禁止访问：禁止可执行访问</span><br><span class=\"line\">　　HTTP 403.2 - 禁止访问：禁止读访问</span><br><span class=\"line\">　　HTTP 403.3 - 禁止访问：禁止写访问</span><br><span class=\"line\">　　HTTP 403.4 - 禁止访问：要求 SSL</span><br><span class=\"line\">　　HTTP 403.5 - 禁止访问：要求 SSL 128</span><br><span class=\"line\">　　HTTP 403.6 - 禁止访问：IP 地址被拒绝</span><br><span class=\"line\">　　HTTP 403.7 - 禁止访问：要求客户证书</span><br><span class=\"line\">　　HTTP 403.8 - 禁止访问：禁止站点访问</span><br><span class=\"line\">　　HTTP 403.9 - 禁止访问：连接的用户过多</span><br><span class=\"line\">　　HTTP 403.10 - 禁止访问：配置无效</span><br><span class=\"line\">　　HTTP 403.11 - 禁止访问：密码更改</span><br><span class=\"line\">　　HTTP 403.12 - 禁止访问：映射器拒绝访问</span><br><span class=\"line\">　　HTTP 403.13 - 禁止访问：客户证书已被吊销</span><br><span class=\"line\">　　HTTP 403.15 - 禁止访问：客户访问许可过多</span><br><span class=\"line\">　　HTTP 403.16 - 禁止访问：客户证书不可信或者无效</span><br><span class=\"line\">HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效</span><br><span class=\"line\">404——一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL</span><br><span class=\"line\">405——用户在Request-Line字段定义的方法不允许</span><br><span class=\"line\">406——根据用户发送的Accept拖，请求资源不可访问</span><br><span class=\"line\">407——类似401，用户必须首先在代理服务器上得到授权</span><br><span class=\"line\">408——客户端没有在用户指定的饿时间内完成请求</span><br><span class=\"line\">409——对当前资源状态，请求不能完成</span><br><span class=\"line\">410——服务器上不再有此资源且无进一步的参考地址</span><br><span class=\"line\">411——服务器拒绝用户定义的Content-Length属性请求</span><br><span class=\"line\">412——一个或多个请求头字段在当前请求中错误</span><br><span class=\"line\">413——请求的资源大于服务器允许的大小</span><br><span class=\"line\">414——请求的资源URL长于服务器允许的长度</span><br><span class=\"line\">415——请求资源不支持请求项目格式</span><br><span class=\"line\">416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段</span><br><span class=\"line\">417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。</span><br><span class=\"line\"></span><br><span class=\"line\">5**(服务端错误类)：服务器不能正确执行一个正确的请求</span><br><span class=\"line\">HTTP 500 - 服务器遇到错误，无法完成请求</span><br><span class=\"line\">　　HTTP 500.100 - 内部服务器错误 - ASP 错误</span><br><span class=\"line\">　　HTTP 500-11 服务器关闭</span><br><span class=\"line\">　　HTTP 500-12 应用程序重新启动</span><br><span class=\"line\">　　HTTP 500-13 - 服务器太忙</span><br><span class=\"line\">　　HTTP 500-14 - 应用程序无效</span><br><span class=\"line\">　　HTTP 500-15 - 不允许请求 global.asa</span><br><span class=\"line\">　　Error 501 - 未实现</span><br><span class=\"line\">HTTP 502 - 网关错误</span><br><span class=\"line\">HTTP 503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常</span><br><span class=\"line\"></span><br><span class=\"line\">- 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）</span><br><span class=\"line\"></span><br><span class=\"line\">注：这题胜在区分度高，知识点覆盖广，再不懂的人，也能答出几句，</span><br><span class=\"line\">而高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、</span><br><span class=\"line\">到浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JS API绑定等等；</span><br><span class=\"line\"></span><br><span class=\"line\">详细版：</span><br><span class=\"line\">1、浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;</span><br><span class=\"line\">2、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;</span><br><span class=\"line\">3、通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;</span><br><span class=\"line\">4、进行HTTP协议会话，客户端发送报头(请求报头);</span><br><span class=\"line\">5、进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;</span><br><span class=\"line\">6、进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;</span><br><span class=\"line\">7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;</span><br><span class=\"line\">8、浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;</span><br><span class=\"line\">9、文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;</span><br><span class=\"line\">10、页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。</span><br><span class=\"line\"></span><br><span class=\"line\">简洁版：</span><br><span class=\"line\">浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；</span><br><span class=\"line\">服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；</span><br><span class=\"line\">浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；</span><br><span class=\"line\">载入解析到的资源文件，渲染页面，完成。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>部分地区用户反应网站很卡，请问有哪些可能性的原因，以及解决方法？</p>\n</li>\n<li><p>从打开app到刷新出内容，整个过程中都发生了什么，如果感觉慢，怎么定位问题，怎么解决?</p>\n</li>\n<li><p>除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？</p>\n</li>\n<li><p>你用的得心应手用的熟练地编辑器&amp;开发环境是什么样子？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sublime Text 3 + 相关插件编写前端代码</span><br><span class=\"line\">Google chrome 、Mozilla Firefox浏览器 +firebug 兼容测试和预览页面UI、动画效果和交互功能</span><br><span class=\"line\">Node.js+Gulp</span><br><span class=\"line\">git 用于版本控制和Code Review</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对前端工程师这个职位是怎么样理解的？它的前景会怎么样？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。</span><br><span class=\"line\">1、实现界面交互</span><br><span class=\"line\">2、提升用户体验</span><br><span class=\"line\">3、有了Node.js，前端可以实现服务端的一些事情</span><br><span class=\"line\"></span><br><span class=\"line\">前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，</span><br><span class=\"line\"></span><br><span class=\"line\">参与项目，快速高质量完成实现效果图，精确到1px；</span><br><span class=\"line\"></span><br><span class=\"line\">与团队成员，UI设计，产品经理的沟通；</span><br><span class=\"line\"></span><br><span class=\"line\">做好的页面结构，页面重构和用户体验；</span><br><span class=\"line\"></span><br><span class=\"line\">处理hack，兼容、写出优美的代码格式；</span><br><span class=\"line\"></span><br><span class=\"line\">针对服务器的优化、拥抱最新前端技术。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>你怎么看待Web App 、hybrid App、Native App？</p>\n</li>\n<li><p>你移动端前端开发的理解？（和 Web 前端开发的主要区别是什么？）</p>\n</li>\n<li><p>你对加班的看法？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">加班就像借钱，原则应当是------救急不救穷</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>平时如何管理你的项目？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等；</span><br><span class=\"line\"></span><br><span class=\"line\">编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；</span><br><span class=\"line\"></span><br><span class=\"line\">标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；</span><br><span class=\"line\"></span><br><span class=\"line\">页面进行标注（例如 页面 模块 开始和结束）；</span><br><span class=\"line\"></span><br><span class=\"line\">CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）；</span><br><span class=\"line\"></span><br><span class=\"line\">JS 分文件夹存放 命名以该JS功能为准的英文翻译。</span><br><span class=\"line\"></span><br><span class=\"line\">图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如何设计突发大规模并发架构？</p>\n</li>\n<li><p>当团队人手不足，把功能代码写完已经需要加班的情况下，你会做前端代码的测试吗？</p>\n</li>\n<li><p>说说最近最流行的一些东西吧？常去哪些网站？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ES6\\WebAssembly\\Node\\MVVM\\Web Components\\React\\React Native\\Webpack 组件化</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>知道什么是SEO并且怎么优化么? 知道各种meta data的含义么?</p>\n</li>\n<li><p>移动端（Android IOS）怎么做好用户体验?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">清晰的视觉纵线、</span><br><span class=\"line\">信息的分组、极致的减法、</span><br><span class=\"line\">利用选择代替输入、</span><br><span class=\"line\">标签及文字的排布方式、</span><br><span class=\"line\">依靠明文确认密码、</span><br><span class=\"line\">合理的键盘利用、</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>简单描述一下你做过的移动APP项目研发流程？</p>\n</li>\n<li><p>你在现在的团队处于什么样的角色，起到了什么明显的作用？</p>\n</li>\n<li><p>你认为怎样才是全端工程师（Full Stack developer）？</p>\n</li>\n<li><p>介绍一个你最得意的作品吧？</p>\n</li>\n<li><p>你有自己的技术博客吗，用了哪些技术？</p>\n</li>\n<li><p>对前端安全有什么看法？</p>\n</li>\n<li><p>是否了解Web注入攻击，说下原理，最常见的两种攻击（XSS 和 CSRF）了解到什么程度？</p>\n</li>\n<li><p>项目中遇到国哪些印象深刻的技术难题，具体是什么问题，怎么解决？。</p>\n</li>\n<li><p>最近在学什么东西？</p>\n</li>\n<li><p>你的优点是什么？缺点是什么？</p>\n</li>\n<li><p>如何管理前端团队?</p>\n</li>\n<li><p>最近在学什么？能谈谈你未来3，5年给自己的规划吗？</p>\n</li>\n</ul>\n<h2 id=\"前端学习网站推荐\"><a href=\"#前端学习网站推荐\" class=\"headerlink\" title=\"前端学习网站推荐\"></a><a name=\"web\">前端学习网站推荐</a></h2><p><a href=\"http://www.gbtags.com/\" target=\"_blank\" rel=\"noopener\">极客标签</a><br><a href=\"http://weekly.manong.io/issues/\" target=\"_blank\" rel=\"noopener\">码农周刊</a><br><a href=\"http://www.feweekly.com/issues\" target=\"_blank\" rel=\"noopener\">前端周刊</a><br><a href=\"http://www.imooc.com/\" target=\"_blank\" rel=\"noopener\">慕课网</a><br><a href=\"http://div.io\" target=\"_blank\" rel=\"noopener\">div.io</a><br><a href=\"https://news.ycombinator.com/news\" target=\"_blank\" rel=\"noopener\">Hacker News</a><br><a href=\"http://www.infoq.com/\" target=\"_blank\" rel=\"noopener\">InfoQ</a><br><a href=\"http://www.w3cplus.com/\" target=\"_blank\" rel=\"noopener\">w3cplus</a><br><a href=\"http://stackoverflow.com/\" target=\"_blank\" rel=\"noopener\">Stack Overflow</a><br><a href=\"http://www.w3school.com.cn/\" target=\"_blank\" rel=\"noopener\">w3school</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript\" target=\"_blank\" rel=\"noopener\">mozilla</a></p>\n<h2 id=\"文档推荐\"><a href=\"#文档推荐\" class=\"headerlink\" title=\"文档推荐\"></a><a name=\"web\">文档推荐</a></h2><ol>\n<li><p><a href=\"http://docs.huihoo.com/jquery/jquery-fundamentals/zh-cn/index.html\" title=\"jQuery 基本原理\" target=\"_blank\" rel=\"noopener\">jQuery 基本原理</a></p>\n</li>\n<li><p><a href=\"http://bonsaiden.github.io/JavaScript-Garden/zh/\" target=\"_blank\" rel=\"noopener\">JavaScript 秘密花园</a></p>\n</li>\n<li><p><a href=\"http://css.doyoe.com/\" target=\"_blank\" rel=\"noopener\">CSS参考手册</a></p>\n</li>\n<li><p><a href=\"http://javascript.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">JavaScript 标准参考教程</a></p>\n</li>\n<li><p><a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">ECMAScript 6入门</a></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>本文收集总结了一些前端面试题，初学者阅后也要用心钻研其中的原理，重要知识需要系统学习、透彻学习，形成自己的知识链。万不可投机取巧，临时抱佛脚只求面试侥幸混过关是错误的！也是不可能的！不可能的！不可能的！<br>","more":"</p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a><a name=\"preface\">前言</a></h2><p>前端还是一个年轻的行业，新的行业标准， 框架， 库都不断在更新和新增，正如赫门在2015深JS大会上的《前端服务化之路》主题演讲中说的一句话：“每18至24个月，前端都会难一倍”，这些变化使前端的能力更加丰富、创造的应用也会更加完美。所以关注各种前端技术，跟上快速变化的节奏，也是身为一个前端程序员必备的技能之一。</p>\n<p><strong>面试有几点需注意：</strong><br>来源<a href=\"http://weibo.com/wintercn\" title=\"微博：寒冬winter\" target=\"_blank\" rel=\"noopener\">寒冬winter</a> 老师，github:@wintercn</p>\n<ol>\n<li><p>面试题目： 根据你的等级和职位的变化，入门级到专家级，广度和深度都会有所增加。</p>\n</li>\n<li><p>题目类型： 理论知识、算法、项目细节、技术视野、开放性题、工作案例。</p>\n</li>\n<li><p>细节追问： 可以确保问到你开始不懂或面试官开始不懂为止，这样可以大大延展题目的区分度和深度，知道你的实际能力。因为这种知识关联是长时期的学习，临时抱佛脚绝对是记不住的。</p>\n</li>\n<li><p>回答问题再棒，面试官（可能是你面试职位的直接领导），会考虑我要不要这个人做我的同事？所以态度很重要、除了能做事，还要会做人。（感觉更像是相亲）</p>\n</li>\n<li><p>资深的前端开发能把absolute和relative弄混，这样的人不要也罢，因为团队需要的是：你这个人具有可以依靠的才能（靠谱）。</p>\n</li>\n</ol>\n<p><strong>前端开发知识点：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTML&amp;CSS：</span><br><span class=\"line\">    对Web标准的理解、浏览器内核差异、兼容性、hack、CSS基本功：布局、盒子模型、选择器优先级、</span><br><span class=\"line\">    HTML5、CSS3、Flexbox</span><br><span class=\"line\"></span><br><span class=\"line\">JavaScript：</span><br><span class=\"line\">    数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、RegExp、JSON、Ajax、</span><br><span class=\"line\">    DOM、BOM、内存泄漏、跨域、异步装载、模板引擎、前端MVC、路由、模块化、Canvas、ECMAScript 6、Nodejs</span><br><span class=\"line\"></span><br><span class=\"line\">其他：</span><br><span class=\"line\">    移动端、响应式、自动化构建、HTTP、离线存储、WEB安全、优化、重构、团队协作、可维护、易用性、SEO、UED、架构、职业生涯、快速学习能力</span><br></pre></td></tr></table></figure></p>\n<p>作为一名前端工程师，<strong>无论工作年头长短都应该掌握的知识点</strong>：<br>此条由 王子墨 发表在 <a href=\"http://lab.yuanwai.wang/\" target=\"_blank\" rel=\"noopener\">攻城师的实验室</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、DOM结构 —— 两个节点之间可能存在哪些关系以及如何在节点之间任意移动。</span><br><span class=\"line\"></span><br><span class=\"line\">2、DOM操作 —— 如何添加、移除、移动、复制、创建和查找节点等。</span><br><span class=\"line\"></span><br><span class=\"line\">3、事件 —— 如何使用事件，以及IE和标准DOM事件模型之间存在的差别。</span><br><span class=\"line\"></span><br><span class=\"line\">4、XMLHttpRequest —— 这是什么、怎样完整地执行一次GET请求、怎样检测错误。</span><br><span class=\"line\"></span><br><span class=\"line\">5、严格模式与混杂模式 —— 如何触发这两种模式，区分它们有何意义。</span><br><span class=\"line\"></span><br><span class=\"line\">6、盒模型 —— 外边距、内边距和边框之间的关系，及IE8以下版本的浏览器中的盒模型</span><br><span class=\"line\"></span><br><span class=\"line\">7、块级元素与行内元素 —— 怎么用CSS控制它们、以及如何合理的使用它们</span><br><span class=\"line\"></span><br><span class=\"line\">8、浮动元素 —— 怎么使用它们、它们有什么问题以及怎么解决这些问题。</span><br><span class=\"line\"></span><br><span class=\"line\">9、HTML与XHTML —— 二者有什么区别，你觉得应该使用哪一个并说出理由。</span><br><span class=\"line\"></span><br><span class=\"line\">10、JSON —— 作用、用途、设计结构。</span><br></pre></td></tr></table></figure></p>\n<p><strong>备注：</strong></p>\n<blockquote>\n<p>根据自己需要选择性阅读，面试题是对理论知识的总结，让自己学会应该如何表达。<br>资料答案不够正确和全面，欢迎欢迎Star和提交issues。<br>格式不断修改更新中。<br>更新记录：<br>2016年3月25日：新增ECMAScript6 相关问题</p>\n</blockquote>\n<p>###更新时间:  2016-3-25</p>\n<h2 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a><a name=\"html\">HTML</a></h2><ul>\n<li><p>Doctype作用？标准模式与兼容模式各有什么区别?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）、&lt;!DOCTYPE&gt;声明位于位于HTML文档中的第一行，处于 &lt;html&gt; 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。</span><br><span class=\"line\"></span><br><span class=\"line\">（2）、标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；</span><br><span class=\"line\"></span><br><span class=\"line\">而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">首先：CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。</span><br><span class=\"line\"></span><br><span class=\"line\">（1）行内元素有：a b span img input select strong（强调的语气）</span><br><span class=\"line\">（2）块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p</span><br><span class=\"line\"></span><br><span class=\"line\">（3）常见的空元素：</span><br><span class=\"line\">    &lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;</span><br><span class=\"line\">    鲜为人知的是：</span><br><span class=\"line\">    &lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;keygen&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>页面导入样式时，使用link和@import有什么区别？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;</span><br><span class=\"line\"></span><br><span class=\"line\">（2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;</span><br><span class=\"line\"></span><br><span class=\"line\">（3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>介绍一下你对浏览器内核的理解？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。</span><br><span class=\"line\">渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。</span><br><span class=\"line\"></span><br><span class=\"line\">JS引擎则：解析和执行javascript来实现网页的动态效果。</span><br><span class=\"line\"></span><br><span class=\"line\">最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>常见的浏览器内核有哪些？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]</span><br><span class=\"line\">Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等</span><br><span class=\"line\">Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]</span><br><span class=\"line\">Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>详细文章：<a href=\"http://www.cnblogs.com/fullhouse/archive/2011/12/19/2293455.html\" target=\"_blank\" rel=\"noopener\">浏览器内核的解析和对比</a></p>\n</blockquote>\n<ul>\n<li><p>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和<br>HTML5？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</span><br><span class=\"line\">      绘画 canvas;</span><br><span class=\"line\">      用于媒介回放的 video 和 audio 元素;</span><br><span class=\"line\">      本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;</span><br><span class=\"line\">      sessionStorage 的数据在浏览器关闭后自动删除;</span><br><span class=\"line\">      语意化更好的内容元素，比如 article、footer、header、nav、section;</span><br><span class=\"line\">      表单控件，calendar、date、time、email、url、search;</span><br><span class=\"line\">      新的技术webworker, websocket, Geolocation;</span><br><span class=\"line\"></span><br><span class=\"line\">  移除的元素：</span><br><span class=\"line\">      纯表现的元素：basefont，big，center，font, s，strike，tt，u;</span><br><span class=\"line\">      对可用性产生负面影响的元素：frame，frameset，noframes；</span><br><span class=\"line\"></span><br><span class=\"line\">* 支持HTML5新标签：</span><br><span class=\"line\">     IE8/IE7/IE6支持通过document.createElement方法产生的标签，</span><br><span class=\"line\">     可以利用这一特性让这些浏览器支持HTML5新标签，</span><br><span class=\"line\">     浏览器支持新标签后，还需要添加标签默认的样式。</span><br><span class=\"line\"></span><br><span class=\"line\">     当然也可以直接使用成熟的框架、比如html5shim;</span><br><span class=\"line\">     &lt;!--[if lt IE 9]&gt;</span><br><span class=\"line\">        &lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt;</span><br><span class=\"line\">     &lt;![endif]--&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">* 如何区分HTML5： DOCTYPE声明\\新增的结构元素\\功能元素</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>简述一下你对HTML语义化的理解？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用正确的标签做正确的事情。</span><br><span class=\"line\">html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;</span><br><span class=\"line\">即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;</span><br><span class=\"line\">搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;</span><br><span class=\"line\">使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>HTML5的离线储存怎么使用，工作原理能不能解释一下？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。</span><br><span class=\"line\">原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</span><br><span class=\"line\"></span><br><span class=\"line\">如何使用：</span><br><span class=\"line\">1、页面头部像下面一样加入一个manifest的属性；</span><br><span class=\"line\">2、在cache.manifest文件的编写离线存储的资源；</span><br><span class=\"line\">    CACHE MANIFEST</span><br><span class=\"line\">    #v0.11</span><br><span class=\"line\">    CACHE:</span><br><span class=\"line\">    js/app.js</span><br><span class=\"line\">    css/style.css</span><br><span class=\"line\">    NETWORK:</span><br><span class=\"line\">    resourse/logo.png</span><br><span class=\"line\">    FALLBACK:</span><br><span class=\"line\">    / /offline.html</span><br><span class=\"line\">3、在离线状态时，操作window.applicationCache进行需求实现。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>详细的使用请参考：<a href=\"http://segmentfault.com/a/1190000000732617\" target=\"_blank\" rel=\"noopener\">有趣的HTML5：离线存储</a></p>\n</blockquote>\n<ul>\n<li>浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。</span><br><span class=\"line\">离线的情况下，浏览器就直接使用离线存储的资源。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>详细的使用请参考：<a href=\"http://segmentfault.com/a/1190000000732617\" target=\"_blank\" rel=\"noopener\">有趣的HTML5：离线存储</a></p>\n</blockquote>\n<ul>\n<li><p>请描述一下 cookies，sessionStorage 和 localStorage 的区别？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。</span><br><span class=\"line\">cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。</span><br><span class=\"line\">sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</span><br><span class=\"line\"></span><br><span class=\"line\">存储大小：</span><br><span class=\"line\">    cookie数据大小不能超过4k。</span><br><span class=\"line\">    sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</span><br><span class=\"line\"></span><br><span class=\"line\">有期时间：</span><br><span class=\"line\">    localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；</span><br><span class=\"line\">    sessionStorage  数据在当前浏览器窗口关闭后自动删除。</span><br><span class=\"line\">    cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>iframe有那些缺点？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*iframe会阻塞主页面的Onload事件；</span><br><span class=\"line\">*搜索引擎的检索程序无法解读这种页面，不利于SEO;</span><br><span class=\"line\"></span><br><span class=\"line\">*iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</span><br><span class=\"line\"></span><br><span class=\"line\">使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript</span><br><span class=\"line\">动态给iframe添加src属性值，这样可以绕开以上两个问题。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Label的作用是什么？是怎么用的？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;label for=&quot;Name&quot;&gt;Number:&lt;/label&gt;</span><br><span class=\"line\">&lt;input type=“text“name=&quot;Name&quot; id=&quot;Name&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;label&gt;Date:&lt;input type=&quot;text&quot; name=&quot;B&quot;/&gt;&lt;/label&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>HTML5的form如何关闭自动完成功能？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给不想要提示的 form 或某个 input 设置为 autocomplete=off。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如何实现浏览器内多个标签页之间的通信? (阿里)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WebSocket、SharedWorker；</span><br><span class=\"line\">也可以调用localstorge、cookies等本地存储方式；</span><br><span class=\"line\"></span><br><span class=\"line\">localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，</span><br><span class=\"line\">我们通过监听事件，控制它的值来进行页面信息通信；</span><br><span class=\"line\">注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常；</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>webSocket如何兼容低浏览器？(阿里)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Adobe Flash Socket 、</span><br><span class=\"line\">ActiveX HTMLFile (IE) 、</span><br><span class=\"line\">基于 multipart 编码发送 XHR 、</span><br><span class=\"line\">基于长轮询的 XHR</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>页面可见性（Page Visibility API） 可以有哪些用途？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;</span><br><span class=\"line\">在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放；</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如何在页面上实现一个圆形的可点击区域？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、map+area或者svg</span><br><span class=\"line\">2、border-radius</span><br><span class=\"line\">3、纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div style=&quot;height:1px;overflow:hidden;background:red&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>网页验证码是干嘛的，是为了解决什么安全问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水；</span><br><span class=\"line\">有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>title与h1的区别、b与strong的区别、i与em的区别？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响；</span><br><span class=\"line\"></span><br><span class=\"line\">strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：&lt;strong&gt;会重读，而&lt;B&gt;是展示强调内容。</span><br><span class=\"line\"></span><br><span class=\"line\">i内容展示为斜体，em表示强调的文本；</span><br><span class=\"line\"></span><br><span class=\"line\">Physical Style Elements -- 自然样式标签</span><br><span class=\"line\">b, i, u, s, pre</span><br><span class=\"line\">Semantic Style Elements -- 语义样式标签</span><br><span class=\"line\">strong, em, ins, del, code</span><br><span class=\"line\">应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a><a name=\"css\">CSS</a></h2><ul>\n<li><p>介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）有两种， IE 盒子模型、W3C 盒子模型；</span><br><span class=\"line\">（2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；</span><br><span class=\"line\">（3）区  别： IE的content部分把 border 和 padding计算了进去;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>CSS选择符有哪些？哪些属性可以继承？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*   1.id选择器（ # myid）</span><br><span class=\"line\">    2.类选择器（.myclassname）</span><br><span class=\"line\">    3.标签选择器（div, h1, p）</span><br><span class=\"line\">    4.相邻选择器（h1 + p）</span><br><span class=\"line\">    5.子选择器（ul &gt; li）</span><br><span class=\"line\">    6.后代选择器（li a）</span><br><span class=\"line\">    7.通配符选择器（ * ）</span><br><span class=\"line\">    8.属性选择器（a[rel = &quot;external&quot;]）</span><br><span class=\"line\">    9.伪类选择器（a:hover, li:nth-child）</span><br><span class=\"line\"></span><br><span class=\"line\">*   可继承的样式： font-size font-family color, UL LI DL DD DT;</span><br><span class=\"line\"></span><br><span class=\"line\">*   不可继承的样式：border padding margin width height ;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>CSS优先级算法如何计算？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*   优先级就近原则，同权重情况下样式定义最近者为准;</span><br><span class=\"line\"></span><br><span class=\"line\">*   载入样式以最后载入的定位为准;</span><br><span class=\"line\"></span><br><span class=\"line\">优先级为:</span><br><span class=\"line\">   !important &gt;  id &gt; class &gt; tag</span><br><span class=\"line\">    important 比 内联优先级高</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>CSS3新增伪类有那些？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">举例：</span><br><span class=\"line\">p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class=\"line\">p:last-of-type  选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class=\"line\">p:only-of-type  选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class=\"line\">p:only-child        选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。</span><br><span class=\"line\">p:nth-child(2)  选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。</span><br><span class=\"line\"></span><br><span class=\"line\">:after          在元素之前添加内容,也可以用来做清除浮动。</span><br><span class=\"line\">:before         在元素之后添加内容</span><br><span class=\"line\">:enabled        </span><br><span class=\"line\">:disabled       控制表单控件的禁用状态。</span><br><span class=\"line\">:checked        单选框或复选框被选中。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 给div设置一个宽度，然后添加margin:0 auto属性</span><br><span class=\"line\">  div&#123;</span><br><span class=\"line\">      width:200px;</span><br><span class=\"line\">      margin:0 auto;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">* 居中一个浮动元素</span><br><span class=\"line\"></span><br><span class=\"line\">  确定容器的宽高 宽500 高 300 的层设置层的外边距</span><br><span class=\"line\"> .div &#123;</span><br><span class=\"line\">      width:500px ; height:300px;//高度可以不设</span><br><span class=\"line\">      margin: -150px 0 0 -250px;</span><br><span class=\"line\">      position:relative;         //相对定位</span><br><span class=\"line\">      background-color:pink;     //方便看效果</span><br><span class=\"line\">      left:50%;</span><br><span class=\"line\">      top:50%;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">* 让绝对定位的div居中</span><br><span class=\"line\"></span><br><span class=\"line\">  position: absolute;</span><br><span class=\"line\">  width: 1200px;</span><br><span class=\"line\">  background: none;</span><br><span class=\"line\">  margin: 0 auto;</span><br><span class=\"line\">  top: 0;</span><br><span class=\"line\">  left: 0;</span><br><span class=\"line\">  bottom: 0;</span><br><span class=\"line\">  right: 0;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>display有哪些值？说明他们的作用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">block         象块类型元素一样显示。</span><br><span class=\"line\">none          缺省值。象行内元素类型一样显示。</span><br><span class=\"line\">inline-block  象行内元素一样显示，但其内容象块类型元素一样显示。</span><br><span class=\"line\">list-item     象块类型元素一样显示，并添加样式列表标记。</span><br><span class=\"line\">table         此元素会作为块级表格来显示</span><br><span class=\"line\">inherit       规定应该从父元素继承 display 属性的值</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>position的值relative和absolute定位原点是？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">absolute</span><br><span class=\"line\">  生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。</span><br><span class=\"line\">fixed （老IE不支持）</span><br><span class=\"line\">  生成绝对定位的元素，相对于浏览器窗口进行定位。</span><br><span class=\"line\">relative</span><br><span class=\"line\">  生成相对定位的元素，相对于其正常位置进行定位。</span><br><span class=\"line\">static</span><br><span class=\"line\">  默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。</span><br><span class=\"line\">inherit</span><br><span class=\"line\">  规定从父元素继承 position 属性的值。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>CSS3有哪些新特性？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">新增各种CSS选择器    （: not(.input)：所有 class 不是“input”的节点）</span><br><span class=\"line\">圆角           （border-radius:8px）</span><br><span class=\"line\">多列布局        （multi-column layout）</span><br><span class=\"line\">阴影和反射      （Shadow\\Reflect）</span><br><span class=\"line\">文字特效      （text-shadow、）</span><br><span class=\"line\">文字渲染      （Text-decoration）</span><br><span class=\"line\">线性渐变      （gradient）</span><br><span class=\"line\">旋转          （transform）</span><br><span class=\"line\">增加了旋转,缩放,定位,倾斜,动画，多背景</span><br><span class=\"line\">transform:\\scale(0.85,0.90)\\ translate(0px,-30px)\\ skew(-9deg,0deg)\\Animation:</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用纯CSS创建一个三角形的原理是什么？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">把上、左、右三条边隐藏掉（颜色设为 transparent）</span><br><span class=\"line\">#demo &#123;</span><br><span class=\"line\">  width: 0;</span><br><span class=\"line\">  height: 0;</span><br><span class=\"line\">  border-width: 20px;</span><br><span class=\"line\">  border-style: solid;</span><br><span class=\"line\">  border-color: transparent transparent red transparent;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>一个满屏 品 字布局 如何设计?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">简单的方式：</span><br><span class=\"line\">    上面的div宽100%，</span><br><span class=\"line\">    下面的两个div分别宽50%，</span><br><span class=\"line\">    然后用float或者inline使其不换行即可</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.</span><br><span class=\"line\"></span><br><span class=\"line\">* 浏览器默认的margin和padding不同。解决方案是加一个全局的*&#123;margin:0;padding:0;&#125;来统一。</span><br><span class=\"line\"></span><br><span class=\"line\">* IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。</span><br><span class=\"line\"></span><br><span class=\"line\">  浮动ie产生的双倍距离 #box&#123; float:left; width:10px; margin:0 0 0 100px;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)</span><br><span class=\"line\"></span><br><span class=\"line\">  渐进识别的方式，从总体中逐渐排除局部。</span><br><span class=\"line\"></span><br><span class=\"line\">  首先，巧妙的使用“\\9”这一标记，将IE游览器从所有情况中分离出来。</span><br><span class=\"line\">  接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。</span><br><span class=\"line\"></span><br><span class=\"line\">  css</span><br><span class=\"line\">      .bb&#123;</span><br><span class=\"line\">          background-color:#f1ee18;/*所有识别*/</span><br><span class=\"line\">          .background-color:#00deff\\9; /*IE6、7、8识别*/</span><br><span class=\"line\">          +background-color:#a200ff;/*IE6、7识别*/</span><br><span class=\"line\">          _background-color:#1e0bd1;/*IE6识别*/</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">*  IE下,可以使用获取常规属性的方法来获取自定义属性,</span><br><span class=\"line\">   也可以使用getAttribute()获取自定义属性;</span><br><span class=\"line\">   Firefox下,只能使用getAttribute()获取自定义属性。</span><br><span class=\"line\">   解决方法:统一通过getAttribute()获取自定义属性。</span><br><span class=\"line\"></span><br><span class=\"line\">*  IE下,even对象有x,y属性,但是没有pageX,pageY属性;</span><br><span class=\"line\">   Firefox下,event对象有pageX,pageY属性,但是没有x,y属性。</span><br><span class=\"line\"></span><br><span class=\"line\">*  解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。</span><br><span class=\"line\"></span><br><span class=\"line\">*  Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,</span><br><span class=\"line\">   可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。</span><br><span class=\"line\"></span><br><span class=\"line\">超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:</span><br><span class=\"line\">L-V-H-A :  a:link &#123;&#125; a:visited &#123;&#125; a:hover &#123;&#125; a:active &#123;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">行框的排列会受到中间空白（回车\\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>为什么要初始化CSS样式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</span><br><span class=\"line\"></span><br><span class=\"line\">- 当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。</span><br><span class=\"line\"></span><br><span class=\"line\">最简单的初始化方法： * &#123;padding: 0; margin: 0;&#125; （强烈不建议）</span><br><span class=\"line\"></span><br><span class=\"line\">淘宝的样式初始化代码：</span><br><span class=\"line\">body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td &#123; margin:0; padding:0; &#125;</span><br><span class=\"line\">body, button, input, select, textarea &#123; font:12px/1.5tahoma, arial, \\5b8b\\4f53; &#125;</span><br><span class=\"line\">h1, h2, h3, h4, h5, h6&#123; font-size:100%; &#125;</span><br><span class=\"line\">address, cite, dfn, em, var &#123; font-style:normal; &#125;</span><br><span class=\"line\">code, kbd, pre, samp &#123; font-family:couriernew, courier, monospace; &#125;</span><br><span class=\"line\">small&#123; font-size:12px; &#125;</span><br><span class=\"line\">ul, ol &#123; list-style:none; &#125;</span><br><span class=\"line\">a &#123; text-decoration:none; &#125;</span><br><span class=\"line\">a:hover &#123; text-decoration:underline; &#125;</span><br><span class=\"line\">sup &#123; vertical-align:text-top; &#125;</span><br><span class=\"line\">sub&#123; vertical-align:text-bottom; &#125;</span><br><span class=\"line\">legend &#123; color:#000; &#125;</span><br><span class=\"line\">fieldset, img &#123; border:0; &#125;</span><br><span class=\"line\">button, input, select, textarea &#123; font-size:100%; &#125;</span><br><span class=\"line\">table &#123; border-collapse:collapse; border-spacing:0; &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>absolute的containing block(容器块)计算方式跟正常流有什么不同？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">无论属于哪种，都要先找到其祖先元素中最近的 position 值不为 static 的元素，然后再判断：</span><br><span class=\"line\">1、若此元素为 inline 元素，则 containing block 为能够包含这个元素生成的第一个和最后一个 inline box 的 padding box (除 margin, border 外的区域) 的最小矩形；</span><br><span class=\"line\">2、否则,则由这个祖先元素的 padding box 构成。</span><br><span class=\"line\">如果都找不到，则为 initial containing block。</span><br><span class=\"line\"></span><br><span class=\"line\">补充：</span><br><span class=\"line\">1. static(默认的)/relative：简单说就是它的父元素的内容框（即去掉padding的部分）</span><br><span class=\"line\">2. absolute: 向上找最近的定位为absolute/relative的元素</span><br><span class=\"line\">3. fixed: 它的containing block一律为根元素(html/body)，根元素也是initial containing block</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？</p>\n</li>\n<li><p>position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？</p>\n</li>\n<li><p>对BFC规范(块级格式化上下文：block formatting context)的理解？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（W3C CSS 2.1 规范中的一个概念,它是一个独立容器，决定了元素如何对其内容进行定位,以及与其他元素的关系和相互作用。）</span><br><span class=\"line\"> 一个页面是由很多个 Box 组成的,元素的类型和 display 属性,决定了这个 Box 的类型。</span><br><span class=\"line\"> 不同类型的 Box,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>css定义的权重</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下例子是演示各种定义的权重值：</span><br><span class=\"line\"></span><br><span class=\"line\">/*权重为1*/</span><br><span class=\"line\">div&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*权重为10*/</span><br><span class=\"line\">.class1&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*权重为100*/</span><br><span class=\"line\">#id1&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*权重为100+1=101*/</span><br><span class=\"line\">#id1 div&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*权重为10+1=11*/</span><br><span class=\"line\">.class1 div&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*权重为10+10+1=21*/</span><br><span class=\"line\">.class1 .class2 div&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>请解释一下为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式</p>\n</li>\n</ul>\n<ul>\n<li>移动端的布局用过媒体查询吗？</li>\n</ul>\n<ul>\n<li><p>使用 CSS 预处理器吗？喜欢那个？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SASS (SASS、LESS没有本质区别，只因为团队前端都是用的SASS)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>CSS优化、提高性能的方法有哪些？</p>\n</li>\n<li><p>浏览器是怎样解析CSS选择器的？</p>\n</li>\n<li><p>在网页中的应该使用奇数还是偶数的字体？为什么呢？</p>\n</li>\n<li><p>margin和padding分别适合什么场景使用？</p>\n</li>\n<li><p>抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题]</p>\n</li>\n<li><p>元素竖向的百分比设定是相对于容器的高度吗？</p>\n</li>\n<li><p>全屏滚动的原理是什么？用到了CSS的那些属性？</p>\n</li>\n<li><p>什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？</p>\n</li>\n<li><p>视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）</p>\n</li>\n<li><p>::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。</p>\n</li>\n<li><p>如何修改chrome记住密码后自动填充表单的黄色背景 ？</p>\n</li>\n<li><p>你对line-height是如何理解的？</p>\n</li>\n<li><p>设置元素浮动后，该元素的display值是多少？（自动变成display:block）</p>\n</li>\n<li><p>怎么让Chrome支持小于12px 的文字？</p>\n</li>\n<li><p>让页面里的字体变清晰，变细用CSS怎么做？（-webkit-font-smoothing: antialiased;）</p>\n</li>\n<li><p>font-style属性可以让它赋值为“oblique” oblique是什么意思？</p>\n</li>\n<li><p>position:fixed;在android下无效怎么处理？</p>\n</li>\n<li><p>如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>display:inline-block 什么时候会显示间隙？(携程)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>overflow: scroll时不能平滑滚动的问题怎么处理？</p>\n</li>\n<li><p>有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度。</p>\n</li>\n<li><p>png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？</p>\n</li>\n</ul>\n<ul>\n<li><p>什么是Cookie 隔离？（或者说：请求资源的时候不要让它带cookie怎么做）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，</span><br><span class=\"line\">所以不如隔离开。</span><br><span class=\"line\"></span><br><span class=\"line\">因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，</span><br><span class=\"line\">这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。</span><br><span class=\"line\"></span><br><span class=\"line\">同时这种方式不会将cookie传入Web Server，也减少了Web Server对cookie的处理分析环节，</span><br><span class=\"line\">提高了webserver的http请求的解析速度。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>style标签写在body后与body前有什么区别？</p>\n</li>\n<li><p>什么是CSS 预处理器 / 后处理器？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。</span><br><span class=\"line\"></span><br><span class=\"line\">- 后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a><a name=\"js\">JavaScript</a></h2><ul>\n<li><p>介绍js的基本数据类型。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Undefined、Null、Boolean、Number、String、Symbol(new in ECMAScript 2015)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>介绍js有哪些内置对象？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object 是 JavaScript 中所有对象的父对象</span><br><span class=\"line\"></span><br><span class=\"line\">数据封装类对象：Object、Array、Boolean、Number 和 String</span><br><span class=\"line\">其他对象：Function、Arguments、Math、Date、RegExp、Error</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>说几条写JavaScript的基本规范？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.不要在同一行声明多个变量。</span><br><span class=\"line\">2.请使用 ===/!==来比较true/false或者数值</span><br><span class=\"line\">3.使用对象字面量替代new Array这种形式</span><br><span class=\"line\">4.不要使用全局函数。</span><br><span class=\"line\">5.Switch语句必须带有default分支</span><br><span class=\"line\">6.函数不应该有时候有返回值，有时候没有返回值。</span><br><span class=\"line\">7.For循环必须使用大括号</span><br><span class=\"line\">8.If语句必须使用大括号</span><br><span class=\"line\">9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>JavaScript原型，原型链 ? 有什么特点？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，</span><br><span class=\"line\">如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，</span><br><span class=\"line\">于是就这样一直找下去，也就是我们平时所说的原型链的概念。</span><br><span class=\"line\">关系：instance.constructor.prototype = instance.__proto__</span><br><span class=\"line\"></span><br><span class=\"line\">特点：</span><br><span class=\"line\">JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"> 当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的话，</span><br><span class=\"line\"> 就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。</span><br><span class=\"line\">    function Func()&#123;&#125;</span><br><span class=\"line\">    Func.prototype.name = &quot;Sean&quot;;</span><br><span class=\"line\">    Func.prototype.getInfo = function() &#123;</span><br><span class=\"line\">      return this.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var person = new Func();//现在可以参考var person = Object.create(oldObject);</span><br><span class=\"line\">    console.log(person.getInfo());//它拥有了Func的属性和方法</span><br><span class=\"line\">    //&quot;Sean&quot;</span><br><span class=\"line\">    console.log(Func.prototype);</span><br><span class=\"line\">    // Func &#123; name=&quot;Sean&quot;, getInfo=function()&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>JavaScript有几种类型的值？，你能画一下他们的内存图吗？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">栈：原始数据类型（Undefined，Null，Boolean，Number、String） </span><br><span class=\"line\">堆：引用数据类型（对象、数组和函数）</span><br><span class=\"line\"></span><br><span class=\"line\">两种类型的区别是：存储位置不同；</span><br><span class=\"line\">原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</span><br><span class=\"line\">引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其</span><br><span class=\"line\">在栈中的地址，取得地址后从堆中获得实体</span><br><span class=\"line\">```        </span><br><span class=\"line\">![Stated Clearly Image](http://www.w3school.com.cn/i/ct_js_value.gif)</span><br><span class=\"line\"></span><br><span class=\"line\">-  Javascript如何实现继承？</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>1、构造继承<br>2、原型继承<br>3、实例继承<br>4、拷贝继承</p>\n<p>原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```javascript</span><br><span class=\"line\">function Parent()&#123;</span><br><span class=\"line\">    this.name = &apos;wang&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Child()&#123;</span><br><span class=\"line\">    this.age = 28;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Child.prototype = new Parent();//继承了Parent，通过原型</span><br><span class=\"line\"></span><br><span class=\"line\">var demo = new Child();</span><br><span class=\"line\">alert(demo.age);</span><br><span class=\"line\">alert(demo.name);//得到被继承的属性</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>JavaScript继承的几种实现方式？</p>\n<blockquote>\n<p>参考：<a href=\"http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html\" target=\"_blank\" rel=\"noopener\">构造函数的继承</a>，<a href=\"http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html\" target=\"_blank\" rel=\"noopener\">非构造函数的继承</a>；</p>\n</blockquote>\n</li>\n<li><p>javascript创建对象的几种方式？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用。</span><br><span class=\"line\"></span><br><span class=\"line\">1、对象字面量的方式   </span><br><span class=\"line\"></span><br><span class=\"line\">    person=&#123;firstname:&quot;Mark&quot;,lastname:&quot;Yun&quot;,age:25,eyecolor:&quot;black&quot;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">2、用function来模拟无参的构造函数</span><br><span class=\"line\"></span><br><span class=\"line\">    function Person()&#123;&#125;</span><br><span class=\"line\">    var person=new Person();//定义一个function，如果使用new&quot;实例化&quot;,该function可以看作是一个Class</span><br><span class=\"line\">    person.name=&quot;Mark&quot;;</span><br><span class=\"line\">    person.age=&quot;25&quot;;</span><br><span class=\"line\">    person.work=function()&#123;</span><br><span class=\"line\">    alert(person.name+&quot; hello...&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    person.work();</span><br><span class=\"line\"></span><br><span class=\"line\">3、用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）</span><br><span class=\"line\"></span><br><span class=\"line\">    function Pet(name,age,hobby)&#123;</span><br><span class=\"line\">       this.name=name;//this作用域：当前对象</span><br><span class=\"line\">       this.age=age;</span><br><span class=\"line\">       this.hobby=hobby;</span><br><span class=\"line\">       this.eat=function()&#123;</span><br><span class=\"line\">          alert(&quot;我叫&quot;+this.name+&quot;,我喜欢&quot;+this.hobby+&quot;,是个程序员&quot;);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var maidou =new Pet(&quot;麦兜&quot;,25,&quot;coding&quot;);//实例化、创建对象</span><br><span class=\"line\">    maidou.eat();//调用eat方法</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">4、用工厂方式来创建（内置对象）</span><br><span class=\"line\"></span><br><span class=\"line\">     var wcDog =new Object();</span><br><span class=\"line\">     wcDog.name=&quot;旺财&quot;;</span><br><span class=\"line\">     wcDog.age=3;</span><br><span class=\"line\">     wcDog.work=function()&#123;</span><br><span class=\"line\">       alert(&quot;我是&quot;+wcDog.name+&quot;,汪汪汪......&quot;);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     wcDog.work();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">5、用原型方式来创建</span><br><span class=\"line\"></span><br><span class=\"line\">    function Dog()&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     Dog.prototype.name=&quot;旺财&quot;;</span><br><span class=\"line\">     Dog.prototype.eat=function()&#123;</span><br><span class=\"line\">     alert(this.name+&quot;是个吃货&quot;);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     var wangcai =new Dog();</span><br><span class=\"line\">     wangcai.eat();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">5、用混合方式来创建</span><br><span class=\"line\"></span><br><span class=\"line\">    function Car(name,price)&#123;</span><br><span class=\"line\">      this.name=name;</span><br><span class=\"line\">      this.price=price; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     Car.prototype.sell=function()&#123;</span><br><span class=\"line\">       alert(&quot;我是&quot;+this.name+&quot;，我现在卖&quot;+this.price+&quot;万元&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    var camry =new Car(&quot;凯美瑞&quot;,27);</span><br><span class=\"line\">    camry.sell();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Javascript作用链域?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。</span><br><span class=\"line\">当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，</span><br><span class=\"line\">直至全局函数，这种组织形式就是作用域链。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>谈谈This对象的理解。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* this总是指向函数的直接调用者（而非间接调用者）；</span><br><span class=\"line\">* 如果有new关键字，this指向new出来的那个对象；</span><br><span class=\"line\">* 在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window；</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>eval是做什么的？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">它的功能是把对应的字符串解析成JS代码并运行；</span><br><span class=\"line\">应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。</span><br><span class=\"line\">由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(&apos;(&apos;+ str +&apos;)&apos;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>什么是window对象? 什么是document对象?</p>\n</li>\n</ul>\n<ul>\n<li>null，undefined 的区别？<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ull，undefined 的区别？</span><br><span class=\"line\">null        表示一个对象被定义了，值为“空值”；</span><br><span class=\"line\">undefined   表示不存在这个值。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof undefined</span><br><span class=\"line\">    //&quot;undefined&quot;</span><br><span class=\"line\">    undefined :是一个表示&quot;无&quot;的原始值或者说表示&quot;缺少值&quot;，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined； </span><br><span class=\"line\">    例如变量被声明了，但没有赋值时，就等于undefined</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof null  //&quot;object&quot;</span><br><span class=\"line\">    null : 是一个对象(空对象, 没有任何属性和方法)；</span><br><span class=\"line\">    例如作为函数的参数，表示该函数的参数不是对象；</span><br></pre></td></tr></table></figure>\n<p>注意：<br>    在验证null时，一定要使用　=== ，因为 == 无法分别 null 和　undefined</p>\n<p>再来一个例子：<br>  null<br>  Q：有张三这个人么？<br>  A：有！<br>  Q：张三有房子么？<br>  A：没有！</p>\n<p>  undefined<br>  Q：有张三这个人么？<br>  A：没有！ </p>\n<blockquote>\n<p>参考阅读：<a href=\"http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html\" target=\"_blank\" rel=\"noopener\">undefined与null的区别</a></p>\n</blockquote>\n<ul>\n<li><p>写一个通用的事件侦听器函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// event(事件)工具集，来源：github.com/markyun</span><br><span class=\"line\">markyun.Event = &#123;</span><br><span class=\"line\">    // 页面加载完成后</span><br><span class=\"line\">    readyEvent : function(fn) &#123;</span><br><span class=\"line\">        if (fn==null) &#123;</span><br><span class=\"line\">            fn=document;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        var oldonload = window.onload;</span><br><span class=\"line\">        if (typeof window.onload != &apos;function&apos;) &#123;</span><br><span class=\"line\">            window.onload = fn;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            window.onload = function() &#123;</span><br><span class=\"line\">                oldonload();</span><br><span class=\"line\">                fn();</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 视能力分别使用dom0||dom2||IE方式 来绑定事件</span><br><span class=\"line\">    // 参数： 操作的元素,事件名称 ,事件处理程序</span><br><span class=\"line\">    addEvent : function(element, type, handler) &#123;</span><br><span class=\"line\">        if (element.addEventListener) &#123;</span><br><span class=\"line\">            //事件类型、需要执行的函数、是否捕捉</span><br><span class=\"line\">            element.addEventListener(type, handler, false);</span><br><span class=\"line\">        &#125; else if (element.attachEvent) &#123;</span><br><span class=\"line\">            element.attachEvent(&apos;on&apos; + type, function() &#123;</span><br><span class=\"line\">                handler.call(element);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            element[&apos;on&apos; + type] = handler;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 移除事件</span><br><span class=\"line\">    removeEvent : function(element, type, handler) &#123;</span><br><span class=\"line\">        if (element.removeEventListener) &#123;</span><br><span class=\"line\">            element.removeEventListener(type, handler, false);</span><br><span class=\"line\">        &#125; else if (element.datachEvent) &#123;</span><br><span class=\"line\">            element.detachEvent(&apos;on&apos; + type, handler);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            element[&apos;on&apos; + type] = null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)</span><br><span class=\"line\">    stopPropagation : function(ev) &#123;</span><br><span class=\"line\">        if (ev.stopPropagation) &#123;</span><br><span class=\"line\">            ev.stopPropagation();</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            ev.cancelBubble = true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 取消事件的默认行为</span><br><span class=\"line\">    preventDefault : function(event) &#123;</span><br><span class=\"line\">        if (event.preventDefault) &#123;</span><br><span class=\"line\">            event.preventDefault();</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            event.returnValue = false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 获取事件目标</span><br><span class=\"line\">    getTarget : function(event) &#123;</span><br><span class=\"line\">        return event.target || event.srcElement;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 获取event对象的引用，取到事件的所有信息，确保随时能使用event；</span><br><span class=\"line\">    getEvent : function(e) &#123;</span><br><span class=\"line\">        var ev = e || window.event;</span><br><span class=\"line\">        if (!ev) &#123;</span><br><span class=\"line\">            var c = this.getEvent.caller;</span><br><span class=\"line\">            while (c) &#123;</span><br><span class=\"line\">                ev = c.arguments[0];</span><br><span class=\"line\">                if (ev &amp;&amp; Event == ev.constructor) &#123;</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                c = c.caller;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>[“1”, “2”, “3”].map(parseInt) 答案是多少？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, NaN, NaN] 因为 parseInt 需要两个参数 (val, radix)，</span><br><span class=\"line\">其中 radix 表示解析时用的基数。</span><br><span class=\"line\">map 传了 3 个 (element, index, array)，对应的 radix 不合法导致解析失败。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>事件是？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。</span><br><span class=\"line\">2. 事件处理机制：IE是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件；</span><br><span class=\"line\">3. ev.stopPropagation();（旧ie的方法 ev.cancelBubble = true;）</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>什么是闭包（closure），为什么要用它？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。</span><br><span class=\"line\"></span><br><span class=\"line\">闭包的特性：</span><br><span class=\"line\"></span><br><span class=\"line\">1.函数内再嵌套函数</span><br><span class=\"line\">2.内部函数可以引用外层的参数和变量</span><br><span class=\"line\">3.参数和变量不会被垃圾回收机制回收</span><br><span class=\"line\"></span><br><span class=\"line\">//li节点的onclick事件都能正确的弹出当前被点击的li索引</span><br><span class=\"line\"> &lt;ul id=&quot;testUL&quot;&gt;</span><br><span class=\"line\">    &lt;li&gt; index = 0&lt;/li&gt;</span><br><span class=\"line\">    &lt;li&gt; index = 1&lt;/li&gt;</span><br><span class=\"line\">    &lt;li&gt; index = 2&lt;/li&gt;</span><br><span class=\"line\">    &lt;li&gt; index = 3&lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">    var nodes = document.getElementsByTagName(&quot;li&quot;);</span><br><span class=\"line\">    for(i = 0;i&lt;nodes.length;i+= 1)&#123;</span><br><span class=\"line\">        nodes[i].onclick = function()&#123;</span><br><span class=\"line\">            console.log(i+1);//不用闭包的话，值每次都是4</span><br><span class=\"line\">        &#125;(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">执行say667()后,say667()闭包内部变量会存在,而闭包内部函数的内部变量不会存在</span><br><span class=\"line\">使得Javascript的垃圾回收机制GC不会收回say667()所占用的资源</span><br><span class=\"line\">因为say667()的内部函数的执行需要依赖say667()中的变量</span><br><span class=\"line\">这是对闭包作用的非常直白的描述</span><br><span class=\"line\"></span><br><span class=\"line\">  function say667() &#123;</span><br><span class=\"line\">    // Local variable that ends up within closure</span><br><span class=\"line\">    var num = 666;</span><br><span class=\"line\">    var sayAlert = function() &#123;</span><br><span class=\"line\">        alert(num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    num++;</span><br><span class=\"line\">    return sayAlert;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> var sayAlert = say667();</span><br><span class=\"line\"> sayAlert()//执行结果应该弹出的667</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,</span><br><span class=\"line\"></span><br><span class=\"line\">使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。</span><br><span class=\"line\">默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值;</span><br><span class=\"line\">全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数,arguments.callee也不允许使用；</span><br><span class=\"line\">消除代码运行的一些不安全之处，保证代码运行的安全,限制函数中的arguments修改，严格模式下的eval函数的行为和非严格模式的也不相同;</span><br><span class=\"line\"></span><br><span class=\"line\">提高编译器效率，增加运行速度；</span><br><span class=\"line\">为未来新版本的Javascript标准化做铺垫。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如何判断一个对象是否属于某个类？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用instanceof （待完善）</span><br><span class=\"line\"> if(a instanceof Person)&#123;</span><br><span class=\"line\">     alert(&apos;yes&apos;);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>new操作符具体干了什么呢?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</span><br><span class=\"line\">   2、属性和方法被加入到 this 引用的对象中。</span><br><span class=\"line\">   3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。</span><br><span class=\"line\"></span><br><span class=\"line\">var obj  = &#123;&#125;;</span><br><span class=\"line\">obj.__proto__ = Base.prototype;</span><br><span class=\"line\">Base.call(obj);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用原生JavaScript的实现过什么功能吗？</p>\n</li>\n</ul>\n<ul>\n<li><p>Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hasOwnProperty</span><br><span class=\"line\"></span><br><span class=\"line\">javaScript中hasOwnProperty函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员。</span><br><span class=\"line\">使用方法：</span><br><span class=\"line\">object.hasOwnProperty(proName)</span><br><span class=\"line\">其中参数object是必选项。一个对象的实例。</span><br><span class=\"line\">proName是必选项。一个属性名称的字符串值。</span><br><span class=\"line\"></span><br><span class=\"line\">如果 object 具有指定名称的属性，那么JavaScript中hasOwnProperty函数方法返回 true，反之则返回 false。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>JSON 的了解？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。</span><br><span class=\"line\">它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小</span><br><span class=\"line\">如：&#123;&quot;age&quot;:&quot;12&quot;, &quot;name&quot;:&quot;back&quot;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">JSON字符串转换为JSON对象:</span><br><span class=\"line\">var obj =eval(&apos;(&apos;+ str +&apos;)&apos;);</span><br><span class=\"line\">var obj = str.parseJSON();</span><br><span class=\"line\">var obj = JSON.parse(str);</span><br><span class=\"line\"></span><br><span class=\"line\">JSON对象转换为JSON字符串：</span><br><span class=\"line\">var last=obj.toJSONString();</span><br><span class=\"line\">var last=JSON.stringify(obj);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>[].forEach.call($$(&quot;*&quot;),function(a){a.style.outline=&quot;1px solid #&quot;+(~~(Math.random()*(1&lt;&lt;24))).toString(16)})</code> 能解释一下这段代码的意思吗？</p>\n</li>\n</ul>\n<ul>\n<li><p>js延迟加载的方式有哪些？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">defer和async、动态创建DOM方式（用得最多）、按需异步载入js</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Ajax 是什么? 如何创建一个Ajax？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ajax的全称：Asynchronous Javascript And XML。</span><br><span class=\"line\">异步传输+js+xml。</span><br><span class=\"line\">所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。</span><br><span class=\"line\"></span><br><span class=\"line\">(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象</span><br><span class=\"line\">(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息</span><br><span class=\"line\">(3)设置响应HTTP请求状态变化的函数</span><br><span class=\"line\">(4)发送HTTP请求</span><br><span class=\"line\">(5)获取异步调用返回的数据</span><br><span class=\"line\">(6)使用JavaScript和DOM实现局部刷新</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>同步和异步的区别?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">同步的概念应该是来自于OS中关于同步的概念:不同进程为协同完成某项工作而在先后次序上调整(通过阻塞,唤醒等方式).同步强调的是顺序性.谁先谁后.异步则不存在这种顺序性.</span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作。</span><br><span class=\"line\"></span><br><span class=\"line\">异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。</span><br><span class=\"line\"></span><br><span class=\"line\">（待完善）</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如何解决跨域问题?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>页面编码和被请求的资源编码如果不一致如何处理？</p>\n</li>\n<li><p>模块化开发怎么做？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ 立即执行函数](http://benalman.com/news/2010/11/immediately-invoked-function-expression/),不暴露私有成员</span><br><span class=\"line\"></span><br><span class=\"line\">var module1 = (function()&#123;</span><br><span class=\"line\">　　　　var _count = 0;</span><br><span class=\"line\">　　　　var m1 = function()&#123;</span><br><span class=\"line\">　　　　　　//...</span><br><span class=\"line\">　　　　&#125;;</span><br><span class=\"line\">　　　　var m2 = function()&#123;</span><br><span class=\"line\">　　　　　　//...</span><br><span class=\"line\">　　　　&#125;;</span><br><span class=\"line\">　　　　return &#123;</span><br><span class=\"line\">　　　　　　m1 : m1,</span><br><span class=\"line\">　　　　　　m2 : m2</span><br><span class=\"line\">　　　　&#125;;</span><br><span class=\"line\">　　&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">（待完善）</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; AMD 规范在这里：https://github.com/amdjs/amdjs-api/wiki/AMD</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; CMD 规范在这里：https://github.com/seajs/seajs/issues/242</span><br><span class=\"line\"></span><br><span class=\"line\">Asynchronous Module Definition，异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中。</span><br><span class=\"line\"></span><br><span class=\"line\"> 区别：</span><br><span class=\"line\"></span><br><span class=\"line\">    1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.</span><br><span class=\"line\">    2. CMD 推崇依赖就近，AMD 推崇依赖前置。看代码：</span><br><span class=\"line\"></span><br><span class=\"line\">// CMD</span><br><span class=\"line\">define(function(require, exports, module) &#123;</span><br><span class=\"line\">    var a = require(&apos;./a&apos;)</span><br><span class=\"line\">    a.doSomething()</span><br><span class=\"line\">    // 此处略去 100 行</span><br><span class=\"line\">    var b = require(&apos;./b&apos;) // 依赖可以就近书写</span><br><span class=\"line\">    b.doSomething()</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// AMD 默认推荐</span><br><span class=\"line\">define([&apos;./a&apos;, &apos;./b&apos;], function(a, b) &#123; // 依赖必须一开始就写好</span><br><span class=\"line\">    a.doSomething()</span><br><span class=\"line\">    // 此处略去 100 行</span><br><span class=\"line\">    b.doSomething()</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何<br>缓存的？）</p>\n</li>\n<li><p>谈一谈你对ECMAScript6的了解？</p>\n</li>\n<li><p>ECMAScript6 怎么写class么，为什么会出现class这种东西? </p>\n</li>\n<li><p>异步加载JS的方式有哪些？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(1) defer，只支持IE</span><br><span class=\"line\"></span><br><span class=\"line\">(2) async：</span><br><span class=\"line\"></span><br><span class=\"line\">(3) 创建script，插入到DOM中，加载完毕后callBack</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>documen.write和 innerHTML的区别</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.write只能重绘整个页面</span><br><span class=\"line\"></span><br><span class=\"line\">innerHTML可以重绘页面的一部分</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>DOM操作——怎样添加、移除、移动、复制、创建和查找节点?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）创建新节点</span><br><span class=\"line\">createDocumentFragment()    //创建一个DOM片段</span><br><span class=\"line\">createElement()   //创建一个具体的元素</span><br><span class=\"line\">createTextNode()   //创建一个文本节点</span><br><span class=\"line\">（2）添加、移除、替换、插入</span><br><span class=\"line\">appendChild()</span><br><span class=\"line\">removeChild()</span><br><span class=\"line\">replaceChild()</span><br><span class=\"line\">insertBefore() //在已有的子节点前插入一个新的子节点</span><br><span class=\"line\">（3）查找</span><br><span class=\"line\">getElementsByTagName()    //通过标签名称</span><br><span class=\"line\">getElementsByName()    //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)</span><br><span class=\"line\">getElementById()    //通过元素Id，唯一性</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>.call() 和 .apply() 的区别？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例子中用 add 来替换 sub，add.call(sub,3,1) == add(3,1) ，所以运行结果为：alert(4);</span><br><span class=\"line\"></span><br><span class=\"line\">注意：js 中的函数其实是对象，函数名是对 Function 对象的引用。</span><br><span class=\"line\"></span><br><span class=\"line\">  function add(a,b)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      alert(a+b);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  function sub(a,b)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      alert(a-b);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  add.call(sub,3,1);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>数组和对象有哪些原生方法，列举一下？</p>\n</li>\n<li><p>JS 怎么实现一个类。怎么实例化这个类</p>\n</li>\n<li><p>JavaScript中的作用域与变量声明提升？</p>\n</li>\n<li><p>如何编写高性能的Javascript？</p>\n</li>\n<li><p>那些操作会造成内存泄漏？</p>\n</li>\n<li><p>JQuery的源码看过吗？能不能简单概况一下它的实现原理？</p>\n</li>\n<li><p>jQuery.fn的init方法返回的this指的是什么对象？为什么要返回this？</p>\n</li>\n<li><p>jquery中如何将数组转化为json字符串，然后再转化回来？</p>\n</li>\n<li><p>jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？ </p>\n</li>\n<li><p>jquery.extend 与 jquery.fn.extend的区别？</p>\n</li>\n<li><p>jQuery 的队列是如何实现的？队列可以用在哪些地方？</p>\n</li>\n<li><p>谈一下Jquery中的bind(),live(),delegate(),on()的区别？</p>\n</li>\n<li><p>JQuery一个对象可以同时绑定多个事件，这是如何实现的？</p>\n</li>\n<li><p>是否知道自定义事件。jQuery里的fire函数是什么意思，什么时候用？</p>\n</li>\n<li><p>jQuery 是通过哪个方法和 Sizzle 选择器结合的？（jQuery.fn.find()进入Sizzle）</p>\n</li>\n<li><p>针对 jQuery性能的优化方法？</p>\n</li>\n<li><p>Jquery与jQuery UI 有啥区别？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*jQuery是一个js库，主要提供的功能是选择器，属性修改和事件绑定等等。</span><br><span class=\"line\"></span><br><span class=\"line\">*jQuery UI则是在jQuery的基础上，利用jQuery的扩展性，设计的插件。</span><br><span class=\"line\"> 提供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>JQuery的源码看过吗？能不能简单说一下它的实现原理？</p>\n</li>\n<li><p>jquery 中如何将数组转化为json字符串，然后再转化回来？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jQuery中没有提供这个功能，所以你需要先编写两个jQuery的扩展：</span><br><span class=\"line\"></span><br><span class=\"line\">$.fn.stringifyArray = function(array) &#123;</span><br><span class=\"line\">    return JSON.stringify(array)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$.fn.parseArray = function(array) &#123;</span><br><span class=\"line\">    return JSON.parse(array)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">然后调用：</span><br><span class=\"line\">$(&quot;&quot;).stringifyArray(array)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>jQuery和Zepto的区别？各自的使用场景？</p>\n</li>\n<li><p>针对 jQuery 的优化方法？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*基于Class的选择性的性能相对于Id选择器开销很大，因为需遍历所有DOM元素。</span><br><span class=\"line\"></span><br><span class=\"line\">*频繁操作的DOM，先缓存起来再操作。用Jquery的链式调用更好。</span><br><span class=\"line\"> 比如：var str=$(&quot;a&quot;).attr(&quot;href&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">*for (var i = size; i &lt; arr.length; i++) &#123;&#125;</span><br><span class=\"line\"> for 循环每一次循环都查找了数组 (arr) 的.length 属性，在开始循环的时候设置一个变量来存储这个数字，可以让循环跑得更快：</span><br><span class=\"line\"> for (var i = size, length = arr.length; i &lt; length; i++) &#123;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Zepto的点透问题如何解决？</p>\n</li>\n<li><p>jQueryUI如何自定义组件?</p>\n</li>\n<li><p>需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？</p>\n</li>\n<li><p>如何判断当前脚本运行在浏览器还是node环境中？（阿里）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>移动端最小触控区域是多大？</p>\n</li>\n<li><p>jQuery 的 slideUp动画 ，如果目标元素是被外部事件驱动, 当鼠标快速地连续触发外部元素事件, 动画会滞后的反复执行，该如何处理呢?</p>\n</li>\n<li><p>把 Script 标签 放在页面的最底部的body封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？</p>\n</li>\n<li><p>移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？（click 有 300ms 延迟,为了实现safari的双击事件的设计，浏览器要知道你是不是要双击操作。）</p>\n</li>\n<li><p>知道各种JS框架(Angular, Backbone, Ember, React, Meteor, Knockout…)么? 能讲出他们各自的优点和缺点么?</p>\n</li>\n<li><p>Underscore 对哪些 JS 原生对象进行了扩展以及提供了哪些好用的函数方法？</p>\n</li>\n<li><p>解释JavaScript中的作用域与变量声明提升？</p>\n</li>\n<li><p>那些操作会造成内存泄漏？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。</span><br><span class=\"line\">垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。</span><br><span class=\"line\">闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>JQuery一个对象可以同时绑定多个事件，这是如何实现的？</p>\n</li>\n<li><p>Node.js的适用场景？</p>\n</li>\n<li><p>(如果会用node)知道route, middleware, cluster, nodemon, pm2, server-side rendering么?</p>\n</li>\n<li><p>解释一下 Backbone 的 MVC 实现方式？</p>\n</li>\n<li><p>什么是“前端路由”?什么时候适合使用“前端路由”? “前端路由”有哪些优点和缺点?</p>\n</li>\n<li><p>知道什么是webkit么? 知道怎么用浏览器的各种工具来调试和debug代码么?</p>\n</li>\n<li><p>如何测试前端代码么? 知道BDD, TDD, Unit Test么? 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)?</p>\n</li>\n<li><p>前端templating(Mustache, underscore, handlebars)是干嘛的, 怎么用?</p>\n</li>\n<li><p>简述一下 Handlebars 的基本用法？</p>\n</li>\n<li><p>简述一下 Handlerbars 的对模板的基本处理流程， 如何编译的？如何缓存的？</p>\n</li>\n<li><p>用js实现千位分隔符?(来源：<a href=\"http://div.io/topic/744\" target=\"_blank\" rel=\"noopener\">前端农民工</a>，提示：正则+replace)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function commafy(num) &#123;</span><br><span class=\"line\">     num = num + &apos;&apos;;</span><br><span class=\"line\">     var reg = /(-?d+)(d&#123;3&#125;)/;</span><br><span class=\"line\">    </span><br><span class=\"line\">    if(reg.test(num))&#123;</span><br><span class=\"line\">     num = num.replace(reg, &apos;$1,$2&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return num;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>检测浏览器版本版本有哪些方式？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">功能检测、userAgent特征检测</span><br><span class=\"line\"></span><br><span class=\"line\">比如：navigator.userAgent</span><br><span class=\"line\">//&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36</span><br><span class=\"line\">  (KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>What is a Polyfill? </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">polyfill 是“在旧版浏览器上复制标准 API 的 JavaScript 补充”,可以动态地加载 JavaScript 代码或库，在不支持这些标准 API 的浏览器中模拟它们。</span><br><span class=\"line\">例如，geolocation（地理位置）polyfill 可以在 navigator 对象上添加全局的 geolocation 对象，还能添加 getCurrentPosition 函数以及“坐标”回调对象，</span><br><span class=\"line\">所有这些都是 W3C 地理位置 API 定义的对象和函数。因为 polyfill 模拟标准 API，所以能够以一种面向所有浏览器未来的方式针对这些 API 进行开发，</span><br><span class=\"line\">一旦对这些 API 的支持变成绝对大多数，则可以方便地去掉 polyfill，无需做任何额外工作。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>做的项目中，有没有用过或自己实现一些 polyfill 方案（兼容性处理方案）？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">比如： html5shiv、Geolocation、Placeholder</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？</p>\n</li>\n</ul>\n<h4 id=\"ECMAScript6-相关\"><a href=\"#ECMAScript6-相关\" class=\"headerlink\" title=\"ECMAScript6 相关\"></a><a name=\"other\">ECMAScript6 相关</a></h4><ul>\n<li>Object.is() 与原来的比较操作符“ ===”、“ ==”的区别？ <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">两等号判等，会在比较时进行类型转换；</span><br><span class=\"line\">三等号判等(判断严格)，比较时不进行隐式类型转换,（类型不同则会返回false）； </span><br><span class=\"line\"></span><br><span class=\"line\">Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，</span><br><span class=\"line\">但 Object.is(NaN, NaN) 会返回 true.</span><br><span class=\"line\"></span><br><span class=\"line\">Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"前端框架相关\"><a href=\"#前端框架相关\" class=\"headerlink\" title=\"前端框架相关\"></a><a name=\"other\">前端框架相关</a></h4><ul>\n<li><p>react-router 路由系统的实现原理？</p>\n</li>\n<li><p>React中如何解决第三方类库的问题?</p>\n</li>\n</ul>\n<h2 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a><a name=\"other\">其他问题</a></h2><ul>\n<li><p>原来公司工作流程是怎么样的，如何与其他人协作的？如何夸部门合作的？</p>\n</li>\n<li><p>你遇到过比较难的技术问题是？你是如何解决的？</p>\n</li>\n<li><p>设计模式 知道什么是singleton, factory, strategy, decrator么?</p>\n</li>\n<li><p>常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？</p>\n</li>\n<li><p>页面重构怎么操作？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。</span><br><span class=\"line\">也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。</span><br><span class=\"line\"></span><br><span class=\"line\">对于传统的网站来说重构通常是：</span><br><span class=\"line\"></span><br><span class=\"line\">表格(table)布局改为DIV+CSS</span><br><span class=\"line\">使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)</span><br><span class=\"line\">对于移动平台的优化</span><br><span class=\"line\">针对于SEO进行优化</span><br><span class=\"line\">深层次的网站重构应该考虑的方面</span><br><span class=\"line\"></span><br><span class=\"line\">减少代码间的耦合</span><br><span class=\"line\">让代码保持弹性</span><br><span class=\"line\">严格按规范编写代码</span><br><span class=\"line\">设计可扩展的API</span><br><span class=\"line\">代替旧有的框架、语言(如VB)</span><br><span class=\"line\">增强用户体验</span><br><span class=\"line\">通常来说对于速度的优化也包含在重构中</span><br><span class=\"line\"></span><br><span class=\"line\">压缩JS、CSS、image等前端资源(通常是由服务器来解决)</span><br><span class=\"line\">程序的性能优化(如数据读写)</span><br><span class=\"line\">采用CDN来加速资源加载</span><br><span class=\"line\">对于JS DOM的优化</span><br><span class=\"line\">HTTP服务器的文件缓存</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>列举IE与其他浏览器不一样的特性？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、事件不同之处：</span><br><span class=\"line\"></span><br><span class=\"line\">触发事件的元素被认为是目标（target）。而在 IE 中，目标包含在 event 对象的 srcElement 属性；</span><br><span class=\"line\"></span><br><span class=\"line\">获取字符代码、如果按键代表一个字符（shift、ctrl、alt除外），IE 的 keyCode 会返回字符代码（Unicode），DOM 中按键的代码和字符是分离的，要获取字符代码，需要使用 charCode 属性；</span><br><span class=\"line\"></span><br><span class=\"line\">阻止某个事件的默认行为，IE 中阻止某个事件的默认行为，必须将 returnValue 属性设置为 false，Mozilla 中，需要调用 preventDefault() 方法；</span><br><span class=\"line\"></span><br><span class=\"line\">停止事件冒泡，IE 中阻止事件进一步冒泡，需要设置 cancelBubble 为 true，Mozzilla 中，需要调用 stopPropagation()；</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>99%的网站都需要被重构是那本书上写的？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">网站重构：应用web标准进行设计（第2版）</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>什么叫优雅降级和渐进增强？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。</span><br><span class=\"line\">如：border-shadow</span><br><span class=\"line\"></span><br><span class=\"line\">渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。</span><br><span class=\"line\">如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验；</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>是否了解公钥加密和私钥加密。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一般情况下是指私钥用于对数据进行签名，公钥用于对签名进行验证;</span><br><span class=\"line\">HTTP网站在浏览器端用公钥加密敏感数据，然后在服务器端再用私钥解密。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>WEB应用从服务器主动推送Data到客户端有那些方式？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html5提供的Websocket</span><br><span class=\"line\">不可见的iframe</span><br><span class=\"line\">WebSocket通过Flash</span><br><span class=\"line\">XHR长时间连接</span><br><span class=\"line\">XHR Multipart Streaming</span><br><span class=\"line\">&lt;script&gt;标签的长时间连接(可跨域)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对Node的优点和缺点提出了自己的看法？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，</span><br><span class=\"line\">  因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。</span><br><span class=\"line\">  此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，</span><br><span class=\"line\">  因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。</span><br><span class=\"line\"></span><br><span class=\"line\">*（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，</span><br><span class=\"line\">  而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>你有用过哪些前端性能优化的方法？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。</span><br><span class=\"line\"></span><br><span class=\"line\">（2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数</span><br><span class=\"line\"></span><br><span class=\"line\">（3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。</span><br><span class=\"line\"></span><br><span class=\"line\">（4） 当需要设置的样式很多时设置className而不是直接操作style。</span><br><span class=\"line\"></span><br><span class=\"line\">（5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。</span><br><span class=\"line\"></span><br><span class=\"line\">（6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。</span><br><span class=\"line\"></span><br><span class=\"line\">（7） 图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。</span><br><span class=\"line\"></span><br><span class=\"line\">（8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。</span><br><span class=\"line\">对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>http状态码有那些？分别代表是什么意思？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">简单版</span><br><span class=\"line\">[</span><br><span class=\"line\">    100  Continue   继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</span><br><span class=\"line\">    200  OK         正常返回信息</span><br><span class=\"line\">    201  Created    请求成功并且服务器创建了新的资源</span><br><span class=\"line\">    202  Accepted   服务器已接受请求，但尚未处理</span><br><span class=\"line\">    301  Moved Permanently  请求的网页已永久移动到新位置。</span><br><span class=\"line\">    302 Found       临时性重定向。</span><br><span class=\"line\">    303 See Other   临时性重定向，且总是使用 GET 请求新的 URI。</span><br><span class=\"line\">    304  Not Modified 自从上次请求后，请求的网页未修改过。</span><br><span class=\"line\"></span><br><span class=\"line\">    400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</span><br><span class=\"line\">    401 Unauthorized 请求未授权。</span><br><span class=\"line\">    403 Forbidden   禁止访问。</span><br><span class=\"line\">    404 Not Found   找不到如何与 URI 相匹配的资源。</span><br><span class=\"line\"></span><br><span class=\"line\">    500 Internal Server Error  最常见的服务器端错误。</span><br><span class=\"line\">    503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">完整版</span><br><span class=\"line\">1**(信息类)：表示接收到请求并且继续处理</span><br><span class=\"line\">100——客户必须继续发出请求</span><br><span class=\"line\">101——客户要求服务器根据请求转换HTTP协议版本</span><br><span class=\"line\"></span><br><span class=\"line\">2**(响应成功)：表示动作被成功接收、理解和接受</span><br><span class=\"line\">200——表明该请求被成功地完成，所请求的资源发送回客户端</span><br><span class=\"line\">201——提示知道新文件的URL</span><br><span class=\"line\">202——接受和处理、但处理未完成</span><br><span class=\"line\">203——返回信息不确定或不完整</span><br><span class=\"line\">204——请求收到，但返回信息为空</span><br><span class=\"line\">205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件</span><br><span class=\"line\">206——服务器已经完成了部分用户的GET请求</span><br><span class=\"line\"></span><br><span class=\"line\">3**(重定向类)：为了完成指定的动作，必须接受进一步处理</span><br><span class=\"line\">300——请求的资源可在多处得到</span><br><span class=\"line\">301——本网页被永久性转移到另一个URL</span><br><span class=\"line\">302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。</span><br><span class=\"line\">303——建议客户访问其他URL或访问方式</span><br><span class=\"line\">304——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用</span><br><span class=\"line\">305——请求的资源必须从服务器指定的地址得到</span><br><span class=\"line\">306——前一版本HTTP中使用的代码，现行版本中不再使用</span><br><span class=\"line\">307——申明请求的资源临时性删除</span><br><span class=\"line\"></span><br><span class=\"line\">4**(客户端错误类)：请求包含错误语法或不能正确执行</span><br><span class=\"line\">400——客户端请求有语法错误，不能被服务器所理解</span><br><span class=\"line\">401——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</span><br><span class=\"line\">HTTP 401.1 - 未授权：登录失败</span><br><span class=\"line\">　　HTTP 401.2 - 未授权：服务器配置问题导致登录失败</span><br><span class=\"line\">　　HTTP 401.3 - ACL 禁止访问资源</span><br><span class=\"line\">　　HTTP 401.4 - 未授权：授权被筛选器拒绝</span><br><span class=\"line\">HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败</span><br><span class=\"line\">402——保留有效ChargeTo头响应</span><br><span class=\"line\">403——禁止访问，服务器收到请求，但是拒绝提供服务</span><br><span class=\"line\">HTTP 403.1 禁止访问：禁止可执行访问</span><br><span class=\"line\">　　HTTP 403.2 - 禁止访问：禁止读访问</span><br><span class=\"line\">　　HTTP 403.3 - 禁止访问：禁止写访问</span><br><span class=\"line\">　　HTTP 403.4 - 禁止访问：要求 SSL</span><br><span class=\"line\">　　HTTP 403.5 - 禁止访问：要求 SSL 128</span><br><span class=\"line\">　　HTTP 403.6 - 禁止访问：IP 地址被拒绝</span><br><span class=\"line\">　　HTTP 403.7 - 禁止访问：要求客户证书</span><br><span class=\"line\">　　HTTP 403.8 - 禁止访问：禁止站点访问</span><br><span class=\"line\">　　HTTP 403.9 - 禁止访问：连接的用户过多</span><br><span class=\"line\">　　HTTP 403.10 - 禁止访问：配置无效</span><br><span class=\"line\">　　HTTP 403.11 - 禁止访问：密码更改</span><br><span class=\"line\">　　HTTP 403.12 - 禁止访问：映射器拒绝访问</span><br><span class=\"line\">　　HTTP 403.13 - 禁止访问：客户证书已被吊销</span><br><span class=\"line\">　　HTTP 403.15 - 禁止访问：客户访问许可过多</span><br><span class=\"line\">　　HTTP 403.16 - 禁止访问：客户证书不可信或者无效</span><br><span class=\"line\">HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效</span><br><span class=\"line\">404——一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL</span><br><span class=\"line\">405——用户在Request-Line字段定义的方法不允许</span><br><span class=\"line\">406——根据用户发送的Accept拖，请求资源不可访问</span><br><span class=\"line\">407——类似401，用户必须首先在代理服务器上得到授权</span><br><span class=\"line\">408——客户端没有在用户指定的饿时间内完成请求</span><br><span class=\"line\">409——对当前资源状态，请求不能完成</span><br><span class=\"line\">410——服务器上不再有此资源且无进一步的参考地址</span><br><span class=\"line\">411——服务器拒绝用户定义的Content-Length属性请求</span><br><span class=\"line\">412——一个或多个请求头字段在当前请求中错误</span><br><span class=\"line\">413——请求的资源大于服务器允许的大小</span><br><span class=\"line\">414——请求的资源URL长于服务器允许的长度</span><br><span class=\"line\">415——请求资源不支持请求项目格式</span><br><span class=\"line\">416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段</span><br><span class=\"line\">417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。</span><br><span class=\"line\"></span><br><span class=\"line\">5**(服务端错误类)：服务器不能正确执行一个正确的请求</span><br><span class=\"line\">HTTP 500 - 服务器遇到错误，无法完成请求</span><br><span class=\"line\">　　HTTP 500.100 - 内部服务器错误 - ASP 错误</span><br><span class=\"line\">　　HTTP 500-11 服务器关闭</span><br><span class=\"line\">　　HTTP 500-12 应用程序重新启动</span><br><span class=\"line\">　　HTTP 500-13 - 服务器太忙</span><br><span class=\"line\">　　HTTP 500-14 - 应用程序无效</span><br><span class=\"line\">　　HTTP 500-15 - 不允许请求 global.asa</span><br><span class=\"line\">　　Error 501 - 未实现</span><br><span class=\"line\">HTTP 502 - 网关错误</span><br><span class=\"line\">HTTP 503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常</span><br><span class=\"line\"></span><br><span class=\"line\">- 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）</span><br><span class=\"line\"></span><br><span class=\"line\">注：这题胜在区分度高，知识点覆盖广，再不懂的人，也能答出几句，</span><br><span class=\"line\">而高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、</span><br><span class=\"line\">到浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JS API绑定等等；</span><br><span class=\"line\"></span><br><span class=\"line\">详细版：</span><br><span class=\"line\">1、浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;</span><br><span class=\"line\">2、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;</span><br><span class=\"line\">3、通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;</span><br><span class=\"line\">4、进行HTTP协议会话，客户端发送报头(请求报头);</span><br><span class=\"line\">5、进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;</span><br><span class=\"line\">6、进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;</span><br><span class=\"line\">7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;</span><br><span class=\"line\">8、浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;</span><br><span class=\"line\">9、文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;</span><br><span class=\"line\">10、页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。</span><br><span class=\"line\"></span><br><span class=\"line\">简洁版：</span><br><span class=\"line\">浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；</span><br><span class=\"line\">服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；</span><br><span class=\"line\">浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；</span><br><span class=\"line\">载入解析到的资源文件，渲染页面，完成。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>部分地区用户反应网站很卡，请问有哪些可能性的原因，以及解决方法？</p>\n</li>\n<li><p>从打开app到刷新出内容，整个过程中都发生了什么，如果感觉慢，怎么定位问题，怎么解决?</p>\n</li>\n<li><p>除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？</p>\n</li>\n<li><p>你用的得心应手用的熟练地编辑器&amp;开发环境是什么样子？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sublime Text 3 + 相关插件编写前端代码</span><br><span class=\"line\">Google chrome 、Mozilla Firefox浏览器 +firebug 兼容测试和预览页面UI、动画效果和交互功能</span><br><span class=\"line\">Node.js+Gulp</span><br><span class=\"line\">git 用于版本控制和Code Review</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对前端工程师这个职位是怎么样理解的？它的前景会怎么样？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。</span><br><span class=\"line\">1、实现界面交互</span><br><span class=\"line\">2、提升用户体验</span><br><span class=\"line\">3、有了Node.js，前端可以实现服务端的一些事情</span><br><span class=\"line\"></span><br><span class=\"line\">前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，</span><br><span class=\"line\"></span><br><span class=\"line\">参与项目，快速高质量完成实现效果图，精确到1px；</span><br><span class=\"line\"></span><br><span class=\"line\">与团队成员，UI设计，产品经理的沟通；</span><br><span class=\"line\"></span><br><span class=\"line\">做好的页面结构，页面重构和用户体验；</span><br><span class=\"line\"></span><br><span class=\"line\">处理hack，兼容、写出优美的代码格式；</span><br><span class=\"line\"></span><br><span class=\"line\">针对服务器的优化、拥抱最新前端技术。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>你怎么看待Web App 、hybrid App、Native App？</p>\n</li>\n<li><p>你移动端前端开发的理解？（和 Web 前端开发的主要区别是什么？）</p>\n</li>\n<li><p>你对加班的看法？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">加班就像借钱，原则应当是------救急不救穷</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>平时如何管理你的项目？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等；</span><br><span class=\"line\"></span><br><span class=\"line\">编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；</span><br><span class=\"line\"></span><br><span class=\"line\">标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；</span><br><span class=\"line\"></span><br><span class=\"line\">页面进行标注（例如 页面 模块 开始和结束）；</span><br><span class=\"line\"></span><br><span class=\"line\">CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）；</span><br><span class=\"line\"></span><br><span class=\"line\">JS 分文件夹存放 命名以该JS功能为准的英文翻译。</span><br><span class=\"line\"></span><br><span class=\"line\">图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如何设计突发大规模并发架构？</p>\n</li>\n<li><p>当团队人手不足，把功能代码写完已经需要加班的情况下，你会做前端代码的测试吗？</p>\n</li>\n<li><p>说说最近最流行的一些东西吧？常去哪些网站？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ES6\\WebAssembly\\Node\\MVVM\\Web Components\\React\\React Native\\Webpack 组件化</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>知道什么是SEO并且怎么优化么? 知道各种meta data的含义么?</p>\n</li>\n<li><p>移动端（Android IOS）怎么做好用户体验?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">清晰的视觉纵线、</span><br><span class=\"line\">信息的分组、极致的减法、</span><br><span class=\"line\">利用选择代替输入、</span><br><span class=\"line\">标签及文字的排布方式、</span><br><span class=\"line\">依靠明文确认密码、</span><br><span class=\"line\">合理的键盘利用、</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>简单描述一下你做过的移动APP项目研发流程？</p>\n</li>\n<li><p>你在现在的团队处于什么样的角色，起到了什么明显的作用？</p>\n</li>\n<li><p>你认为怎样才是全端工程师（Full Stack developer）？</p>\n</li>\n<li><p>介绍一个你最得意的作品吧？</p>\n</li>\n<li><p>你有自己的技术博客吗，用了哪些技术？</p>\n</li>\n<li><p>对前端安全有什么看法？</p>\n</li>\n<li><p>是否了解Web注入攻击，说下原理，最常见的两种攻击（XSS 和 CSRF）了解到什么程度？</p>\n</li>\n<li><p>项目中遇到国哪些印象深刻的技术难题，具体是什么问题，怎么解决？。</p>\n</li>\n<li><p>最近在学什么东西？</p>\n</li>\n<li><p>你的优点是什么？缺点是什么？</p>\n</li>\n<li><p>如何管理前端团队?</p>\n</li>\n<li><p>最近在学什么？能谈谈你未来3，5年给自己的规划吗？</p>\n</li>\n</ul>\n<h2 id=\"前端学习网站推荐\"><a href=\"#前端学习网站推荐\" class=\"headerlink\" title=\"前端学习网站推荐\"></a><a name=\"web\">前端学习网站推荐</a></h2><p><a href=\"http://www.gbtags.com/\" target=\"_blank\" rel=\"noopener\">极客标签</a><br><a href=\"http://weekly.manong.io/issues/\" target=\"_blank\" rel=\"noopener\">码农周刊</a><br><a href=\"http://www.feweekly.com/issues\" target=\"_blank\" rel=\"noopener\">前端周刊</a><br><a href=\"http://www.imooc.com/\" target=\"_blank\" rel=\"noopener\">慕课网</a><br><a href=\"http://div.io\" target=\"_blank\" rel=\"noopener\">div.io</a><br><a href=\"https://news.ycombinator.com/news\" target=\"_blank\" rel=\"noopener\">Hacker News</a><br><a href=\"http://www.infoq.com/\" target=\"_blank\" rel=\"noopener\">InfoQ</a><br><a href=\"http://www.w3cplus.com/\" target=\"_blank\" rel=\"noopener\">w3cplus</a><br><a href=\"http://stackoverflow.com/\" target=\"_blank\" rel=\"noopener\">Stack Overflow</a><br><a href=\"http://www.w3school.com.cn/\" target=\"_blank\" rel=\"noopener\">w3school</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript\" target=\"_blank\" rel=\"noopener\">mozilla</a></p>\n<h2 id=\"文档推荐\"><a href=\"#文档推荐\" class=\"headerlink\" title=\"文档推荐\"></a><a name=\"web\">文档推荐</a></h2><ol>\n<li><p><a href=\"http://docs.huihoo.com/jquery/jquery-fundamentals/zh-cn/index.html\" title=\"jQuery 基本原理\" target=\"_blank\" rel=\"noopener\">jQuery 基本原理</a></p>\n</li>\n<li><p><a href=\"http://bonsaiden.github.io/JavaScript-Garden/zh/\" target=\"_blank\" rel=\"noopener\">JavaScript 秘密花园</a></p>\n</li>\n<li><p><a href=\"http://css.doyoe.com/\" target=\"_blank\" rel=\"noopener\">CSS参考手册</a></p>\n</li>\n<li><p><a href=\"http://javascript.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">JavaScript 标准参考教程</a></p>\n</li>\n<li><p><a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">ECMAScript 6入门</a></p>\n</li>\n</ol>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjtifjpsp0002lohik43ft61u","category_id":"cjtifjpst0004lohi5chd10lk","_id":"cjtifjpt5000elohi38zc614u"},{"post_id":"cjtifjpss0003lohid8idlid0","category_id":"cjtifjpt00009lohicsno5h9e","_id":"cjtifjptb000llohiqjnzf5ib"},{"post_id":"cjtifjpt8000hlohipircw2sh","category_id":"cjtifjpt00009lohicsno5h9e","_id":"cjtifjptd000plohidbq46kwo"},{"post_id":"cjtifjpsw0006lohiyryushpo","category_id":"cjtifjpt00009lohicsno5h9e","_id":"cjtifjptd000slohivgpuef1e"},{"post_id":"cjtifjptc000nlohi3vo6w05x","category_id":"cjtifjpt00009lohicsno5h9e","_id":"cjtifjpte000ulohie6jvduto"},{"post_id":"cjtifjpsz0008lohi9ootrfum","category_id":"cjtifjptb000klohid0geyguj","_id":"cjtifjpte000vlohi54xuaivi"},{"post_id":"cjtifjptm000zlohi3mnvx0z7","category_id":"cjtifjpt00009lohicsno5h9e","_id":"cjtifjptn0011lohi75hnpbzb"},{"post_id":"cjtifjpuj0013lohi5kvoj5l1","category_id":"cjtifjpt00009lohicsno5h9e","_id":"cjtifjpuk0015lohi06s9uc0t"}],"PostTag":[{"post_id":"cjtifjpsp0002lohik43ft61u","tag_id":"cjtifjpsv0005lohizc22oyye","_id":"cjtifjpt1000blohifgevtlgn"},{"post_id":"cjtifjpss0003lohid8idlid0","tag_id":"cjtifjpt0000alohiola28hii","_id":"cjtifjpt9000ilohipu5oz14g"},{"post_id":"cjtifjpsw0006lohiyryushpo","tag_id":"cjtifjpt6000glohi1bnmd4tp","_id":"cjtifjptc000olohinwcwlg43"},{"post_id":"cjtifjptc000nlohi3vo6w05x","tag_id":"cjtifjpt6000glohi1bnmd4tp","_id":"cjtifjptd000qlohiyym51kyh"},{"post_id":"cjtifjpsz0008lohi9ootrfum","tag_id":"cjtifjptb000mlohi36sa9mpg","_id":"cjtifjpte000tlohifsguqm8p"},{"post_id":"cjtifjpt8000hlohipircw2sh","tag_id":"cjtifjptd000rlohizs7st0y0","_id":"cjtifjpte000xlohimldjmtq6"},{"post_id":"cjtifjpt9000jlohid4fxwi2j","tag_id":"cjtifjpte000wlohiztrjb0id","_id":"cjtifjptg000ylohiyiow07nm"},{"post_id":"cjtifjptm000zlohi3mnvx0z7","tag_id":"cjtifjpt0000alohiola28hii","_id":"cjtifjptn0010lohi5msy63co"},{"post_id":"cjtifjpuj0013lohi5kvoj5l1","tag_id":"cjtifjpuk0014lohi7zgi82wb","_id":"cjtifjpuk0016lohichqad25p"}],"Tag":[{"name":"HTTP服务器","_id":"cjtifjpsv0005lohizc22oyye"},{"name":"Git","_id":"cjtifjpt0000alohiola28hii"},{"name":"Hexo","_id":"cjtifjpt6000glohi1bnmd4tp"},{"name":"Sublime","_id":"cjtifjptb000mlohi36sa9mpg"},{"name":"Gulp","_id":"cjtifjptd000rlohizs7st0y0"},{"name":"JavaScript","_id":"cjtifjpte000wlohiztrjb0id"},{"name":"面试","_id":"cjtifjpuk0014lohi7zgi82wb"}]}}